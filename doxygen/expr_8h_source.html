<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Intel SPMD Program Compiler: expr.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>expr.h</h1>  </div>
</div>
<div class="contents">
<a href="expr_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">  Copyright (c) 2010-2011, Intel Corporation</span>
<a name="l00003"></a>00003 <span class="comment">  All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">  Redistribution and use in source and binary forms, with or without</span>
<a name="l00006"></a>00006 <span class="comment">  modification, are permitted provided that the following conditions are</span>
<a name="l00007"></a>00007 <span class="comment">  met:</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">    * Redistributions of source code must retain the above copyright</span>
<a name="l00010"></a>00010 <span class="comment">      notice, this list of conditions and the following disclaimer.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">    * Redistributions in binary form must reproduce the above copyright</span>
<a name="l00013"></a>00013 <span class="comment">      notice, this list of conditions and the following disclaimer in the</span>
<a name="l00014"></a>00014 <span class="comment">      documentation and/or other materials provided with the distribution.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">    * Neither the name of Intel Corporation nor the names of its</span>
<a name="l00017"></a>00017 <span class="comment">      contributors may be used to endorse or promote products derived from</span>
<a name="l00018"></a>00018 <span class="comment">      this software without specific prior written permission.</span>
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment"></span>
<a name="l00021"></a>00021 <span class="comment">   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS</span>
<a name="l00022"></a>00022 <span class="comment">   IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED</span>
<a name="l00023"></a>00023 <span class="comment">   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A</span>
<a name="l00024"></a>00024 <span class="comment">   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER</span>
<a name="l00025"></a>00025 <span class="comment">   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
<a name="l00026"></a>00026 <span class="comment">   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</span>
<a name="l00027"></a>00027 <span class="comment">   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span>
<a name="l00028"></a>00028 <span class="comment">   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<a name="l00029"></a>00029 <span class="comment">   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<a name="l00030"></a>00030 <span class="comment">   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<a name="l00031"></a>00031 <span class="comment">   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  </span>
<a name="l00032"></a>00032 <span class="comment">*/</span>
<a name="l00033"></a>00033 <span class="comment"></span>
<a name="l00034"></a>00034 <span class="comment">/** @file expr.h</span>
<a name="l00035"></a>00035 <span class="comment">    @brief Expr abstract base class and expression implementations</span>
<a name="l00036"></a>00036 <span class="comment">*/</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="preprocessor">#ifndef ISPC_EXPR_H</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#define ISPC_EXPR_H 1</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="ispc_8h.html" title="Main ispc.header file.">ispc.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;ast.h&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;<a class="code" href="type_8h.html" title="File with declarations for classes related to type representation.">type.h</a>&quot;</span>
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="keyword">class </span><a class="code" href="classFunctionSymbolExpr.html" title="Expression representing a function symbol in the program (generally used for a function call)...">FunctionSymbolExpr</a>;
<a name="l00046"></a>00046 <span class="comment"></span>
<a name="l00047"></a>00047 <span class="comment">/** @brief Expr is the abstract base class that defines the interface that</span>
<a name="l00048"></a>00048 <span class="comment">    all expression types must implement.</span>
<a name="l00049"></a>00049 <span class="comment"> */</span>
<a name="l00050"></a><a class="code" href="classExpr.html">00050</a> <span class="keyword">class </span><a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> : <span class="keyword">public</span> <a class="code" href="classASTNode.html">ASTNode</a> {
<a name="l00051"></a>00051 <span class="keyword">public</span>:
<a name="l00052"></a><a class="code" href="classExpr.html#a2b863b1ee3b938b67f5b067142e94b96">00052</a>     <a class="code" href="classExpr.html#a2b863b1ee3b938b67f5b067142e94b96">Expr</a>(<a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p) : <a class="code" href="classASTNode.html">ASTNode</a>(p) { }
<a name="l00053"></a>00053 <span class="comment"></span>
<a name="l00054"></a>00054 <span class="comment">    /** This is the main method for Expr implementations to implement.  It</span>
<a name="l00055"></a>00055 <span class="comment">        should call methods in the FunctionEmitContext to emit LLVM IR</span>
<a name="l00056"></a>00056 <span class="comment">        instructions to the current basic block in order to generate an</span>
<a name="l00057"></a>00057 <span class="comment">        llvm::Value that represents the expression&#39;s value. */</span>
<a name="l00058"></a>00058     <span class="keyword">virtual</span> llvm::Value *<a class="code" href="classExpr.html#a2bc3d2bff41746985dd2b07d0637d7e8">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span> = 0;
<a name="l00059"></a>00059 <span class="comment"></span>
<a name="l00060"></a>00060 <span class="comment">    /** For expressions that can provide an lvalue (e.g. array indexing),</span>
<a name="l00061"></a>00061 <span class="comment">        this function should emit IR that computes the expression&#39;s lvalue</span>
<a name="l00062"></a>00062 <span class="comment">        and returns the corresponding llvm::Value.  Expressions that can&#39;t</span>
<a name="l00063"></a>00063 <span class="comment">        provide an lvalue should leave this unimplemented; the default</span>
<a name="l00064"></a>00064 <span class="comment">        implementation returns NULL.  */</span>
<a name="l00065"></a>00065     <span class="keyword">virtual</span> llvm::Value *<a class="code" href="classExpr.html#a9d3baf6e5f52fff8e916f3c0b5139c2e">GetLValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00066"></a>00066 <span class="comment"></span>
<a name="l00067"></a>00067 <span class="comment">    /** Returns the Type of the expression. */</span>
<a name="l00068"></a>00068     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classExpr.html#a8451d4988f430bea94e354dc44e6b094">GetType</a>() <span class="keyword">const</span> = 0;
<a name="l00069"></a>00069 <span class="comment"></span>
<a name="l00070"></a>00070 <span class="comment">    /** For expressions that have values based on a symbol (e.g. regular</span>
<a name="l00071"></a>00071 <span class="comment">        symbol references, array indexing, etc.), this returns a pointer to</span>
<a name="l00072"></a>00072 <span class="comment">        that symbol. */</span>
<a name="l00073"></a>00073     <span class="keyword">virtual</span> <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classExpr.html#a4219def5afcedd6551acf0954d2fa2de">GetBaseSymbol</a>() <span class="keyword">const</span>;
<a name="l00074"></a>00074 <span class="comment"></span>
<a name="l00075"></a>00075 <span class="comment">    /** If this is a constant expression that can be converted to a</span>
<a name="l00076"></a>00076 <span class="comment">        constant of the given type, this method should return the</span>
<a name="l00077"></a>00077 <span class="comment">        corresponding llvm::Constant value.  Otherwise it should return</span>
<a name="l00078"></a>00078 <span class="comment">        NULL. */</span>
<a name="l00079"></a>00079     <span class="keyword">virtual</span> llvm::Constant *<a class="code" href="classExpr.html#a0409d1bd3dae14b118bea8b8c28321db">GetConstant</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *type) <span class="keyword">const</span>;
<a name="l00080"></a>00080 <span class="comment"></span>
<a name="l00081"></a>00081 <span class="comment">    /** This method should perform early optimizations of the expression</span>
<a name="l00082"></a>00082 <span class="comment">        (constant folding, etc.) and return a pointer to the resulting</span>
<a name="l00083"></a>00083 <span class="comment">        expression.  If an error is encountered during optimization, NULL</span>
<a name="l00084"></a>00084 <span class="comment">        should be returned. */</span>
<a name="l00085"></a>00085     <span class="keyword">virtual</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classExpr.html#aeffa58fc4e9b2b058c1d3931caed2ae4">Optimize</a>() = 0;
<a name="l00086"></a>00086 <span class="comment"></span>
<a name="l00087"></a>00087 <span class="comment">    /** This method should perform type checking of the expression and</span>
<a name="l00088"></a>00088 <span class="comment">        return a pointer to the resulting expression.  If an error is</span>
<a name="l00089"></a>00089 <span class="comment">        encountered, NULL should be returned. */</span>
<a name="l00090"></a>00090     <span class="keyword">virtual</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classExpr.html#acf568bb978a23556c8e40f2662715190">TypeCheck</a>() = 0;
<a name="l00091"></a>00091 <span class="comment"></span>
<a name="l00092"></a>00092 <span class="comment">    /** Prints the expression to standard output (used for debugging). */</span>
<a name="l00093"></a>00093     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classExpr.html#ac8d62a881604e554c36ec30738163423">Print</a>() <span class="keyword">const</span> = 0;
<a name="l00094"></a>00094 <span class="comment"></span>
<a name="l00095"></a>00095 <span class="comment">    /** This method tries to convert the expression to the given type.  In</span>
<a name="l00096"></a>00096 <span class="comment">        the event of failure, if the failureOk parameter is true, then no</span>
<a name="l00097"></a>00097 <span class="comment">        error is issued.  If failureOk is false, then an error is printed</span>
<a name="l00098"></a>00098 <span class="comment">        that incorporates the given error message string.  In either</span>
<a name="l00099"></a>00099 <span class="comment">        failure case, NULL is returned.  */</span>
<a name="l00100"></a>00100     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classExpr.html#a691de1b4455845e85849cae086508d17">TypeConv</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *type, <span class="keyword">const</span> <span class="keywordtype">char</span> *errorMsgBase = NULL, 
<a name="l00101"></a>00101                    <span class="keywordtype">bool</span> failureOk = <span class="keyword">false</span>, <span class="keywordtype">bool</span> issuePrecisionWarnings = <span class="keyword">true</span>);
<a name="l00102"></a>00102 };
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="comment"></span>
<a name="l00105"></a>00105 <span class="comment">/** @brief Unary expression */</span>
<a name="l00106"></a><a class="code" href="classUnaryExpr.html">00106</a> <span class="keyword">class </span><a class="code" href="classUnaryExpr.html" title="Unary expression.">UnaryExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00107"></a>00107 <span class="keyword">public</span>:
<a name="l00108"></a><a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0a">00108</a>     <span class="keyword">enum</span> <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0a">Op</a> {
<a name="l00109"></a><a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aadbe199ac60697c535f0d43d0dba1551e">00109</a>         <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aadbe199ac60697c535f0d43d0dba1551e" title="Pre-increment.">PreInc</a>,      <span class="comment">///&lt; Pre-increment</span>
<a name="l00110"></a><a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aa8371682ef0e8c8db3e0b326eebd7fcf1">00110</a> <span class="comment"></span>        <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aa8371682ef0e8c8db3e0b326eebd7fcf1" title="Pre-decrement.">PreDec</a>,      <span class="comment">///&lt; Pre-decrement </span>
<a name="l00111"></a><a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aa60eca9776c0bbcf670ac1fe50c19b85e">00111</a> <span class="comment"></span>        <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aa60eca9776c0bbcf670ac1fe50c19b85e" title="Post-increment.">PostInc</a>,     <span class="comment">///&lt; Post-increment</span>
<a name="l00112"></a><a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aaccb7c3257ef012bb05bdae852e8687a1">00112</a> <span class="comment"></span>        <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aaccb7c3257ef012bb05bdae852e8687a1" title="Post-decrement.">PostDec</a>,     <span class="comment">///&lt; Post-decrement</span>
<a name="l00113"></a><a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aa5caf3ba4519a6caa706a217baf7b2fb6">00113</a> <span class="comment"></span>        <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aa5caf3ba4519a6caa706a217baf7b2fb6" title="Negation.">Negate</a>,      <span class="comment">///&lt; Negation</span>
<a name="l00114"></a><a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aae7624b1b76dfe31bfe2fb8a7bc42880c">00114</a> <span class="comment"></span>        <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aae7624b1b76dfe31bfe2fb8a7bc42880c" title="Logical not.">LogicalNot</a>,  <span class="comment">///&lt; Logical not</span>
<a name="l00115"></a><a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aae2154322c4d3e3dba3d8b3db175d14dd">00115</a> <span class="comment"></span>        <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aae2154322c4d3e3dba3d8b3db175d14dd" title="Bit not.">BitNot</a>,      <span class="comment">///&lt; Bit not</span>
<a name="l00116"></a>00116 <span class="comment"></span>    };
<a name="l00117"></a>00117 
<a name="l00118"></a>00118     <a class="code" href="classUnaryExpr.html#a0e246b4d1cd1c69a65ee17c22a9f750b">UnaryExpr</a>(<a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0a">Op</a> <a class="code" href="classUnaryExpr.html#a8e84e48189c8947262677076e591671a">op</a>, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classUnaryExpr.html#a7a56bea77b7439efa5d8ebd89d22ea93">expr</a>, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> pos);
<a name="l00119"></a>00119 
<a name="l00120"></a>00120     llvm::Value *<a class="code" href="classUnaryExpr.html#a491f1175afacdde2954235b8f6a28422">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00121"></a>00121     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classUnaryExpr.html#a147e436a4b1e55c93a8cf248fe326b14">GetType</a>() <span class="keyword">const</span>;
<a name="l00122"></a>00122     <span class="keywordtype">void</span> <a class="code" href="classUnaryExpr.html#aac9ba92c4f80a3afd341c44f85b656b2">Print</a>() <span class="keyword">const</span>;
<a name="l00123"></a>00123     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classUnaryExpr.html#aa4b660df9ce888e9cdbb675dbd44b300">Optimize</a>();
<a name="l00124"></a>00124     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classUnaryExpr.html#a4115b641cf51f20e4d0ae221c107ac88">TypeCheck</a>();
<a name="l00125"></a>00125     <span class="keywordtype">int</span> <a class="code" href="classUnaryExpr.html#a09ffadd5ecca89f8579932c3a949db38">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00126"></a>00126 
<a name="l00127"></a><a class="code" href="classUnaryExpr.html#a8e84e48189c8947262677076e591671a">00127</a>     <span class="keyword">const</span> <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0a">Op</a> <a class="code" href="classUnaryExpr.html#a8e84e48189c8947262677076e591671a">op</a>;
<a name="l00128"></a><a class="code" href="classUnaryExpr.html#a7a56bea77b7439efa5d8ebd89d22ea93">00128</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classUnaryExpr.html#a7a56bea77b7439efa5d8ebd89d22ea93">expr</a>;
<a name="l00129"></a>00129 };
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="comment"></span>
<a name="l00132"></a>00132 <span class="comment">/** @brief Binary expression */</span>
<a name="l00133"></a><a class="code" href="classBinaryExpr.html">00133</a> <span class="keyword">class </span><a class="code" href="classBinaryExpr.html" title="Binary expression.">BinaryExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00134"></a>00134 <span class="keyword">public</span>:
<a name="l00135"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7">00135</a>     <span class="keyword">enum</span> <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7">Op</a> {
<a name="l00136"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a4d239613f5b623d61ca5aafc19a9579b">00136</a>         <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a4d239613f5b623d61ca5aafc19a9579b" title="Addition.">Add</a>,           <span class="comment">///&lt; Addition</span>
<a name="l00137"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a94d438e3ae5c0d14e5dd2319e08bde70">00137</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a94d438e3ae5c0d14e5dd2319e08bde70" title="Subtraction.">Sub</a>,           <span class="comment">///&lt; Subtraction</span>
<a name="l00138"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a3d30be2a9c2b0ae23c3695b5b7c9157d">00138</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a3d30be2a9c2b0ae23c3695b5b7c9157d" title="Multiplication.">Mul</a>,           <span class="comment">///&lt; Multiplication</span>
<a name="l00139"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7aa082d01fa67760930edacb6e37123bf8">00139</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7aa082d01fa67760930edacb6e37123bf8" title="Division.">Div</a>,           <span class="comment">///&lt; Division</span>
<a name="l00140"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a2a253f235bd8731d71d986b690716684">00140</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a2a253f235bd8731d71d986b690716684" title="Modulus.">Mod</a>,           <span class="comment">///&lt; Modulus</span>
<a name="l00141"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ade0d8e8500caa6aa17e2e681ed181be5">00141</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ade0d8e8500caa6aa17e2e681ed181be5" title="Shift left.">Shl</a>,           <span class="comment">///&lt; Shift left</span>
<a name="l00142"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7afd39b7f6dac4983939e1c35fc0a347c0">00142</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7afd39b7f6dac4983939e1c35fc0a347c0" title="Shift right.">Shr</a>,           <span class="comment">///&lt; Shift right</span>
<a name="l00143"></a>00143 <span class="comment"></span>
<a name="l00144"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ae595fac49e25e1126a433042fedac896">00144</a>         <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ae595fac49e25e1126a433042fedac896" title="Less than.">Lt</a>,            <span class="comment">///&lt; Less than</span>
<a name="l00145"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a21c13d9affbb96afa4265d94b7143098">00145</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a21c13d9affbb96afa4265d94b7143098" title="Greater than.">Gt</a>,            <span class="comment">///&lt; Greater than</span>
<a name="l00146"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7afb132b34f0c41ae0920a40550a56a49f">00146</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7afb132b34f0c41ae0920a40550a56a49f" title="Less than or equal.">Le</a>,            <span class="comment">///&lt; Less than or equal</span>
<a name="l00147"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a71c2ab0a95fa191b1a3e7d8771838320">00147</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a71c2ab0a95fa191b1a3e7d8771838320" title="Greater than or equal.">Ge</a>,            <span class="comment">///&lt; Greater than or equal</span>
<a name="l00148"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ac63a25f6515cee23796c2a2aa2f39e57">00148</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ac63a25f6515cee23796c2a2aa2f39e57" title="Equal.">Equal</a>,         <span class="comment">///&lt; Equal</span>
<a name="l00149"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7aceb1c48a518a810d6c8c944b59c77ce3">00149</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7aceb1c48a518a810d6c8c944b59c77ce3" title="Not equal.">NotEqual</a>,      <span class="comment">///&lt; Not equal</span>
<a name="l00150"></a>00150 <span class="comment"></span>
<a name="l00151"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a8db0f4e01c01f1b975acefcd3ea203db">00151</a>         <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a8db0f4e01c01f1b975acefcd3ea203db" title="Bitwise AND.">BitAnd</a>,        <span class="comment">///&lt; Bitwise AND</span>
<a name="l00152"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7aac6763d96b8609f6530940952364d2f0">00152</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7aac6763d96b8609f6530940952364d2f0" title="Bitwise XOR.">BitXor</a>,        <span class="comment">///&lt; Bitwise XOR</span>
<a name="l00153"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ad4bf08b0ad65c931d59d45aa33c5e8e1">00153</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ad4bf08b0ad65c931d59d45aa33c5e8e1" title="Bitwise OR.">BitOr</a>,         <span class="comment">///&lt; Bitwise OR</span>
<a name="l00154"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a14bc6963fa4e11c06ada97069350de13">00154</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a14bc6963fa4e11c06ada97069350de13" title="Logical AND.">LogicalAnd</a>,    <span class="comment">///&lt; Logical AND</span>
<a name="l00155"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7af5c69ba861c4ebefe7ee64f90d416b96">00155</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7af5c69ba861c4ebefe7ee64f90d416b96" title="Logical OR.">LogicalOr</a>,     <span class="comment">///&lt; Logical OR</span>
<a name="l00156"></a>00156 <span class="comment"></span>
<a name="l00157"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ab20da151044a48f0047fa472bfaab97a">00157</a>         <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ab20da151044a48f0047fa472bfaab97a" title="Comma operator.">Comma</a>,         <span class="comment">///&lt; Comma operator</span>
<a name="l00158"></a>00158 <span class="comment"></span>    };
<a name="l00159"></a>00159 
<a name="l00160"></a>00160     <a class="code" href="classBinaryExpr.html#ab6205e08dbd56c3296b7eba91b065804">BinaryExpr</a>(<a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7">Op</a> o, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *a, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *b, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00161"></a>00161 
<a name="l00162"></a>00162     llvm::Value *<a class="code" href="classBinaryExpr.html#ac206ff9a04679c064cdb3d8daf1eb75d">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00163"></a>00163     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classBinaryExpr.html#ab809b2190a5d9b87436cbfd0fd537299">GetType</a>() <span class="keyword">const</span>;
<a name="l00164"></a>00164     <span class="keywordtype">void</span> <a class="code" href="classBinaryExpr.html#a53f62e7751853080719f415346fc770d">Print</a>() <span class="keyword">const</span>;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classBinaryExpr.html#afa938a1d4e8651bdd5eb833971258549">Optimize</a>();
<a name="l00167"></a>00167     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classBinaryExpr.html#a7dd0352a3b80f1fd4d50475b1722dffb">TypeCheck</a>();
<a name="l00168"></a>00168     <span class="keywordtype">int</span> <a class="code" href="classBinaryExpr.html#a5b6541c2d840ca2c741ade6cfb948642">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00169"></a>00169 
<a name="l00170"></a><a class="code" href="classBinaryExpr.html#a24c2764ba06e0d2e6c5f032833ae15c7">00170</a>     <span class="keyword">const</span> <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7">Op</a> <a class="code" href="classBinaryExpr.html#a24c2764ba06e0d2e6c5f032833ae15c7">op</a>;
<a name="l00171"></a><a class="code" href="classBinaryExpr.html#a40c0076587fdb4909f804a24ec7d826c">00171</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classBinaryExpr.html#a53fab112d99338b92775b99b9a1fe54c">arg0</a>, *<a class="code" href="classBinaryExpr.html#a40c0076587fdb4909f804a24ec7d826c">arg1</a>;
<a name="l00172"></a>00172 };
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <span class="comment"></span>
<a name="l00175"></a>00175 <span class="comment">/** @brief Assignment expression */</span>
<a name="l00176"></a><a class="code" href="classAssignExpr.html">00176</a> <span class="keyword">class </span><a class="code" href="classAssignExpr.html" title="Assignment expression.">AssignExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00177"></a>00177 <span class="keyword">public</span>:
<a name="l00178"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7">00178</a>     <span class="keyword">enum</span> <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7">Op</a> {
<a name="l00179"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7ad90801d98b08e2c00dd356dc0bc0db09">00179</a>         <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7ad90801d98b08e2c00dd356dc0bc0db09" title="Regular assignment.">Assign</a>,     <span class="comment">///&lt; Regular assignment</span>
<a name="l00180"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a91cd72fee59a49ed86ebefabe1b06364">00180</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a91cd72fee59a49ed86ebefabe1b06364" title="*= assignment">MulAssign</a>,  <span class="comment">///&lt; *= assignment</span>
<a name="l00181"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7ab888b5b6e6e40d35de2c668094470b1d">00181</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7ab888b5b6e6e40d35de2c668094470b1d" title="/= assignment">DivAssign</a>,  <span class="comment">///&lt; /= assignment</span>
<a name="l00182"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7af3710fce9debc5c64349ab31b4d511f8">00182</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7af3710fce9debc5c64349ab31b4d511f8" title="= assignment">ModAssign</a>,  <span class="comment">///&lt; %= assignment</span>
<a name="l00183"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a7f7e3daf7a8703a56562c5728ba1ad43">00183</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a7f7e3daf7a8703a56562c5728ba1ad43" title="+= assignment">AddAssign</a>,  <span class="comment">///&lt; += assignment</span>
<a name="l00184"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a5f7ed24dfe200a7928097cfe60923788">00184</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a5f7ed24dfe200a7928097cfe60923788" title="-= assignment">SubAssign</a>,  <span class="comment">///&lt; -= assignment</span>
<a name="l00185"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7aa562230af04e0411aec26a87164ebd4d">00185</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7aa562230af04e0411aec26a87164ebd4d" title="&amp;lt;&amp;lt;= assignment">ShlAssign</a>,  <span class="comment">///&lt; &lt;&lt;= assignment</span>
<a name="l00186"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a75107016d9d4ccf939e19537f7dd489c">00186</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a75107016d9d4ccf939e19537f7dd489c" title="&amp;gt;&amp;gt;= assignment">ShrAssign</a>,  <span class="comment">///&lt; &gt;&gt;= assignment</span>
<a name="l00187"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a9328aafd76c18d673d373fac04e48632">00187</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a9328aafd76c18d673d373fac04e48632" title="&amp;amp;= assignment">AndAssign</a>,  <span class="comment">///&lt; &amp;= assignment</span>
<a name="l00188"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a72f2976ebc5d2bcd13f4ec58ab387c22">00188</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a72f2976ebc5d2bcd13f4ec58ab387c22" title="^= assignment">XorAssign</a>,  <span class="comment">///&lt; ^= assignment</span>
<a name="l00189"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a17c0a5f02f9f497b23944fde67faf2b9">00189</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a17c0a5f02f9f497b23944fde67faf2b9" title="|= assignment">OrAssign</a>,   <span class="comment">///&lt; |= assignment</span>
<a name="l00190"></a>00190 <span class="comment"></span>    };
<a name="l00191"></a>00191 
<a name="l00192"></a>00192     <a class="code" href="classAssignExpr.html#a481beb8bc02efab8a5a4622f8c598e4e">AssignExpr</a>(<a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7">Op</a> o, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *a, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *b, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00193"></a>00193 
<a name="l00194"></a>00194     llvm::Value *<a class="code" href="classAssignExpr.html#a527fd9d588f58374323cdde588446d58">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00195"></a>00195     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classAssignExpr.html#a4914217b2b4fb6daff53db2e37d5d86d">GetType</a>() <span class="keyword">const</span>;
<a name="l00196"></a>00196     <span class="keywordtype">void</span> <a class="code" href="classAssignExpr.html#acb10431425b736c805e690873853fe20">Print</a>() <span class="keyword">const</span>;
<a name="l00197"></a>00197 
<a name="l00198"></a>00198     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classAssignExpr.html#a95ce9f096271957877412af17694a8ab">Optimize</a>();
<a name="l00199"></a>00199     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classAssignExpr.html#a7e964f6043f50c1d9c52a1a1f7fd2189">TypeCheck</a>();
<a name="l00200"></a>00200     <span class="keywordtype">int</span> <a class="code" href="classAssignExpr.html#af1cecb2f836fd9c607b51e18af214b5d">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00201"></a>00201 
<a name="l00202"></a><a class="code" href="classAssignExpr.html#a8ff67a87545cdf43cefd0481d0a6745a">00202</a>     <span class="keyword">const</span> <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7">Op</a> <a class="code" href="classAssignExpr.html#a8ff67a87545cdf43cefd0481d0a6745a">op</a>;
<a name="l00203"></a><a class="code" href="classAssignExpr.html#aecf688d3498a87e53d60925d072a1c2f">00203</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classAssignExpr.html#aa6ef7de40103442b6094b990ce883264">lvalue</a>, *<a class="code" href="classAssignExpr.html#aecf688d3498a87e53d60925d072a1c2f">rvalue</a>;
<a name="l00204"></a>00204 };
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 <span class="comment"></span>
<a name="l00207"></a>00207 <span class="comment">/** @brief Selection expression, corresponding to &quot;test ? a : b&quot;.  </span>
<a name="l00208"></a>00208 <span class="comment"></span>
<a name="l00209"></a>00209 <span class="comment">    Returns the value of &quot;a&quot; or &quot;b&quot;, depending on the value of &quot;test&quot;.</span>
<a name="l00210"></a>00210 <span class="comment">*/</span>
<a name="l00211"></a><a class="code" href="classSelectExpr.html">00211</a> <span class="keyword">class </span><a class="code" href="classSelectExpr.html" title="Selection expression, corresponding to &amp;quot;test ? a : b&amp;quot;.">SelectExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00212"></a>00212 <span class="keyword">public</span>:
<a name="l00213"></a>00213     <a class="code" href="classSelectExpr.html#abbf3ced36cd78acc07b566890e677661">SelectExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSelectExpr.html#aad8d842fd03005cec3407ee6205d43e5">test</a>, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *a, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *b, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00214"></a>00214 
<a name="l00215"></a>00215     llvm::Value *<a class="code" href="classSelectExpr.html#ae1e4d610d23390bbb7c8083c141d3995">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00216"></a>00216     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classSelectExpr.html#af36485eda148b293bfda30058aa04bf8">GetType</a>() <span class="keyword">const</span>;
<a name="l00217"></a>00217     <span class="keywordtype">void</span> <a class="code" href="classSelectExpr.html#aecfb71a8752639e6eab5b5be7e41c287">Print</a>() <span class="keyword">const</span>;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSelectExpr.html#a29a19cbf6bff81b79c90fe8c5fc5c2f2">Optimize</a>();
<a name="l00220"></a>00220     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSelectExpr.html#a64f9e0c37a4d553908fa0564aeaafd51">TypeCheck</a>();
<a name="l00221"></a>00221     <span class="keywordtype">int</span> <a class="code" href="classSelectExpr.html#add075184fbef1f53da066c2bc08dd4cb">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00222"></a>00222 
<a name="l00223"></a><a class="code" href="classSelectExpr.html#aad8d842fd03005cec3407ee6205d43e5">00223</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSelectExpr.html#aad8d842fd03005cec3407ee6205d43e5">test</a>, *<a class="code" href="classSelectExpr.html#aec302429bf4a9ede1e2cf83171acd25c">expr1</a>, *<a class="code" href="classSelectExpr.html#aaf702b20175ad070b01f1cb56456c31b">expr2</a>;
<a name="l00224"></a>00224 };
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 <span class="comment"></span>
<a name="l00227"></a>00227 <span class="comment">/** @brief A list of expressions.</span>
<a name="l00228"></a>00228 <span class="comment"></span>
<a name="l00229"></a>00229 <span class="comment">    These are mostly used for representing curly-brace delimited</span>
<a name="l00230"></a>00230 <span class="comment">    initializers for initializers for complex types and for representing</span>
<a name="l00231"></a>00231 <span class="comment">    the arguments passed to a function call.</span>
<a name="l00232"></a>00232 <span class="comment"> */</span>
<a name="l00233"></a><a class="code" href="classExprList.html">00233</a> <span class="keyword">class </span><a class="code" href="classExprList.html" title="A list of expressions.">ExprList</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00234"></a>00234 <span class="keyword">public</span>:
<a name="l00235"></a><a class="code" href="classExprList.html#a1175ee87aef8ed69163eed7cca496d7a">00235</a>     <a class="code" href="classExprList.html#a1175ee87aef8ed69163eed7cca496d7a">ExprList</a>(<a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p) : <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a>(p) { }
<a name="l00236"></a><a class="code" href="classExprList.html#a6bc3e30fcacbb152e820ccfb525a4410">00236</a>     <a class="code" href="classExprList.html#a6bc3e30fcacbb152e820ccfb525a4410">ExprList</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *e, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p) : <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a>(p) { <a class="code" href="classExprList.html#a701a2dc534fd40e2255bdb1b397daa5e">exprs</a>.push_back(e); }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238     llvm::Value *<a class="code" href="classExprList.html#abef2a40a1830dfa69de153d832de2f82">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00239"></a>00239     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classExprList.html#a249e57b34809b0cac782400c9cfb64ab">GetType</a>() <span class="keyword">const</span>;
<a name="l00240"></a>00240     <span class="keywordtype">void</span> <a class="code" href="classExprList.html#aabfced5c0665aafcb4e0930b3ace96bc">Print</a>() <span class="keyword">const</span>;
<a name="l00241"></a>00241     llvm::Constant *<a class="code" href="classExprList.html#aca19946ae96cc4343cc5300a11005abd">GetConstant</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *type) <span class="keyword">const</span>;
<a name="l00242"></a>00242     <a class="code" href="classExprList.html" title="A list of expressions.">ExprList</a> *<a class="code" href="classExprList.html#a6b2b90afd6a278bdf8e1b865fb7354bc">Optimize</a>();
<a name="l00243"></a>00243     <a class="code" href="classExprList.html" title="A list of expressions.">ExprList</a> *<a class="code" href="classExprList.html#a46530e3ccea4a4b3f742cd892795adc1">TypeCheck</a>();
<a name="l00244"></a>00244     <span class="keywordtype">int</span> <a class="code" href="classExprList.html#acb97b512c61c17fa3413378f4cd30ef9">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00245"></a>00245 
<a name="l00246"></a><a class="code" href="classExprList.html#a701a2dc534fd40e2255bdb1b397daa5e">00246</a>     std::vector&lt;Expr *&gt; <a class="code" href="classExprList.html#a701a2dc534fd40e2255bdb1b397daa5e">exprs</a>;
<a name="l00247"></a>00247 };
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 <span class="comment"></span>
<a name="l00250"></a>00250 <span class="comment">/** @brief Expression representing a function call.</span>
<a name="l00251"></a>00251 <span class="comment"> */</span>
<a name="l00252"></a><a class="code" href="classFunctionCallExpr.html">00252</a> <span class="keyword">class </span><a class="code" href="classFunctionCallExpr.html" title="Expression representing a function call.">FunctionCallExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00253"></a>00253 <span class="keyword">public</span>:
<a name="l00254"></a>00254     <a class="code" href="classFunctionCallExpr.html#ac0ffc59913a8d284d198fb3418ddb344">FunctionCallExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classFunctionCallExpr.html#a96c712c3358aa3cc6241de1b31d94c33">func</a>, <a class="code" href="classExprList.html" title="A list of expressions.">ExprList</a> *<a class="code" href="classFunctionCallExpr.html#a6efde7be3cd2d9d00dc56e77f82b0ed2">args</a>, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p, 
<a name="l00255"></a>00255                      <span class="keywordtype">bool</span> <a class="code" href="classFunctionCallExpr.html#a65977190d50b009c400133cae808ff73">isLaunch</a> = <span class="keyword">false</span>, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classFunctionCallExpr.html#a06c8f7d411ed1fe49d5fd3a136e40755">launchCountExpr</a> = <a class="code" href="parse_8yy.html">NULL</a>);
<a name="l00256"></a>00256 
<a name="l00257"></a>00257     llvm::Value *<a class="code" href="classFunctionCallExpr.html#afa94cbe916b34082c3f2416bdbfd4d09">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00258"></a>00258     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classFunctionCallExpr.html#a895bf78acf9ace26dfadc3d3a5f0b72f">GetType</a>() <span class="keyword">const</span>;
<a name="l00259"></a>00259     <span class="keywordtype">void</span> <a class="code" href="classFunctionCallExpr.html#a0cae5ed0975f86d698e63dd164940961">Print</a>() <span class="keyword">const</span>;
<a name="l00260"></a>00260 
<a name="l00261"></a>00261     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classFunctionCallExpr.html#a0daf3c50beaf41b0e00ba6bbd9e40290">Optimize</a>();
<a name="l00262"></a>00262     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classFunctionCallExpr.html#a64b54547c7a84c245197fd6c94bccbef">TypeCheck</a>();
<a name="l00263"></a>00263     <span class="keywordtype">int</span> <a class="code" href="classFunctionCallExpr.html#a8dc8285ec7b28ed1b0770dde0da5965c">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00264"></a>00264 
<a name="l00265"></a><a class="code" href="classFunctionCallExpr.html#a96c712c3358aa3cc6241de1b31d94c33">00265</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classFunctionCallExpr.html#a96c712c3358aa3cc6241de1b31d94c33">func</a>;
<a name="l00266"></a><a class="code" href="classFunctionCallExpr.html#a6efde7be3cd2d9d00dc56e77f82b0ed2">00266</a>     <a class="code" href="classExprList.html" title="A list of expressions.">ExprList</a> *<a class="code" href="classFunctionCallExpr.html#a6efde7be3cd2d9d00dc56e77f82b0ed2">args</a>;
<a name="l00267"></a><a class="code" href="classFunctionCallExpr.html#a65977190d50b009c400133cae808ff73">00267</a>     <span class="keywordtype">bool</span> <a class="code" href="classFunctionCallExpr.html#a65977190d50b009c400133cae808ff73">isLaunch</a>;
<a name="l00268"></a><a class="code" href="classFunctionCallExpr.html#a06c8f7d411ed1fe49d5fd3a136e40755">00268</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classFunctionCallExpr.html#a06c8f7d411ed1fe49d5fd3a136e40755">launchCountExpr</a>;
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 <span class="keyword">private</span>:
<a name="l00271"></a>00271     <span class="keywordtype">void</span> <a class="code" href="classFunctionCallExpr.html#a6e9a76e6edf6621cb20cb9e7b85d4942">resolveFunctionOverloads</a>(<span class="keywordtype">bool</span> exactMatchOnly);
<a name="l00272"></a>00272     <span class="keywordtype">bool</span> <a class="code" href="classFunctionCallExpr.html#ae421b491c20dfc8d79f1406151b65d0e">tryResolve</a>(<span class="keywordtype">bool</span> (*matchFunc)(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *, <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *));
<a name="l00273"></a>00273 };
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="comment"></span>
<a name="l00276"></a>00276 <span class="comment">/** @brief Expression representing indexing into something with an integer</span>
<a name="l00277"></a>00277 <span class="comment">    offset.</span>
<a name="l00278"></a>00278 <span class="comment"></span>
<a name="l00279"></a>00279 <span class="comment">    This is used for both array indexing and indexing into VectorTypes. </span>
<a name="l00280"></a>00280 <span class="comment">*/</span>
<a name="l00281"></a><a class="code" href="classIndexExpr.html">00281</a> <span class="keyword">class </span><a class="code" href="classIndexExpr.html" title="Expression representing indexing into something with an integer offset.">IndexExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00282"></a>00282 <span class="keyword">public</span>:
<a name="l00283"></a>00283     <a class="code" href="classIndexExpr.html#a5bcc8cf69f451d7fe4c05a3a58ac0898">IndexExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classIndexExpr.html#aeeb32b6210d9c1f6d6eec115a0adee89">arrayOrVector</a>, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classIndexExpr.html#a5e06e65bf953e30ec2c518f528a439aa">index</a>, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00284"></a>00284 
<a name="l00285"></a>00285     llvm::Value *<a class="code" href="classIndexExpr.html#a3519954d20ca149e07881ce9e42ce684">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00286"></a>00286     llvm::Value *<a class="code" href="classIndexExpr.html#add9accb4f2423d5a3a8d7f9daa26ca1b">GetLValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00287"></a>00287     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classIndexExpr.html#a9f8efbad35c616ce4ef2368e20d087de">GetType</a>() <span class="keyword">const</span>;
<a name="l00288"></a>00288     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classIndexExpr.html#a39433a242e1bf61b3e361b350370d3d5">GetBaseSymbol</a>() <span class="keyword">const</span>;
<a name="l00289"></a>00289     <span class="keywordtype">void</span> <a class="code" href="classIndexExpr.html#a25fe1d6b6345c272d4fc46e83fa21e2b">Print</a>() <span class="keyword">const</span>;
<a name="l00290"></a>00290 
<a name="l00291"></a>00291     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classIndexExpr.html#a2b3e70bbdb74839fd1e53c8000b7440a">Optimize</a>();
<a name="l00292"></a>00292     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classIndexExpr.html#ac5d495e5df9cff4bbcbc9b580ea67fb7">TypeCheck</a>();
<a name="l00293"></a>00293     <span class="keywordtype">int</span> <a class="code" href="classIndexExpr.html#a52015acb426e8358dffe9b2e9ddfec07">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00294"></a>00294 
<a name="l00295"></a><a class="code" href="classIndexExpr.html#a5e06e65bf953e30ec2c518f528a439aa">00295</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classIndexExpr.html#aeeb32b6210d9c1f6d6eec115a0adee89">arrayOrVector</a>, *<a class="code" href="classIndexExpr.html#a5e06e65bf953e30ec2c518f528a439aa">index</a>;
<a name="l00296"></a>00296 };
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 <span class="comment"></span>
<a name="l00299"></a>00299 <span class="comment">/** @brief Expression representing member selection (&quot;foo.bar&quot;).</span>
<a name="l00300"></a>00300 <span class="comment"> *</span>
<a name="l00301"></a>00301 <span class="comment"> *  This will also be overloaded to deal with swizzles.</span>
<a name="l00302"></a>00302 <span class="comment"> */</span>
<a name="l00303"></a><a class="code" href="classMemberExpr.html">00303</a> <span class="keyword">class </span><a class="code" href="classMemberExpr.html" title="Expression representing member selection (&amp;quot;foo.bar&amp;quot;).">MemberExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00304"></a>00304 <span class="keyword">public</span>:
<a name="l00305"></a>00305     <span class="keyword">static</span> <a class="code" href="classMemberExpr.html" title="Expression representing member selection (&amp;quot;foo.bar&amp;quot;).">MemberExpr</a>* <a class="code" href="classMemberExpr.html#a4209eba290a54bcf637b1ad6d9a1eff9">create</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classMemberExpr.html#ae09b937def8c157105dcb5b6c74e0895">expr</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classMemberExpr.html#a22de65e0dd262aafaf0c5bd41292c72c">identifier</a>,
<a name="l00306"></a>00306                               <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> pos, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> <a class="code" href="classMemberExpr.html#a2aef07630b33e8fc186ad6aed64489bb">identifierPos</a>);
<a name="l00307"></a>00307 
<a name="l00308"></a>00308     <a class="code" href="classMemberExpr.html#a68a9e06d6b8d6dfef9f4b7b16493c57f">MemberExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *expr, <span class="keyword">const</span> <span class="keywordtype">char</span> *identifier, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> pos, 
<a name="l00309"></a>00309                <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> identifierPos);
<a name="l00310"></a>00310 
<a name="l00311"></a>00311     llvm::Value *<a class="code" href="classMemberExpr.html#a7d146e8f7ca8011a32e09a09fe506f7b">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00312"></a>00312     llvm::Value *<a class="code" href="classMemberExpr.html#acd46ec0f9bf97132fccc5649a0b279ef">GetLValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00313"></a>00313     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classMemberExpr.html#a618e9c9658998e410383b63a2b5c635e">GetType</a>() <span class="keyword">const</span>;
<a name="l00314"></a>00314     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classMemberExpr.html#a7a3bd3494a146748d6963acea9cf1c13">GetBaseSymbol</a>() <span class="keyword">const</span>;
<a name="l00315"></a>00315     <span class="keywordtype">void</span> <a class="code" href="classMemberExpr.html#ab7c0cf67c57e645b095fefef16764c9e">Print</a>() <span class="keyword">const</span>;
<a name="l00316"></a>00316     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classMemberExpr.html#a5295ee2a6a6afdce1fe3a1d05d54836b">Optimize</a>();
<a name="l00317"></a>00317     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classMemberExpr.html#a118f925d1f975296a0083097196a20d5">TypeCheck</a>();
<a name="l00318"></a>00318     <span class="keywordtype">int</span> <a class="code" href="classMemberExpr.html#acf15d8e397cd8fe113cfb9d0e560d6a7">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00319"></a>00319 
<a name="l00320"></a>00320     <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classMemberExpr.html#a22ef5f5ea7aa99b0d3240cd4620f5797">getElementNumber</a>() <span class="keyword">const</span>;
<a name="l00321"></a>00321 
<a name="l00322"></a>00322     std::string <a class="code" href="classMemberExpr.html#a937295319c4e5de2b0b80aca53927eda">getCandidateNearMatches</a>() <span class="keyword">const</span>;
<a name="l00323"></a>00323 
<a name="l00324"></a><a class="code" href="classMemberExpr.html#ae09b937def8c157105dcb5b6c74e0895">00324</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classMemberExpr.html#ae09b937def8c157105dcb5b6c74e0895">expr</a>;
<a name="l00325"></a><a class="code" href="classMemberExpr.html#a22de65e0dd262aafaf0c5bd41292c72c">00325</a>     std::string <a class="code" href="classMemberExpr.html#a22de65e0dd262aafaf0c5bd41292c72c">identifier</a>;
<a name="l00326"></a><a class="code" href="classMemberExpr.html#a2aef07630b33e8fc186ad6aed64489bb">00326</a>     <span class="keyword">const</span> <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> <a class="code" href="classMemberExpr.html#a2aef07630b33e8fc186ad6aed64489bb">identifierPos</a>;
<a name="l00327"></a>00327 };
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 <span class="comment"></span>
<a name="l00330"></a>00330 <span class="comment">/** @brief Expression representing a compile-time constant value.  </span>
<a name="l00331"></a>00331 <span class="comment"></span>
<a name="l00332"></a>00332 <span class="comment">    This class can currently represent compile-time constants of anything</span>
<a name="l00333"></a>00333 <span class="comment">    that is an AtomicType or an EnumType; for anything more complex, we</span>
<a name="l00334"></a>00334 <span class="comment">    don&#39;t currently have a representation of a compile-time constant that</span>
<a name="l00335"></a>00335 <span class="comment">    can be further reasoned about.</span>
<a name="l00336"></a>00336 <span class="comment"> */</span>
<a name="l00337"></a><a class="code" href="classConstExpr.html">00337</a> <span class="keyword">class </span><a class="code" href="classConstExpr.html" title="Expression representing a compile-time constant value.">ConstExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00338"></a>00338 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l00339"></a>00339 <span class="comment">    /** Create a ConstExpr from a uniform int8 value */</span>
<a name="l00340"></a>00340     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, int8_t i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00341"></a>00341 <span class="comment">    /** Create a ConstExpr from a varying int8 value */</span>
<a name="l00342"></a>00342     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, int8_t *i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00343"></a>00343 <span class="comment">    /** Create a ConstExpr from a uniform uint8 value */</span>
<a name="l00344"></a>00344     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, uint8_t u, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00345"></a>00345 <span class="comment">    /** Create a ConstExpr from a varying uint8 value */</span>
<a name="l00346"></a>00346     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, uint8_t *u, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00347"></a>00347 <span class="comment"></span>
<a name="l00348"></a>00348 <span class="comment">    /** Create a ConstExpr from a uniform int16 value */</span>
<a name="l00349"></a>00349     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, int16_t i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00350"></a>00350 <span class="comment">    /** Create a ConstExpr from a varying int16 value */</span>
<a name="l00351"></a>00351     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, int16_t *i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00352"></a>00352 <span class="comment">    /** Create a ConstExpr from a uniform uint16 value */</span>
<a name="l00353"></a>00353     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, uint16_t u, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00354"></a>00354 <span class="comment">    /** Create a ConstExpr from a varying uint16 value */</span>
<a name="l00355"></a>00355     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, uint16_t *u, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00356"></a>00356 <span class="comment"></span>
<a name="l00357"></a>00357 <span class="comment">    /** Create a ConstExpr from a uniform int32 value */</span>
<a name="l00358"></a>00358     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <a class="code" href="parse_8yy.html#a10e8b2d266b06d06f972396bf71af292">int32_t</a> i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00359"></a>00359 <span class="comment">    /** Create a ConstExpr from a varying int32 value */</span>
<a name="l00360"></a>00360     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <a class="code" href="parse_8yy.html#a10e8b2d266b06d06f972396bf71af292">int32_t</a> *i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00361"></a>00361 <span class="comment">    /** Create a ConstExpr from a uniform uint32 value */</span>
<a name="l00362"></a>00362     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, uint32_t u, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00363"></a>00363 <span class="comment">    /** Create a ConstExpr from a varying uint32 value */</span>
<a name="l00364"></a>00364     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, uint32_t *u, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00365"></a>00365 <span class="comment"></span>
<a name="l00366"></a>00366 <span class="comment">    /** Create a ConstExpr from a uniform float value */</span>
<a name="l00367"></a>00367     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <span class="keywordtype">float</span> f, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00368"></a>00368 <span class="comment">    /** Create a ConstExpr from a varying float value */</span>
<a name="l00369"></a>00369     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <span class="keywordtype">float</span> *f, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00370"></a>00370 <span class="comment"></span>
<a name="l00371"></a>00371 <span class="comment">    /** Create a ConstExpr from a uniform double value */</span>
<a name="l00372"></a>00372     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <span class="keywordtype">double</span> d, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00373"></a>00373 <span class="comment">    /** Create a ConstExpr from a varying double value */</span>
<a name="l00374"></a>00374     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <span class="keywordtype">double</span> *d, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00375"></a>00375 <span class="comment"></span>
<a name="l00376"></a>00376 <span class="comment">    /** Create a ConstExpr from a uniform int64 value */</span>
<a name="l00377"></a>00377     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, int64_t i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00378"></a>00378 <span class="comment">    /** Create a ConstExpr from a varying int64 value */</span>
<a name="l00379"></a>00379     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, int64_t *i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00380"></a>00380 <span class="comment">    /** Create a ConstExpr from a uniform uint64 value */</span>
<a name="l00381"></a>00381     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, uint64_t i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00382"></a>00382 <span class="comment">    /** Create a ConstExpr from a varying uint64 value */</span>
<a name="l00383"></a>00383     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, uint64_t *i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00384"></a>00384 <span class="comment"></span>
<a name="l00385"></a>00385 <span class="comment">    /** Create a ConstExpr from a uniform bool value */</span>
<a name="l00386"></a>00386     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <span class="keywordtype">bool</span> b, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00387"></a>00387 <span class="comment">    /** Create a ConstExpr from a varying bool value */</span>
<a name="l00388"></a>00388     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <span class="keywordtype">bool</span> *b, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00389"></a>00389 <span class="comment"></span>
<a name="l00390"></a>00390 <span class="comment">    /** Create a ConstExpr of the same type as the given old ConstExpr,</span>
<a name="l00391"></a>00391 <span class="comment">        with values given by the &quot;vales&quot; parameter. */</span>
<a name="l00392"></a>00392     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<a class="code" href="classConstExpr.html" title="Expression representing a compile-time constant value.">ConstExpr</a> *old, <span class="keywordtype">double</span> *values);
<a name="l00393"></a>00393 
<a name="l00394"></a>00394     llvm::Value *<a class="code" href="classConstExpr.html#ab7c1e025525bcea04483d6bbad936f9f">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00395"></a>00395     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classConstExpr.html#aebfe3a498ef43a1e47f3971247d9e375">GetType</a>() <span class="keyword">const</span>;
<a name="l00396"></a>00396     <span class="keywordtype">void</span> <a class="code" href="classConstExpr.html#a849abf21d9b9e710eaf8ae8ffb39f834">Print</a>() <span class="keyword">const</span>;
<a name="l00397"></a>00397     llvm::Constant *<a class="code" href="classConstExpr.html#a8efa14af7143740d74b91014aa1bff93">GetConstant</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classConstExpr.html#ad8eaecdf8a562262140ba193cb4d298d">type</a>) <span class="keyword">const</span>;
<a name="l00398"></a>00398 
<a name="l00399"></a>00399     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classConstExpr.html#a749ca36fc17440ef545f1c3bf728b24a">TypeCheck</a>();
<a name="l00400"></a>00400     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classConstExpr.html#ac7c0dbc645dd375fe3a843e040201651">Optimize</a>();
<a name="l00401"></a>00401     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a10d09def76d6bf1b5f965c919c8c940c">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00402"></a>00402 <span class="comment"></span>
<a name="l00403"></a>00403 <span class="comment">    /** Return the ConstExpr&#39;s values as booleans, doing type conversion</span>
<a name="l00404"></a>00404 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00405"></a>00405 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00406"></a>00406 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00407"></a>00407     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a1a89d987d12562980dd207ab0b52582f">AsBool</a>(<span class="keywordtype">bool</span> *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00408"></a>00408 <span class="comment"></span>
<a name="l00409"></a>00409 <span class="comment">    /** Return the ConstExpr&#39;s values as int8s, doing type conversion</span>
<a name="l00410"></a>00410 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00411"></a>00411 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00412"></a>00412 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00413"></a>00413     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a4cf2748101cd8313f62dfbe573f28c82">AsInt8</a>(int8_t *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00414"></a>00414 <span class="comment"></span>
<a name="l00415"></a>00415 <span class="comment">    /** Return the ConstExpr&#39;s values as uint8s, doing type conversion</span>
<a name="l00416"></a>00416 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00417"></a>00417 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00418"></a>00418 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00419"></a>00419     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a1510ce733e605185601fea54d8d8982f">AsUInt8</a>(uint8_t *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00420"></a>00420 <span class="comment"></span>
<a name="l00421"></a>00421 <span class="comment">    /** Return the ConstExpr&#39;s values as int16s, doing type conversion</span>
<a name="l00422"></a>00422 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00423"></a>00423 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00424"></a>00424 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00425"></a>00425     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a74706244467bf3d462977b9588dcd860">AsInt16</a>(int16_t *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00426"></a>00426 <span class="comment"></span>
<a name="l00427"></a>00427 <span class="comment">    /** Return the ConstExpr&#39;s values as uint16s, doing type conversion</span>
<a name="l00428"></a>00428 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00429"></a>00429 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00430"></a>00430 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00431"></a>00431     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#ac6e88a2872be62f6597240063558e497">AsUInt16</a>(uint16_t *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00432"></a>00432 <span class="comment"></span>
<a name="l00433"></a>00433 <span class="comment">    /** Return the ConstExpr&#39;s values as int32s, doing type conversion</span>
<a name="l00434"></a>00434 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00435"></a>00435 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00436"></a>00436 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00437"></a>00437     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a020f60a6a49d042f4c5ff73f90e83c5d">AsInt32</a>(<a class="code" href="parse_8yy.html#a10e8b2d266b06d06f972396bf71af292">int32_t</a> *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00438"></a>00438 <span class="comment"></span>
<a name="l00439"></a>00439 <span class="comment">    /** Return the ConstExpr&#39;s values as uint32s, doing type conversion</span>
<a name="l00440"></a>00440 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00441"></a>00441 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00442"></a>00442 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00443"></a>00443     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#ad1410b0e96d29d7a9d2f1fb6f7a23f5f">AsUInt32</a>(uint32_t *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00444"></a>00444 <span class="comment"></span>
<a name="l00445"></a>00445 <span class="comment">    /** Return the ConstExpr&#39;s values as floats, doing type conversion</span>
<a name="l00446"></a>00446 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00447"></a>00447 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00448"></a>00448 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00449"></a>00449     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a24e75d1c1f6781c5a249bbb75237c7a1">AsFloat</a>(<span class="keywordtype">float</span> *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00450"></a>00450 <span class="comment"></span>
<a name="l00451"></a>00451 <span class="comment">    /** Return the ConstExpr&#39;s values as int64s, doing type conversion</span>
<a name="l00452"></a>00452 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00453"></a>00453 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00454"></a>00454 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00455"></a>00455     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a498cc9fc819dd91cc54442b1bafad436">AsInt64</a>(int64_t *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00456"></a>00456 <span class="comment"></span>
<a name="l00457"></a>00457 <span class="comment">    /** Return the ConstExpr&#39;s values as uint64s, doing type conversion</span>
<a name="l00458"></a>00458 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00459"></a>00459 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00460"></a>00460 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00461"></a>00461     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#aecdd71328cd80c3fad1daf81c15d7ac2">AsUInt64</a>(uint64_t *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00462"></a>00462 <span class="comment"></span>
<a name="l00463"></a>00463 <span class="comment">    /** Return the ConstExpr&#39;s values as doubles, doing type conversion</span>
<a name="l00464"></a>00464 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00465"></a>00465 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00466"></a>00466 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00467"></a>00467     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a1764cdbdcc71801cee81fb10171f5572">AsDouble</a>(<span class="keywordtype">double</span> *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00468"></a>00468 <span class="comment"></span>
<a name="l00469"></a>00469 <span class="comment">    /** Return the number of values in the ConstExpr; should be either 1,</span>
<a name="l00470"></a>00470 <span class="comment">        if it has uniform type, or the target&#39;s vector width if it&#39;s</span>
<a name="l00471"></a>00471 <span class="comment">        varying. */</span>
<a name="l00472"></a>00472     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#adc914222b8baf9433171903f30f12ef9">Count</a>() <span class="keyword">const</span>;
<a name="l00473"></a>00473 
<a name="l00474"></a>00474 <span class="keyword">private</span>:
<a name="l00475"></a>00475     <a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8">AtomicType::BasicType</a> <a class="code" href="classConstExpr.html#ae87ca34b80a9e57dab15515c7b29b576">getBasicType</a>() <span class="keyword">const</span>;
<a name="l00476"></a>00476 
<a name="l00477"></a><a class="code" href="classConstExpr.html#ad8eaecdf8a562262140ba193cb4d298d">00477</a>     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classConstExpr.html#ad8eaecdf8a562262140ba193cb4d298d">type</a>;
<a name="l00478"></a>00478     <span class="keyword">union </span>{
<a name="l00479"></a><a class="code" href="classConstExpr.html#a63bc6c5962b9396a31c1a0785a8945fe">00479</a>         int8_t <a class="code" href="classConstExpr.html#a63bc6c5962b9396a31c1a0785a8945fe">int8Val</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00480"></a><a class="code" href="classConstExpr.html#afd182b02090182319c6cdc176abe27d8">00480</a>         uint8_t <a class="code" href="classConstExpr.html#afd182b02090182319c6cdc176abe27d8">uint8Val</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00481"></a><a class="code" href="classConstExpr.html#aa3ac1cd1662287dbe8528bc660cbb964">00481</a>         int16_t <a class="code" href="classConstExpr.html#aa3ac1cd1662287dbe8528bc660cbb964">int16Val</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00482"></a><a class="code" href="classConstExpr.html#a08dcdead96d0505b00210c1305028dd2">00482</a>         uint16_t <a class="code" href="classConstExpr.html#a08dcdead96d0505b00210c1305028dd2">uint16Val</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00483"></a><a class="code" href="classConstExpr.html#a9ad92c517e871a5d07da585041de79ce">00483</a>         <a class="code" href="parse_8yy.html#a10e8b2d266b06d06f972396bf71af292">int32_t</a> <a class="code" href="classConstExpr.html#a9ad92c517e871a5d07da585041de79ce">int32Val</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00484"></a><a class="code" href="classConstExpr.html#a6e9d75ca5c8597bc252dd2e4bb723549">00484</a>         uint32_t <a class="code" href="classConstExpr.html#a6e9d75ca5c8597bc252dd2e4bb723549">uint32Val</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00485"></a><a class="code" href="classConstExpr.html#a2aae572bb8a1b0a9522677a1b9bf91c2">00485</a>         <span class="keywordtype">bool</span> <a class="code" href="classConstExpr.html#a2aae572bb8a1b0a9522677a1b9bf91c2">boolVal</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00486"></a><a class="code" href="classConstExpr.html#aa50de7f6ba4305e7c9a9ea1f8db269fb">00486</a>         <span class="keywordtype">float</span> <a class="code" href="classConstExpr.html#aa50de7f6ba4305e7c9a9ea1f8db269fb">floatVal</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00487"></a><a class="code" href="classConstExpr.html#a133bfdab1f884014cb45a4994abbb4dd">00487</a>         <span class="keywordtype">double</span> <a class="code" href="classConstExpr.html#a133bfdab1f884014cb45a4994abbb4dd">doubleVal</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00488"></a><a class="code" href="classConstExpr.html#a4befdefdad28725c11eb48983e1de031">00488</a>         int64_t <a class="code" href="classConstExpr.html#a4befdefdad28725c11eb48983e1de031">int64Val</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00489"></a><a class="code" href="classConstExpr.html#aedffbd22b4275640503e0f78eb8811ab">00489</a>         uint64_t <a class="code" href="classConstExpr.html#aedffbd22b4275640503e0f78eb8811ab">uint64Val</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00490"></a>00490     };
<a name="l00491"></a>00491 };
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 <span class="comment"></span>
<a name="l00494"></a>00494 <span class="comment">/** @brief Expression representing a type cast of the given expression to a</span>
<a name="l00495"></a>00495 <span class="comment">    probably-different type. */</span>
<a name="l00496"></a><a class="code" href="classTypeCastExpr.html">00496</a> <span class="keyword">class </span><a class="code" href="classTypeCastExpr.html" title="Expression representing a type cast of the given expression to a probably-different type...">TypeCastExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00497"></a>00497 <span class="keyword">public</span>:
<a name="l00498"></a>00498     <a class="code" href="classTypeCastExpr.html#ad558a1a03d31f482210e2fecb97b5783">TypeCastExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *e, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00499"></a>00499 
<a name="l00500"></a>00500     llvm::Value *<a class="code" href="classTypeCastExpr.html#a28389125c96a0c1afa25fd9ee2bb2c9a">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00501"></a>00501     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classTypeCastExpr.html#a885dff67661a38f4fa04a64df0afb1fd">GetType</a>() <span class="keyword">const</span>;
<a name="l00502"></a>00502     <span class="keywordtype">void</span> <a class="code" href="classTypeCastExpr.html#a1c8bd0f1258594150060f6af100c7c50">Print</a>() <span class="keyword">const</span>;
<a name="l00503"></a>00503     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classTypeCastExpr.html#a1ec58815a5e4bdb9be7eace2db9d8bf0">TypeCheck</a>();
<a name="l00504"></a>00504     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classTypeCastExpr.html#a8c1ffa77dffbfd6a039da548a65796ad">Optimize</a>();
<a name="l00505"></a>00505     <span class="keywordtype">int</span> <a class="code" href="classTypeCastExpr.html#a8b4f6a58d98ff96148a8d03fb2592081">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00506"></a>00506 
<a name="l00507"></a><a class="code" href="classTypeCastExpr.html#a032d0aaf472f8426186edeb52a220731">00507</a>     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classTypeCastExpr.html#a032d0aaf472f8426186edeb52a220731">type</a>;
<a name="l00508"></a><a class="code" href="classTypeCastExpr.html#a7793053dd14396260ecbcab9c87db852">00508</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classTypeCastExpr.html#a7793053dd14396260ecbcab9c87db852">expr</a>;
<a name="l00509"></a>00509 };
<a name="l00510"></a>00510 
<a name="l00511"></a>00511 <span class="comment"></span>
<a name="l00512"></a>00512 <span class="comment">/** @brief Expression that represents taking a reference of a (non-reference)</span>
<a name="l00513"></a>00513 <span class="comment">    variable. */</span>
<a name="l00514"></a><a class="code" href="classReferenceExpr.html">00514</a> <span class="keyword">class </span><a class="code" href="classReferenceExpr.html" title="Expression that represents taking a reference of a (non-reference) variable.">ReferenceExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00515"></a>00515 <span class="keyword">public</span>:
<a name="l00516"></a>00516     <a class="code" href="classReferenceExpr.html#ace703bb1e12fc25ebd68f079232617d1">ReferenceExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *e, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00517"></a>00517 
<a name="l00518"></a>00518     llvm::Value *<a class="code" href="classReferenceExpr.html#a7b4debe98b864dd82081f3a23cc51ae4">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00519"></a>00519     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classReferenceExpr.html#a99d3936283e0ad4b287bac93e8bbfbb5">GetType</a>() <span class="keyword">const</span>;
<a name="l00520"></a>00520     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classReferenceExpr.html#ab0d05136e78ae2d4da318eea506b1afb">GetBaseSymbol</a>() <span class="keyword">const</span>;
<a name="l00521"></a>00521     <span class="keywordtype">void</span> <a class="code" href="classReferenceExpr.html#af96aabe6be6cd40933e53ed7a52abf3b">Print</a>() <span class="keyword">const</span>;
<a name="l00522"></a>00522     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classReferenceExpr.html#ab636a6871c0269295e98d731337beeb7">TypeCheck</a>();
<a name="l00523"></a>00523     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classReferenceExpr.html#a373bb9e573b56125c1b441bcfdb7d07f">Optimize</a>();
<a name="l00524"></a>00524     <span class="keywordtype">int</span> <a class="code" href="classReferenceExpr.html#a83f588792255826de8cd963637871fe5">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00525"></a>00525 
<a name="l00526"></a><a class="code" href="classReferenceExpr.html#a3be4bd392d625b815cf70845e3562cc5">00526</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classReferenceExpr.html#a3be4bd392d625b815cf70845e3562cc5">expr</a>;
<a name="l00527"></a>00527 };
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 <span class="comment"></span>
<a name="l00530"></a>00530 <span class="comment">/** @brief Expression that represents dereferencing a reference to get its</span>
<a name="l00531"></a>00531 <span class="comment">    value. */</span>
<a name="l00532"></a><a class="code" href="classDereferenceExpr.html">00532</a> <span class="keyword">class </span><a class="code" href="classDereferenceExpr.html" title="Expression that represents dereferencing a reference to get its value.">DereferenceExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00533"></a>00533 <span class="keyword">public</span>:
<a name="l00534"></a>00534     <a class="code" href="classDereferenceExpr.html#a755a1377b8ec219fa04aac796676b5fa">DereferenceExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *e, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00535"></a>00535 
<a name="l00536"></a>00536     llvm::Value *<a class="code" href="classDereferenceExpr.html#a7393e69a7dc3dd34c682bad74dcd33bd">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00537"></a>00537     llvm::Value *<a class="code" href="classDereferenceExpr.html#a8f649c482f5ec690aaaefe435387c786">GetLValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00538"></a>00538     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classDereferenceExpr.html#ac34dd170f45f913c396dbca77f067804">GetType</a>() <span class="keyword">const</span>;
<a name="l00539"></a>00539     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classDereferenceExpr.html#aa9118499c8a10e27ec6ff1c821a7ee13">GetBaseSymbol</a>() <span class="keyword">const</span>;
<a name="l00540"></a>00540     <span class="keywordtype">void</span> <a class="code" href="classDereferenceExpr.html#ad58326a890f65136750afa7d59480daa">Print</a>() <span class="keyword">const</span>;
<a name="l00541"></a>00541     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classDereferenceExpr.html#ada95d76cb0f7e1092489e74f4a711d3d">TypeCheck</a>();
<a name="l00542"></a>00542     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classDereferenceExpr.html#a2e849db576e69418b2ce7558353862c8">Optimize</a>();
<a name="l00543"></a>00543     <span class="keywordtype">int</span> <a class="code" href="classDereferenceExpr.html#a5d46cd7f6b6dfa32d5022bf0286f76dc">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00544"></a>00544 
<a name="l00545"></a><a class="code" href="classDereferenceExpr.html#a599c7da86dc18370783574aa30f20a5b">00545</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classDereferenceExpr.html#a599c7da86dc18370783574aa30f20a5b">expr</a>;
<a name="l00546"></a>00546 };
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 <span class="comment"></span>
<a name="l00549"></a>00549 <span class="comment">/** @brief Expression representing a symbol reference in the program */</span>
<a name="l00550"></a><a class="code" href="classSymbolExpr.html">00550</a> <span class="keyword">class </span><a class="code" href="classSymbolExpr.html" title="Expression representing a symbol reference in the program.">SymbolExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00551"></a>00551 <span class="keyword">public</span>:
<a name="l00552"></a>00552     <a class="code" href="classSymbolExpr.html#a4a7262071b7df8d91821e67e6fcb75e0">SymbolExpr</a>(<a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="parse_8yy.html#a670da3e561356241efb8054bd91b88a8">s</a>, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00553"></a>00553 
<a name="l00554"></a>00554     llvm::Value *<a class="code" href="classSymbolExpr.html#ad87d063e378a3adce31dc9e5e185af0d">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00555"></a>00555     llvm::Value *<a class="code" href="classSymbolExpr.html#ad86cdf5dceb9bb6638f19cb4193fc844">GetLValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00556"></a>00556     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classSymbolExpr.html#a34c9bdebbcafcb318f40f4bf65f42426">GetType</a>() <span class="keyword">const</span>;
<a name="l00557"></a>00557     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classSymbolExpr.html#af1914db18366a395558b4f4e6b083929">GetBaseSymbol</a>() <span class="keyword">const</span>;
<a name="l00558"></a>00558     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSymbolExpr.html#ab8ba46274b1e56244baab9e3fd9d169f">TypeCheck</a>();
<a name="l00559"></a>00559     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSymbolExpr.html#a09610f84e65c3062016d30642b09cf20">Optimize</a>();
<a name="l00560"></a>00560     <span class="keywordtype">void</span> <a class="code" href="classSymbolExpr.html#a2dbebb90a83e96c0de88a264114a3099">Print</a>() <span class="keyword">const</span>;
<a name="l00561"></a>00561     <span class="keywordtype">int</span> <a class="code" href="classSymbolExpr.html#a846cb5a74470843194481112ee3b9fa7">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00562"></a>00562 
<a name="l00563"></a>00563 <span class="keyword">private</span>:
<a name="l00564"></a><a class="code" href="classSymbolExpr.html#a063f9e83d4d690fb8617a93f373fea63">00564</a>     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classSymbolExpr.html#a063f9e83d4d690fb8617a93f373fea63">symbol</a>;
<a name="l00565"></a>00565 };
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 <span class="comment"></span>
<a name="l00568"></a>00568 <span class="comment">/** @brief Expression representing a function symbol in the program (generally</span>
<a name="l00569"></a>00569 <span class="comment">    used for a function call).</span>
<a name="l00570"></a>00570 <span class="comment"> */</span>    
<a name="l00571"></a><a class="code" href="classFunctionSymbolExpr.html">00571</a> <span class="keyword">class </span><a class="code" href="classFunctionSymbolExpr.html" title="Expression representing a function symbol in the program (generally used for a function call)...">FunctionSymbolExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00572"></a>00572 <span class="keyword">public</span>:
<a name="l00573"></a>00573     <a class="code" href="classFunctionSymbolExpr.html#a51b2ebf373910216110fb19369b5a69c">FunctionSymbolExpr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classFunctionSymbolExpr.html#a23dc665e0c2734daea7439ba42c75f45">name</a>, std::vector&lt;Symbol *&gt; *<a class="code" href="classFunctionSymbolExpr.html#ac269411e5513c76bd6fc55eab4d86939">candidateFunctions</a>,
<a name="l00574"></a>00574                        <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> pos);
<a name="l00575"></a>00575 
<a name="l00576"></a>00576     llvm::Value *<a class="code" href="classFunctionSymbolExpr.html#a1eee5a80543e4a51b2ccb6c41396ccc5">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00577"></a>00577     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classFunctionSymbolExpr.html#a36c54fa6b3874295878880e92e90575b">GetType</a>() <span class="keyword">const</span>;
<a name="l00578"></a>00578     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classFunctionSymbolExpr.html#a7f6831ce09b79f8cdca14365d11a5bb1">GetBaseSymbol</a>() <span class="keyword">const</span>;
<a name="l00579"></a>00579     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classFunctionSymbolExpr.html#ad44e613dd2071288a93a8487aacbcdf8">TypeCheck</a>();
<a name="l00580"></a>00580     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classFunctionSymbolExpr.html#a16727f6e846c7a554f823c397a1a6149">Optimize</a>();
<a name="l00581"></a>00581     <span class="keywordtype">void</span> <a class="code" href="classFunctionSymbolExpr.html#a754a28381847e8d9eb7772cbc56c6774">Print</a>() <span class="keyword">const</span>;
<a name="l00582"></a>00582     <span class="keywordtype">int</span> <a class="code" href="classFunctionSymbolExpr.html#a7a69453705486679ffa3e991a748733b">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584 <span class="keyword">private</span>:
<a name="l00585"></a><a class="code" href="classFunctionSymbolExpr.html#a16c7a56b0784578eaa051b9f22bba303">00585</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classFunctionCallExpr.html" title="Expression representing a function call.">FunctionCallExpr</a>;
<a name="l00586"></a>00586 <span class="comment"></span>
<a name="l00587"></a>00587 <span class="comment">    /** Name of the function that is being called. */</span>
<a name="l00588"></a><a class="code" href="classFunctionSymbolExpr.html#a23dc665e0c2734daea7439ba42c75f45">00588</a>     std::string <a class="code" href="classFunctionSymbolExpr.html#a23dc665e0c2734daea7439ba42c75f45">name</a>;
<a name="l00589"></a>00589 <span class="comment"></span>
<a name="l00590"></a>00590 <span class="comment">    /** All of the functions with the name given in the function call;</span>
<a name="l00591"></a>00591 <span class="comment">        there may be more then one, in which case we need to resolve which</span>
<a name="l00592"></a>00592 <span class="comment">        overload is the best match. */</span>
<a name="l00593"></a><a class="code" href="classFunctionSymbolExpr.html#ac269411e5513c76bd6fc55eab4d86939">00593</a>     std::vector&lt;Symbol *&gt; *<a class="code" href="classFunctionSymbolExpr.html#ac269411e5513c76bd6fc55eab4d86939">candidateFunctions</a>;
<a name="l00594"></a>00594 <span class="comment"></span>
<a name="l00595"></a>00595 <span class="comment">    /** The actual matching function found after overload resolution; this</span>
<a name="l00596"></a>00596 <span class="comment">        value is set by FunctionCallExpr::resolveFunctionOverloads() */</span>
<a name="l00597"></a><a class="code" href="classFunctionSymbolExpr.html#ada53c1fccabda44ceb4a65faa9b8fc8a">00597</a>     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classFunctionSymbolExpr.html#ada53c1fccabda44ceb4a65faa9b8fc8a">matchingFunc</a>;
<a name="l00598"></a>00598 };
<a name="l00599"></a>00599 
<a name="l00600"></a>00600 <span class="comment"></span>
<a name="l00601"></a>00601 <span class="comment">/** @brief A sync statement in the program (waits for all launched tasks before</span>
<a name="l00602"></a>00602 <span class="comment">    proceeding). */</span>
<a name="l00603"></a><a class="code" href="classSyncExpr.html">00603</a> <span class="keyword">class </span><a class="code" href="classSyncExpr.html" title="A sync statement in the program (waits for all launched tasks before proceeding).">SyncExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00604"></a>00604 <span class="keyword">public</span>:
<a name="l00605"></a><a class="code" href="classSyncExpr.html#a61a97214bbee52ad2499fcadf892709e">00605</a>     <a class="code" href="classSyncExpr.html#a61a97214bbee52ad2499fcadf892709e">SyncExpr</a>(<a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p) : <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a>(p) { }
<a name="l00606"></a>00606 
<a name="l00607"></a>00607     llvm::Value *<a class="code" href="classSyncExpr.html#aa9a46eb62f7879b61fd56da3092b4ff5">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00608"></a>00608     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classSyncExpr.html#a9279f70fda2e643d34972bdff71b0a47">GetType</a>() <span class="keyword">const</span>;
<a name="l00609"></a>00609     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSyncExpr.html#af411fe3062afc649c104ed877bd5fd41">TypeCheck</a>();
<a name="l00610"></a>00610     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSyncExpr.html#a12b8c56aa2ae34936242b449932e467f">Optimize</a>();
<a name="l00611"></a>00611     <span class="keywordtype">void</span> <a class="code" href="classSyncExpr.html#ad3a4bff2fbe2b44429b3765dfdf3e1bb">Print</a>() <span class="keyword">const</span>;
<a name="l00612"></a>00612     <span class="keywordtype">int</span> <a class="code" href="classSyncExpr.html#a98c9e183d66f659cdfed37e332c0de44">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00613"></a>00613 };
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 <span class="preprocessor">#endif // ISPC_EXPR_H</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 6 2011 19:44:51 for Intel SPMD Program Compiler by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
