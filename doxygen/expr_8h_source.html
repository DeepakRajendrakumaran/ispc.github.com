<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Intel SPMD Program Compiler: expr.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Intel SPMD Program Compiler
   &#160;<span id="projectnumber">1.2.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">expr.h</div>  </div>
</div>
<div class="contents">
<a href="expr_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">  Copyright (c) 2010-2012, Intel Corporation</span>
<a name="l00003"></a>00003 <span class="comment">  All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">  Redistribution and use in source and binary forms, with or without</span>
<a name="l00006"></a>00006 <span class="comment">  modification, are permitted provided that the following conditions are</span>
<a name="l00007"></a>00007 <span class="comment">  met:</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">    * Redistributions of source code must retain the above copyright</span>
<a name="l00010"></a>00010 <span class="comment">      notice, this list of conditions and the following disclaimer.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">    * Redistributions in binary form must reproduce the above copyright</span>
<a name="l00013"></a>00013 <span class="comment">      notice, this list of conditions and the following disclaimer in the</span>
<a name="l00014"></a>00014 <span class="comment">      documentation and/or other materials provided with the distribution.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">    * Neither the name of Intel Corporation nor the names of its</span>
<a name="l00017"></a>00017 <span class="comment">      contributors may be used to endorse or promote products derived from</span>
<a name="l00018"></a>00018 <span class="comment">      this software without specific prior written permission.</span>
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment"></span>
<a name="l00021"></a>00021 <span class="comment">   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS</span>
<a name="l00022"></a>00022 <span class="comment">   IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED</span>
<a name="l00023"></a>00023 <span class="comment">   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A</span>
<a name="l00024"></a>00024 <span class="comment">   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER</span>
<a name="l00025"></a>00025 <span class="comment">   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
<a name="l00026"></a>00026 <span class="comment">   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</span>
<a name="l00027"></a>00027 <span class="comment">   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span>
<a name="l00028"></a>00028 <span class="comment">   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<a name="l00029"></a>00029 <span class="comment">   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<a name="l00030"></a>00030 <span class="comment">   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<a name="l00031"></a>00031 <span class="comment">   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  </span>
<a name="l00032"></a>00032 <span class="comment">*/</span>
<a name="l00033"></a>00033 <span class="comment"></span>
<a name="l00034"></a>00034 <span class="comment">/** @file expr.h</span>
<a name="l00035"></a>00035 <span class="comment">    @brief Expr abstract base class and expression implementations</span>
<a name="l00036"></a>00036 <span class="comment">*/</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="preprocessor">#ifndef ISPC_EXPR_H</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#define ISPC_EXPR_H 1</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="ispc_8h.html" title="Main ispc.header file.">ispc.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;ast.h&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;<a class="code" href="type_8h.html" title="File with declarations for classes related to type representation.">type.h</a>&quot;</span>
<a name="l00044"></a>00044 <span class="comment"></span>
<a name="l00045"></a>00045 <span class="comment">/** @brief Expr is the abstract base class that defines the interface that</span>
<a name="l00046"></a>00046 <span class="comment">    all expression types must implement.</span>
<a name="l00047"></a>00047 <span class="comment"> */</span>
<a name="l00048"></a><a class="code" href="classExpr.html">00048</a> <span class="keyword">class </span><a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> : <span class="keyword">public</span> <a class="code" href="classASTNode.html">ASTNode</a> {
<a name="l00049"></a>00049 <span class="keyword">public</span>:
<a name="l00050"></a><a class="code" href="classExpr.html#a2b863b1ee3b938b67f5b067142e94b96">00050</a>     <a class="code" href="classExpr.html#a2b863b1ee3b938b67f5b067142e94b96">Expr</a>(<a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p) : <a class="code" href="classASTNode.html">ASTNode</a>(p) { }
<a name="l00051"></a>00051 <span class="comment"></span>
<a name="l00052"></a>00052 <span class="comment">    /** This is the main method for Expr implementations to implement.  It</span>
<a name="l00053"></a>00053 <span class="comment">        should call methods in the FunctionEmitContext to emit LLVM IR</span>
<a name="l00054"></a>00054 <span class="comment">        instructions to the current basic block in order to generate an</span>
<a name="l00055"></a>00055 <span class="comment">        llvm::Value that represents the expression&#39;s value. */</span>
<a name="l00056"></a>00056     <span class="keyword">virtual</span> llvm::Value *<a class="code" href="classExpr.html#a2bc3d2bff41746985dd2b07d0637d7e8">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span> = 0;
<a name="l00057"></a>00057 <span class="comment"></span>
<a name="l00058"></a>00058 <span class="comment">    /** For expressions that can provide an lvalue (e.g. array indexing),</span>
<a name="l00059"></a>00059 <span class="comment">        this function should emit IR that computes the expression&#39;s lvalue</span>
<a name="l00060"></a>00060 <span class="comment">        and returns the corresponding llvm::Value.  Expressions that can&#39;t</span>
<a name="l00061"></a>00061 <span class="comment">        provide an lvalue should leave this unimplemented; the default</span>
<a name="l00062"></a>00062 <span class="comment">        implementation returns NULL.  */</span>
<a name="l00063"></a>00063     <span class="keyword">virtual</span> llvm::Value *<a class="code" href="classExpr.html#a9d3baf6e5f52fff8e916f3c0b5139c2e">GetLValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00064"></a>00064 <span class="comment"></span>
<a name="l00065"></a>00065 <span class="comment">    /** Returns the Type of the expression. */</span>
<a name="l00066"></a>00066     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classExpr.html#a8451d4988f430bea94e354dc44e6b094">GetType</a>() <span class="keyword">const</span> = 0;
<a name="l00067"></a>00067 <span class="comment"></span>
<a name="l00068"></a>00068 <span class="comment">    /** Returns the type of the value returned by GetLValueType(); this</span>
<a name="l00069"></a>00069 <span class="comment">        should be a pointer type of some sort (uniform or varying). */</span>
<a name="l00070"></a>00070     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classExpr.html#a9893c01e9872f3f07c43f0f67abecad2">GetLValueType</a>() <span class="keyword">const</span>;
<a name="l00071"></a>00071 <span class="comment"></span>
<a name="l00072"></a>00072 <span class="comment">    /** For expressions that have values based on a symbol (e.g. regular</span>
<a name="l00073"></a>00073 <span class="comment">        symbol references, array indexing, etc.), this returns a pointer to</span>
<a name="l00074"></a>00074 <span class="comment">        that symbol. */</span>
<a name="l00075"></a>00075     <span class="keyword">virtual</span> <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classExpr.html#a4219def5afcedd6551acf0954d2fa2de">GetBaseSymbol</a>() <span class="keyword">const</span>;
<a name="l00076"></a>00076 <span class="comment"></span>
<a name="l00077"></a>00077 <span class="comment">    /** If this is a constant expression that can be converted to a</span>
<a name="l00078"></a>00078 <span class="comment">        constant of the given type, this method should return the</span>
<a name="l00079"></a>00079 <span class="comment">        corresponding llvm::Constant value.  Otherwise it should return</span>
<a name="l00080"></a>00080 <span class="comment">        NULL. */</span>
<a name="l00081"></a>00081     <span class="keyword">virtual</span> llvm::Constant *<a class="code" href="classExpr.html#a0409d1bd3dae14b118bea8b8c28321db">GetConstant</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *type) <span class="keyword">const</span>;
<a name="l00082"></a>00082 <span class="comment"></span>
<a name="l00083"></a>00083 <span class="comment">    /** This method should perform early optimizations of the expression</span>
<a name="l00084"></a>00084 <span class="comment">        (constant folding, etc.) and return a pointer to the resulting</span>
<a name="l00085"></a>00085 <span class="comment">        expression.  If an error is encountered during optimization, NULL</span>
<a name="l00086"></a>00086 <span class="comment">        should be returned. */</span>
<a name="l00087"></a>00087     <span class="keyword">virtual</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classExpr.html#aeffa58fc4e9b2b058c1d3931caed2ae4">Optimize</a>() = 0;
<a name="l00088"></a>00088 <span class="comment"></span>
<a name="l00089"></a>00089 <span class="comment">    /** This method should perform type checking of the expression and</span>
<a name="l00090"></a>00090 <span class="comment">        return a pointer to the resulting expression.  If an error is</span>
<a name="l00091"></a>00091 <span class="comment">        encountered, NULL should be returned. */</span>
<a name="l00092"></a>00092     <span class="keyword">virtual</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classExpr.html#acf568bb978a23556c8e40f2662715190">TypeCheck</a>() = 0;
<a name="l00093"></a>00093 <span class="comment"></span>
<a name="l00094"></a>00094 <span class="comment">    /** Prints the expression to standard output (used for debugging). */</span>
<a name="l00095"></a>00095     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classExpr.html#ac8d62a881604e554c36ec30738163423">Print</a>() <span class="keyword">const</span> = 0;
<a name="l00096"></a>00096 };
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="comment"></span>
<a name="l00099"></a>00099 <span class="comment">/** @brief Unary expression */</span>
<a name="l00100"></a><a class="code" href="classUnaryExpr.html">00100</a> <span class="keyword">class </span><a class="code" href="classUnaryExpr.html" title="Unary expression.">UnaryExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00101"></a>00101 <span class="keyword">public</span>:
<a name="l00102"></a><a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0a">00102</a>     <span class="keyword">enum</span> <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0a">Op</a> {
<a name="l00103"></a><a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aadbe199ac60697c535f0d43d0dba1551e">00103</a>         <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aadbe199ac60697c535f0d43d0dba1551e" title="Pre-increment.">PreInc</a>,      <span class="comment">///&lt; Pre-increment</span>
<a name="l00104"></a><a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aa8371682ef0e8c8db3e0b326eebd7fcf1">00104</a> <span class="comment"></span>        <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aa8371682ef0e8c8db3e0b326eebd7fcf1" title="Pre-decrement.">PreDec</a>,      <span class="comment">///&lt; Pre-decrement </span>
<a name="l00105"></a><a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aa60eca9776c0bbcf670ac1fe50c19b85e">00105</a> <span class="comment"></span>        <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aa60eca9776c0bbcf670ac1fe50c19b85e" title="Post-increment.">PostInc</a>,     <span class="comment">///&lt; Post-increment</span>
<a name="l00106"></a><a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aaccb7c3257ef012bb05bdae852e8687a1">00106</a> <span class="comment"></span>        <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aaccb7c3257ef012bb05bdae852e8687a1" title="Post-decrement.">PostDec</a>,     <span class="comment">///&lt; Post-decrement</span>
<a name="l00107"></a><a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aa5caf3ba4519a6caa706a217baf7b2fb6">00107</a> <span class="comment"></span>        <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aa5caf3ba4519a6caa706a217baf7b2fb6" title="Negation.">Negate</a>,      <span class="comment">///&lt; Negation</span>
<a name="l00108"></a><a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aae7624b1b76dfe31bfe2fb8a7bc42880c">00108</a> <span class="comment"></span>        <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aae7624b1b76dfe31bfe2fb8a7bc42880c" title="Logical not.">LogicalNot</a>,  <span class="comment">///&lt; Logical not</span>
<a name="l00109"></a><a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aae2154322c4d3e3dba3d8b3db175d14dd">00109</a> <span class="comment"></span>        <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0aae2154322c4d3e3dba3d8b3db175d14dd" title="Bit not.">BitNot</a>,      <span class="comment">///&lt; Bit not</span>
<a name="l00110"></a>00110 <span class="comment"></span>    };
<a name="l00111"></a>00111 
<a name="l00112"></a>00112     <a class="code" href="classUnaryExpr.html#a0e246b4d1cd1c69a65ee17c22a9f750b">UnaryExpr</a>(<a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0a">Op</a> <a class="code" href="classUnaryExpr.html#a8e84e48189c8947262677076e591671a">op</a>, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classUnaryExpr.html#a7a56bea77b7439efa5d8ebd89d22ea93">expr</a>, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> pos);
<a name="l00113"></a>00113 
<a name="l00114"></a>00114     llvm::Value *<a class="code" href="classUnaryExpr.html#a491f1175afacdde2954235b8f6a28422">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00115"></a>00115     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classUnaryExpr.html#a147e436a4b1e55c93a8cf248fe326b14">GetType</a>() <span class="keyword">const</span>;
<a name="l00116"></a>00116     <span class="keywordtype">void</span> <a class="code" href="classUnaryExpr.html#aac9ba92c4f80a3afd341c44f85b656b2">Print</a>() <span class="keyword">const</span>;
<a name="l00117"></a>00117     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classUnaryExpr.html#aa4b660df9ce888e9cdbb675dbd44b300">Optimize</a>();
<a name="l00118"></a>00118     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classUnaryExpr.html#a4115b641cf51f20e4d0ae221c107ac88">TypeCheck</a>();
<a name="l00119"></a>00119     <span class="keywordtype">int</span> <a class="code" href="classUnaryExpr.html#a09ffadd5ecca89f8579932c3a949db38">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00120"></a>00120 
<a name="l00121"></a><a class="code" href="classUnaryExpr.html#a8e84e48189c8947262677076e591671a">00121</a>     <span class="keyword">const</span> <a class="code" href="classUnaryExpr.html#afa4b68c59f40c7c964dffd2333f07f0a">Op</a> <a class="code" href="classUnaryExpr.html#a8e84e48189c8947262677076e591671a">op</a>;
<a name="l00122"></a><a class="code" href="classUnaryExpr.html#a7a56bea77b7439efa5d8ebd89d22ea93">00122</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classUnaryExpr.html#a7a56bea77b7439efa5d8ebd89d22ea93">expr</a>;
<a name="l00123"></a>00123 };
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="comment"></span>
<a name="l00126"></a>00126 <span class="comment">/** @brief Binary expression */</span>
<a name="l00127"></a><a class="code" href="classBinaryExpr.html">00127</a> <span class="keyword">class </span><a class="code" href="classBinaryExpr.html" title="Binary expression.">BinaryExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00128"></a>00128 <span class="keyword">public</span>:
<a name="l00129"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7">00129</a>     <span class="keyword">enum</span> <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7">Op</a> {
<a name="l00130"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a4d239613f5b623d61ca5aafc19a9579b">00130</a>         <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a4d239613f5b623d61ca5aafc19a9579b" title="Addition.">Add</a>,           <span class="comment">///&lt; Addition</span>
<a name="l00131"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a94d438e3ae5c0d14e5dd2319e08bde70">00131</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a94d438e3ae5c0d14e5dd2319e08bde70" title="Subtraction.">Sub</a>,           <span class="comment">///&lt; Subtraction</span>
<a name="l00132"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a3d30be2a9c2b0ae23c3695b5b7c9157d">00132</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a3d30be2a9c2b0ae23c3695b5b7c9157d" title="Multiplication.">Mul</a>,           <span class="comment">///&lt; Multiplication</span>
<a name="l00133"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7aa082d01fa67760930edacb6e37123bf8">00133</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7aa082d01fa67760930edacb6e37123bf8" title="Division.">Div</a>,           <span class="comment">///&lt; Division</span>
<a name="l00134"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a2a253f235bd8731d71d986b690716684">00134</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a2a253f235bd8731d71d986b690716684" title="Modulus.">Mod</a>,           <span class="comment">///&lt; Modulus</span>
<a name="l00135"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ade0d8e8500caa6aa17e2e681ed181be5">00135</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ade0d8e8500caa6aa17e2e681ed181be5" title="Shift left.">Shl</a>,           <span class="comment">///&lt; Shift left</span>
<a name="l00136"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7afd39b7f6dac4983939e1c35fc0a347c0">00136</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7afd39b7f6dac4983939e1c35fc0a347c0" title="Shift right.">Shr</a>,           <span class="comment">///&lt; Shift right</span>
<a name="l00137"></a>00137 <span class="comment"></span>
<a name="l00138"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ae595fac49e25e1126a433042fedac896">00138</a>         <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ae595fac49e25e1126a433042fedac896" title="Less than.">Lt</a>,            <span class="comment">///&lt; Less than</span>
<a name="l00139"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a21c13d9affbb96afa4265d94b7143098">00139</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a21c13d9affbb96afa4265d94b7143098" title="Greater than.">Gt</a>,            <span class="comment">///&lt; Greater than</span>
<a name="l00140"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7afb132b34f0c41ae0920a40550a56a49f">00140</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7afb132b34f0c41ae0920a40550a56a49f" title="Less than or equal.">Le</a>,            <span class="comment">///&lt; Less than or equal</span>
<a name="l00141"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a71c2ab0a95fa191b1a3e7d8771838320">00141</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a71c2ab0a95fa191b1a3e7d8771838320" title="Greater than or equal.">Ge</a>,            <span class="comment">///&lt; Greater than or equal</span>
<a name="l00142"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ac63a25f6515cee23796c2a2aa2f39e57">00142</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ac63a25f6515cee23796c2a2aa2f39e57" title="Equal.">Equal</a>,         <span class="comment">///&lt; Equal</span>
<a name="l00143"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7aceb1c48a518a810d6c8c944b59c77ce3">00143</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7aceb1c48a518a810d6c8c944b59c77ce3" title="Not equal.">NotEqual</a>,      <span class="comment">///&lt; Not equal</span>
<a name="l00144"></a>00144 <span class="comment"></span>
<a name="l00145"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a8db0f4e01c01f1b975acefcd3ea203db">00145</a>         <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a8db0f4e01c01f1b975acefcd3ea203db" title="Bitwise AND.">BitAnd</a>,        <span class="comment">///&lt; Bitwise AND</span>
<a name="l00146"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7aac6763d96b8609f6530940952364d2f0">00146</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7aac6763d96b8609f6530940952364d2f0" title="Bitwise XOR.">BitXor</a>,        <span class="comment">///&lt; Bitwise XOR</span>
<a name="l00147"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ad4bf08b0ad65c931d59d45aa33c5e8e1">00147</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ad4bf08b0ad65c931d59d45aa33c5e8e1" title="Bitwise OR.">BitOr</a>,         <span class="comment">///&lt; Bitwise OR</span>
<a name="l00148"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a14bc6963fa4e11c06ada97069350de13">00148</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7a14bc6963fa4e11c06ada97069350de13" title="Logical AND.">LogicalAnd</a>,    <span class="comment">///&lt; Logical AND</span>
<a name="l00149"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7af5c69ba861c4ebefe7ee64f90d416b96">00149</a> <span class="comment"></span>        <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7af5c69ba861c4ebefe7ee64f90d416b96" title="Logical OR.">LogicalOr</a>,     <span class="comment">///&lt; Logical OR</span>
<a name="l00150"></a>00150 <span class="comment"></span>
<a name="l00151"></a><a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ab20da151044a48f0047fa472bfaab97a">00151</a>         <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7ab20da151044a48f0047fa472bfaab97a" title="Comma operator.">Comma</a>,         <span class="comment">///&lt; Comma operator</span>
<a name="l00152"></a>00152 <span class="comment"></span>    };
<a name="l00153"></a>00153 
<a name="l00154"></a>00154     <a class="code" href="classBinaryExpr.html#ab6205e08dbd56c3296b7eba91b065804">BinaryExpr</a>(<a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7">Op</a> o, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *a, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *b, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00155"></a>00155 
<a name="l00156"></a>00156     llvm::Value *<a class="code" href="classBinaryExpr.html#ac206ff9a04679c064cdb3d8daf1eb75d">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00157"></a>00157     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classBinaryExpr.html#ab809b2190a5d9b87436cbfd0fd537299">GetType</a>() <span class="keyword">const</span>;
<a name="l00158"></a>00158     <span class="keywordtype">void</span> <a class="code" href="classBinaryExpr.html#a53f62e7751853080719f415346fc770d">Print</a>() <span class="keyword">const</span>;
<a name="l00159"></a>00159 
<a name="l00160"></a>00160     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classBinaryExpr.html#afa938a1d4e8651bdd5eb833971258549">Optimize</a>();
<a name="l00161"></a>00161     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classBinaryExpr.html#a7dd0352a3b80f1fd4d50475b1722dffb">TypeCheck</a>();
<a name="l00162"></a>00162     <span class="keywordtype">int</span> <a class="code" href="classBinaryExpr.html#a5b6541c2d840ca2c741ade6cfb948642">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00163"></a>00163 
<a name="l00164"></a><a class="code" href="classBinaryExpr.html#a24c2764ba06e0d2e6c5f032833ae15c7">00164</a>     <span class="keyword">const</span> <a class="code" href="classBinaryExpr.html#a968e4b26ba6673e3422708e341f1aed7">Op</a> <a class="code" href="classBinaryExpr.html#a24c2764ba06e0d2e6c5f032833ae15c7">op</a>;
<a name="l00165"></a><a class="code" href="classBinaryExpr.html#a40c0076587fdb4909f804a24ec7d826c">00165</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classBinaryExpr.html#a53fab112d99338b92775b99b9a1fe54c">arg0</a>, *<a class="code" href="classBinaryExpr.html#a40c0076587fdb4909f804a24ec7d826c">arg1</a>;
<a name="l00166"></a>00166 };
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 <span class="comment"></span>
<a name="l00169"></a>00169 <span class="comment">/** @brief Assignment expression */</span>
<a name="l00170"></a><a class="code" href="classAssignExpr.html">00170</a> <span class="keyword">class </span><a class="code" href="classAssignExpr.html" title="Assignment expression.">AssignExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00171"></a>00171 <span class="keyword">public</span>:
<a name="l00172"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7">00172</a>     <span class="keyword">enum</span> <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7">Op</a> {
<a name="l00173"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7ad90801d98b08e2c00dd356dc0bc0db09">00173</a>         <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7ad90801d98b08e2c00dd356dc0bc0db09" title="Regular assignment.">Assign</a>,     <span class="comment">///&lt; Regular assignment</span>
<a name="l00174"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a91cd72fee59a49ed86ebefabe1b06364">00174</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a91cd72fee59a49ed86ebefabe1b06364" title="*= assignment">MulAssign</a>,  <span class="comment">///&lt; *= assignment</span>
<a name="l00175"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7ab888b5b6e6e40d35de2c668094470b1d">00175</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7ab888b5b6e6e40d35de2c668094470b1d" title="/= assignment">DivAssign</a>,  <span class="comment">///&lt; /= assignment</span>
<a name="l00176"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7af3710fce9debc5c64349ab31b4d511f8">00176</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7af3710fce9debc5c64349ab31b4d511f8" title="%= assignment">ModAssign</a>,  <span class="comment">///&lt; %= assignment</span>
<a name="l00177"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a7f7e3daf7a8703a56562c5728ba1ad43">00177</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a7f7e3daf7a8703a56562c5728ba1ad43" title="+= assignment">AddAssign</a>,  <span class="comment">///&lt; += assignment</span>
<a name="l00178"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a5f7ed24dfe200a7928097cfe60923788">00178</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a5f7ed24dfe200a7928097cfe60923788">SubAssign</a>,  <span class="comment">///&lt; -= assignment</span>
<a name="l00179"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7aa562230af04e0411aec26a87164ebd4d">00179</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7aa562230af04e0411aec26a87164ebd4d" title="&lt;&lt;= assignment">ShlAssign</a>,  <span class="comment">///&lt; &lt;&lt;= assignment</span>
<a name="l00180"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a75107016d9d4ccf939e19537f7dd489c">00180</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a75107016d9d4ccf939e19537f7dd489c" title="&gt;&gt;= assignment">ShrAssign</a>,  <span class="comment">///&lt; &gt;&gt;= assignment</span>
<a name="l00181"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a9328aafd76c18d673d373fac04e48632">00181</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a9328aafd76c18d673d373fac04e48632" title="&amp;= assignment">AndAssign</a>,  <span class="comment">///&lt; &amp;= assignment</span>
<a name="l00182"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a72f2976ebc5d2bcd13f4ec58ab387c22">00182</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a72f2976ebc5d2bcd13f4ec58ab387c22" title="^= assignment">XorAssign</a>,  <span class="comment">///&lt; ^= assignment</span>
<a name="l00183"></a><a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a17c0a5f02f9f497b23944fde67faf2b9">00183</a> <span class="comment"></span>        <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7a17c0a5f02f9f497b23944fde67faf2b9" title="|= assignment">OrAssign</a>,   <span class="comment">///&lt; |= assignment</span>
<a name="l00184"></a>00184 <span class="comment"></span>    };
<a name="l00185"></a>00185 
<a name="l00186"></a>00186     <a class="code" href="classAssignExpr.html#a481beb8bc02efab8a5a4622f8c598e4e">AssignExpr</a>(<a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7">Op</a> o, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *a, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *b, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00187"></a>00187 
<a name="l00188"></a>00188     llvm::Value *<a class="code" href="classAssignExpr.html#a527fd9d588f58374323cdde588446d58">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00189"></a>00189     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classAssignExpr.html#a4914217b2b4fb6daff53db2e37d5d86d">GetType</a>() <span class="keyword">const</span>;
<a name="l00190"></a>00190     <span class="keywordtype">void</span> <a class="code" href="classAssignExpr.html#acb10431425b736c805e690873853fe20">Print</a>() <span class="keyword">const</span>;
<a name="l00191"></a>00191 
<a name="l00192"></a>00192     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classAssignExpr.html#a95ce9f096271957877412af17694a8ab">Optimize</a>();
<a name="l00193"></a>00193     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classAssignExpr.html#a7e964f6043f50c1d9c52a1a1f7fd2189">TypeCheck</a>();
<a name="l00194"></a>00194     <span class="keywordtype">int</span> <a class="code" href="classAssignExpr.html#af1cecb2f836fd9c607b51e18af214b5d">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00195"></a>00195 
<a name="l00196"></a><a class="code" href="classAssignExpr.html#a8ff67a87545cdf43cefd0481d0a6745a">00196</a>     <span class="keyword">const</span> <a class="code" href="classAssignExpr.html#a623bb1c9b6e8175365e7451eedcb51a7">Op</a> <a class="code" href="classAssignExpr.html#a8ff67a87545cdf43cefd0481d0a6745a">op</a>;
<a name="l00197"></a><a class="code" href="classAssignExpr.html#aecf688d3498a87e53d60925d072a1c2f">00197</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classAssignExpr.html#aa6ef7de40103442b6094b990ce883264">lvalue</a>, *<a class="code" href="classAssignExpr.html#aecf688d3498a87e53d60925d072a1c2f">rvalue</a>;
<a name="l00198"></a>00198 };
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 <span class="comment"></span>
<a name="l00201"></a>00201 <span class="comment">/** @brief Selection expression, corresponding to &quot;test ? a : b&quot;.  </span>
<a name="l00202"></a>00202 <span class="comment"></span>
<a name="l00203"></a>00203 <span class="comment">    Returns the value of &quot;a&quot; or &quot;b&quot;, depending on the value of &quot;test&quot;.</span>
<a name="l00204"></a>00204 <span class="comment">*/</span>
<a name="l00205"></a><a class="code" href="classSelectExpr.html">00205</a> <span class="keyword">class </span><a class="code" href="classSelectExpr.html" title="Selection expression, corresponding to &quot;test ? a : b&quot;.">SelectExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00206"></a>00206 <span class="keyword">public</span>:
<a name="l00207"></a>00207     <a class="code" href="classSelectExpr.html#abbf3ced36cd78acc07b566890e677661">SelectExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSelectExpr.html#aad8d842fd03005cec3407ee6205d43e5">test</a>, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *a, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *b, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00208"></a>00208 
<a name="l00209"></a>00209     llvm::Value *<a class="code" href="classSelectExpr.html#ae1e4d610d23390bbb7c8083c141d3995">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00210"></a>00210     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classSelectExpr.html#af36485eda148b293bfda30058aa04bf8">GetType</a>() <span class="keyword">const</span>;
<a name="l00211"></a>00211     <span class="keywordtype">void</span> <a class="code" href="classSelectExpr.html#aecfb71a8752639e6eab5b5be7e41c287">Print</a>() <span class="keyword">const</span>;
<a name="l00212"></a>00212 
<a name="l00213"></a>00213     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSelectExpr.html#a29a19cbf6bff81b79c90fe8c5fc5c2f2">Optimize</a>();
<a name="l00214"></a>00214     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSelectExpr.html#a64f9e0c37a4d553908fa0564aeaafd51">TypeCheck</a>();
<a name="l00215"></a>00215     <span class="keywordtype">int</span> <a class="code" href="classSelectExpr.html#add075184fbef1f53da066c2bc08dd4cb">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00216"></a>00216 
<a name="l00217"></a><a class="code" href="classSelectExpr.html#aad8d842fd03005cec3407ee6205d43e5">00217</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSelectExpr.html#aad8d842fd03005cec3407ee6205d43e5">test</a>, *<a class="code" href="classSelectExpr.html#aec302429bf4a9ede1e2cf83171acd25c">expr1</a>, *<a class="code" href="classSelectExpr.html#aaf702b20175ad070b01f1cb56456c31b">expr2</a>;
<a name="l00218"></a>00218 };
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 <span class="comment"></span>
<a name="l00221"></a>00221 <span class="comment">/** @brief A list of expressions.</span>
<a name="l00222"></a>00222 <span class="comment"></span>
<a name="l00223"></a>00223 <span class="comment">    These are mostly used for representing curly-brace delimited</span>
<a name="l00224"></a>00224 <span class="comment">    initializers for initializers for complex types and for representing</span>
<a name="l00225"></a>00225 <span class="comment">    the arguments passed to a function call.</span>
<a name="l00226"></a>00226 <span class="comment"> */</span>
<a name="l00227"></a><a class="code" href="classExprList.html">00227</a> <span class="keyword">class </span><a class="code" href="classExprList.html" title="A list of expressions.">ExprList</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00228"></a>00228 <span class="keyword">public</span>:
<a name="l00229"></a><a class="code" href="classExprList.html#a1175ee87aef8ed69163eed7cca496d7a">00229</a>     <a class="code" href="classExprList.html#a1175ee87aef8ed69163eed7cca496d7a">ExprList</a>(<a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p) : <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a>(p) { }
<a name="l00230"></a><a class="code" href="classExprList.html#a6bc3e30fcacbb152e820ccfb525a4410">00230</a>     <a class="code" href="classExprList.html#a6bc3e30fcacbb152e820ccfb525a4410">ExprList</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *e, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p) : <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a>(p) { <a class="code" href="classExprList.html#a701a2dc534fd40e2255bdb1b397daa5e">exprs</a>.push_back(e); }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232     llvm::Value *<a class="code" href="classExprList.html#abef2a40a1830dfa69de153d832de2f82">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00233"></a>00233     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classExprList.html#a249e57b34809b0cac782400c9cfb64ab">GetType</a>() <span class="keyword">const</span>;
<a name="l00234"></a>00234     <span class="keywordtype">void</span> <a class="code" href="classExprList.html#aabfced5c0665aafcb4e0930b3ace96bc">Print</a>() <span class="keyword">const</span>;
<a name="l00235"></a>00235     llvm::Constant *<a class="code" href="classExprList.html#aca19946ae96cc4343cc5300a11005abd">GetConstant</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *type) <span class="keyword">const</span>;
<a name="l00236"></a>00236     <a class="code" href="classExprList.html" title="A list of expressions.">ExprList</a> *<a class="code" href="classExprList.html#a6b2b90afd6a278bdf8e1b865fb7354bc">Optimize</a>();
<a name="l00237"></a>00237     <a class="code" href="classExprList.html" title="A list of expressions.">ExprList</a> *<a class="code" href="classExprList.html#a46530e3ccea4a4b3f742cd892795adc1">TypeCheck</a>();
<a name="l00238"></a>00238     <span class="keywordtype">int</span> <a class="code" href="classExprList.html#acb97b512c61c17fa3413378f4cd30ef9">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00239"></a>00239 
<a name="l00240"></a><a class="code" href="classExprList.html#a701a2dc534fd40e2255bdb1b397daa5e">00240</a>     std::vector&lt;Expr *&gt; <a class="code" href="classExprList.html#a701a2dc534fd40e2255bdb1b397daa5e">exprs</a>;
<a name="l00241"></a>00241 };
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="comment"></span>
<a name="l00244"></a>00244 <span class="comment">/** @brief Expression representing a function call.</span>
<a name="l00245"></a>00245 <span class="comment"> */</span>
<a name="l00246"></a><a class="code" href="classFunctionCallExpr.html">00246</a> <span class="keyword">class </span><a class="code" href="classFunctionCallExpr.html" title="Expression representing a function call.">FunctionCallExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00247"></a>00247 <span class="keyword">public</span>:
<a name="l00248"></a>00248     <a class="code" href="classFunctionCallExpr.html#ac0ffc59913a8d284d198fb3418ddb344">FunctionCallExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classFunctionCallExpr.html#a96c712c3358aa3cc6241de1b31d94c33">func</a>, <a class="code" href="classExprList.html" title="A list of expressions.">ExprList</a> *<a class="code" href="classFunctionCallExpr.html#a6efde7be3cd2d9d00dc56e77f82b0ed2">args</a>, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p, 
<a name="l00249"></a>00249                      <span class="keywordtype">bool</span> <a class="code" href="classFunctionCallExpr.html#a65977190d50b009c400133cae808ff73">isLaunch</a> = <span class="keyword">false</span>, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classFunctionCallExpr.html#a06c8f7d411ed1fe49d5fd3a136e40755">launchCountExpr</a> = <a class="code" href="parse_8yy.html">NULL</a>);
<a name="l00250"></a>00250 
<a name="l00251"></a>00251     llvm::Value *<a class="code" href="classFunctionCallExpr.html#afa94cbe916b34082c3f2416bdbfd4d09">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00252"></a>00252     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classFunctionCallExpr.html#a895bf78acf9ace26dfadc3d3a5f0b72f">GetType</a>() <span class="keyword">const</span>;
<a name="l00253"></a>00253     <span class="keywordtype">void</span> <a class="code" href="classFunctionCallExpr.html#a0cae5ed0975f86d698e63dd164940961">Print</a>() <span class="keyword">const</span>;
<a name="l00254"></a>00254 
<a name="l00255"></a>00255     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classFunctionCallExpr.html#a0daf3c50beaf41b0e00ba6bbd9e40290">Optimize</a>();
<a name="l00256"></a>00256     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classFunctionCallExpr.html#a64b54547c7a84c245197fd6c94bccbef">TypeCheck</a>();
<a name="l00257"></a>00257     <span class="keywordtype">int</span> <a class="code" href="classFunctionCallExpr.html#a8dc8285ec7b28ed1b0770dde0da5965c">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00258"></a>00258 
<a name="l00259"></a><a class="code" href="classFunctionCallExpr.html#a96c712c3358aa3cc6241de1b31d94c33">00259</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classFunctionCallExpr.html#a96c712c3358aa3cc6241de1b31d94c33">func</a>;
<a name="l00260"></a><a class="code" href="classFunctionCallExpr.html#a6efde7be3cd2d9d00dc56e77f82b0ed2">00260</a>     <a class="code" href="classExprList.html" title="A list of expressions.">ExprList</a> *<a class="code" href="classFunctionCallExpr.html#a6efde7be3cd2d9d00dc56e77f82b0ed2">args</a>;
<a name="l00261"></a><a class="code" href="classFunctionCallExpr.html#a65977190d50b009c400133cae808ff73">00261</a>     <span class="keywordtype">bool</span> <a class="code" href="classFunctionCallExpr.html#a65977190d50b009c400133cae808ff73">isLaunch</a>;
<a name="l00262"></a><a class="code" href="classFunctionCallExpr.html#a06c8f7d411ed1fe49d5fd3a136e40755">00262</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classFunctionCallExpr.html#a06c8f7d411ed1fe49d5fd3a136e40755">launchCountExpr</a>;
<a name="l00263"></a>00263 };
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 <span class="comment"></span>
<a name="l00266"></a>00266 <span class="comment">/** @brief Expression representing indexing into something with an integer</span>
<a name="l00267"></a>00267 <span class="comment">    offset.</span>
<a name="l00268"></a>00268 <span class="comment"></span>
<a name="l00269"></a>00269 <span class="comment">    This is used for both array indexing and indexing into VectorTypes. </span>
<a name="l00270"></a>00270 <span class="comment">*/</span>
<a name="l00271"></a><a class="code" href="classIndexExpr.html">00271</a> <span class="keyword">class </span><a class="code" href="classIndexExpr.html" title="Expression representing indexing into something with an integer offset.">IndexExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00272"></a>00272 <span class="keyword">public</span>:
<a name="l00273"></a>00273     <a class="code" href="classIndexExpr.html#ab5ca24889fbcbd445641d56588fe555e">IndexExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classIndexExpr.html#a9ebd1d2a157d9958cb91d82608cd18d6">baseExpr</a>, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classIndexExpr.html#a5e06e65bf953e30ec2c518f528a439aa">index</a>, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00274"></a>00274 
<a name="l00275"></a>00275     llvm::Value *<a class="code" href="classIndexExpr.html#a3519954d20ca149e07881ce9e42ce684">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00276"></a>00276     llvm::Value *<a class="code" href="classIndexExpr.html#add9accb4f2423d5a3a8d7f9daa26ca1b">GetLValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00277"></a>00277     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classIndexExpr.html#a9f8efbad35c616ce4ef2368e20d087de">GetType</a>() <span class="keyword">const</span>;
<a name="l00278"></a>00278     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classIndexExpr.html#a0a04d231385f366122992c6a44edc3be">GetLValueType</a>() <span class="keyword">const</span>;
<a name="l00279"></a>00279     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classIndexExpr.html#a39433a242e1bf61b3e361b350370d3d5">GetBaseSymbol</a>() <span class="keyword">const</span>;
<a name="l00280"></a>00280     <span class="keywordtype">void</span> <a class="code" href="classIndexExpr.html#a25fe1d6b6345c272d4fc46e83fa21e2b">Print</a>() <span class="keyword">const</span>;
<a name="l00281"></a>00281 
<a name="l00282"></a>00282     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classIndexExpr.html#a2b3e70bbdb74839fd1e53c8000b7440a">Optimize</a>();
<a name="l00283"></a>00283     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classIndexExpr.html#ac5d495e5df9cff4bbcbc9b580ea67fb7">TypeCheck</a>();
<a name="l00284"></a>00284     <span class="keywordtype">int</span> <a class="code" href="classIndexExpr.html#a52015acb426e8358dffe9b2e9ddfec07">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00285"></a>00285 
<a name="l00286"></a><a class="code" href="classIndexExpr.html#a5e06e65bf953e30ec2c518f528a439aa">00286</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classIndexExpr.html#a9ebd1d2a157d9958cb91d82608cd18d6">baseExpr</a>, *<a class="code" href="classIndexExpr.html#a5e06e65bf953e30ec2c518f528a439aa">index</a>;
<a name="l00287"></a>00287 };
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 <span class="comment"></span>
<a name="l00290"></a>00290 <span class="comment">/** @brief Expression representing member selection (&quot;foo.bar&quot;).</span>
<a name="l00291"></a>00291 <span class="comment"> *</span>
<a name="l00292"></a>00292 <span class="comment"> *  This will also be overloaded to deal with swizzles.</span>
<a name="l00293"></a>00293 <span class="comment"> */</span>
<a name="l00294"></a><a class="code" href="classMemberExpr.html">00294</a> <span class="keyword">class </span><a class="code" href="classMemberExpr.html" title="Expression representing member selection (&quot;foo.bar&quot;).">MemberExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00295"></a>00295 <span class="keyword">public</span>:
<a name="l00296"></a>00296     <span class="keyword">static</span> <a class="code" href="classMemberExpr.html" title="Expression representing member selection (&quot;foo.bar&quot;).">MemberExpr</a> *<a class="code" href="classMemberExpr.html#a41f1f08a701f9999a6972992dc5a46ae">create</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classMemberExpr.html#ae09b937def8c157105dcb5b6c74e0895">expr</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classMemberExpr.html#a22de65e0dd262aafaf0c5bd41292c72c">identifier</a>,
<a name="l00297"></a>00297                               <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> pos, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> <a class="code" href="classMemberExpr.html#a2aef07630b33e8fc186ad6aed64489bb">identifierPos</a>,
<a name="l00298"></a>00298                               <span class="keywordtype">bool</span> derefLvalue);
<a name="l00299"></a>00299     llvm::Value *<a class="code" href="classMemberExpr.html#a7d146e8f7ca8011a32e09a09fe506f7b">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00300"></a>00300     llvm::Value *<a class="code" href="classMemberExpr.html#acd46ec0f9bf97132fccc5649a0b279ef">GetLValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00301"></a>00301     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classMemberExpr.html#a618e9c9658998e410383b63a2b5c635e">GetType</a>() <span class="keyword">const</span>;
<a name="l00302"></a>00302     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classMemberExpr.html#a7a3bd3494a146748d6963acea9cf1c13">GetBaseSymbol</a>() <span class="keyword">const</span>;
<a name="l00303"></a>00303     <span class="keywordtype">void</span> <a class="code" href="classMemberExpr.html#ab7c0cf67c57e645b095fefef16764c9e">Print</a>() <span class="keyword">const</span>;
<a name="l00304"></a>00304     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classMemberExpr.html#a5295ee2a6a6afdce1fe3a1d05d54836b">Optimize</a>();
<a name="l00305"></a>00305     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classMemberExpr.html#a118f925d1f975296a0083097196a20d5">TypeCheck</a>();
<a name="l00306"></a>00306     <span class="keywordtype">int</span> <a class="code" href="classMemberExpr.html#acf15d8e397cd8fe113cfb9d0e560d6a7">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00307"></a>00307 
<a name="l00308"></a>00308     <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classMemberExpr.html#a3bf18b37b2d2afdc22115e8e6fad79a2">getElementNumber</a>() <span class="keyword">const</span> = 0;
<a name="l00309"></a>00309     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classMemberExpr.html#a98d089638f1bf022bb95dd73ec4f2f81">getElementType</a>() <span class="keyword">const</span> = 0;
<a name="l00310"></a>00310     std::string <a class="code" href="classMemberExpr.html#a937295319c4e5de2b0b80aca53927eda">getCandidateNearMatches</a>() <span class="keyword">const</span>;
<a name="l00311"></a>00311 
<a name="l00312"></a><a class="code" href="classMemberExpr.html#ae09b937def8c157105dcb5b6c74e0895">00312</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classMemberExpr.html#ae09b937def8c157105dcb5b6c74e0895">expr</a>;
<a name="l00313"></a><a class="code" href="classMemberExpr.html#a22de65e0dd262aafaf0c5bd41292c72c">00313</a>     std::string <a class="code" href="classMemberExpr.html#a22de65e0dd262aafaf0c5bd41292c72c">identifier</a>;
<a name="l00314"></a><a class="code" href="classMemberExpr.html#a2aef07630b33e8fc186ad6aed64489bb">00314</a>     <span class="keyword">const</span> <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> <a class="code" href="classMemberExpr.html#a2aef07630b33e8fc186ad6aed64489bb">identifierPos</a>;
<a name="l00315"></a>00315 
<a name="l00316"></a>00316     <a class="code" href="classMemberExpr.html#a0b51fd5192ba137e670b328f1da27337">MemberExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *expr, <span class="keyword">const</span> <span class="keywordtype">char</span> *identifier, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> pos, 
<a name="l00317"></a>00317                <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> identifierPos, <span class="keywordtype">bool</span> derefLValue);
<a name="l00318"></a>00318 <span class="comment"></span>
<a name="l00319"></a>00319 <span class="comment">    /** Indicates whether the expression should be dereferenced before the</span>
<a name="l00320"></a>00320 <span class="comment">        member is found.  (i.e. this is true if the MemberExpr was a &#39;-&gt;&#39;</span>
<a name="l00321"></a>00321 <span class="comment">        operator, and is false if it was a &#39;.&#39; operator. */</span>
<a name="l00322"></a><a class="code" href="classMemberExpr.html#ad9847cfd7fbe3d25e3905b00e9e8508c">00322</a>     <span class="keywordtype">bool</span> <a class="code" href="classMemberExpr.html#ad9847cfd7fbe3d25e3905b00e9e8508c">dereferenceExpr</a>;
<a name="l00323"></a>00323 };
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="comment"></span>
<a name="l00326"></a>00326 <span class="comment">/** @brief Expression representing a compile-time constant value.  </span>
<a name="l00327"></a>00327 <span class="comment"></span>
<a name="l00328"></a>00328 <span class="comment">    This class can currently represent compile-time constants of anything</span>
<a name="l00329"></a>00329 <span class="comment">    that is an AtomicType or an EnumType; for anything more complex, we</span>
<a name="l00330"></a>00330 <span class="comment">    don&#39;t currently have a representation of a compile-time constant that</span>
<a name="l00331"></a>00331 <span class="comment">    can be further reasoned about.</span>
<a name="l00332"></a>00332 <span class="comment"> */</span>
<a name="l00333"></a><a class="code" href="classConstExpr.html">00333</a> <span class="keyword">class </span><a class="code" href="classConstExpr.html" title="Expression representing a compile-time constant value.">ConstExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00334"></a>00334 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l00335"></a>00335 <span class="comment">    /** Create a ConstExpr from a uniform int8 value */</span>
<a name="l00336"></a>00336     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, int8_t i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00337"></a>00337 <span class="comment">    /** Create a ConstExpr from a varying int8 value */</span>
<a name="l00338"></a>00338     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, int8_t *i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00339"></a>00339 <span class="comment">    /** Create a ConstExpr from a uniform uint8 value */</span>
<a name="l00340"></a>00340     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, uint8_t u, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00341"></a>00341 <span class="comment">    /** Create a ConstExpr from a varying uint8 value */</span>
<a name="l00342"></a>00342     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, uint8_t *u, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00343"></a>00343 <span class="comment"></span>
<a name="l00344"></a>00344 <span class="comment">    /** Create a ConstExpr from a uniform int16 value */</span>
<a name="l00345"></a>00345     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, int16_t i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00346"></a>00346 <span class="comment">    /** Create a ConstExpr from a varying int16 value */</span>
<a name="l00347"></a>00347     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, int16_t *i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00348"></a>00348 <span class="comment">    /** Create a ConstExpr from a uniform uint16 value */</span>
<a name="l00349"></a>00349     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, uint16_t u, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00350"></a>00350 <span class="comment">    /** Create a ConstExpr from a varying uint16 value */</span>
<a name="l00351"></a>00351     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, uint16_t *u, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00352"></a>00352 <span class="comment"></span>
<a name="l00353"></a>00353 <span class="comment">    /** Create a ConstExpr from a uniform int32 value */</span>
<a name="l00354"></a>00354     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <a class="code" href="parse_8yy.html#a10e8b2d266b06d06f972396bf71af292">int32_t</a> i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00355"></a>00355 <span class="comment">    /** Create a ConstExpr from a varying int32 value */</span>
<a name="l00356"></a>00356     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <a class="code" href="parse_8yy.html#a10e8b2d266b06d06f972396bf71af292">int32_t</a> *i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00357"></a>00357 <span class="comment">    /** Create a ConstExpr from a uniform uint32 value */</span>
<a name="l00358"></a>00358     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, uint32_t u, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00359"></a>00359 <span class="comment">    /** Create a ConstExpr from a varying uint32 value */</span>
<a name="l00360"></a>00360     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, uint32_t *u, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00361"></a>00361 <span class="comment"></span>
<a name="l00362"></a>00362 <span class="comment">    /** Create a ConstExpr from a uniform float value */</span>
<a name="l00363"></a>00363     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <span class="keywordtype">float</span> f, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00364"></a>00364 <span class="comment">    /** Create a ConstExpr from a varying float value */</span>
<a name="l00365"></a>00365     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <span class="keywordtype">float</span> *f, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00366"></a>00366 <span class="comment"></span>
<a name="l00367"></a>00367 <span class="comment">    /** Create a ConstExpr from a uniform double value */</span>
<a name="l00368"></a>00368     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <span class="keywordtype">double</span> d, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00369"></a>00369 <span class="comment">    /** Create a ConstExpr from a varying double value */</span>
<a name="l00370"></a>00370     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <span class="keywordtype">double</span> *d, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00371"></a>00371 <span class="comment"></span>
<a name="l00372"></a>00372 <span class="comment">    /** Create a ConstExpr from a uniform int64 value */</span>
<a name="l00373"></a>00373     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, int64_t i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00374"></a>00374 <span class="comment">    /** Create a ConstExpr from a varying int64 value */</span>
<a name="l00375"></a>00375     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, int64_t *i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00376"></a>00376 <span class="comment">    /** Create a ConstExpr from a uniform uint64 value */</span>
<a name="l00377"></a>00377     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, uint64_t i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00378"></a>00378 <span class="comment">    /** Create a ConstExpr from a varying uint64 value */</span>
<a name="l00379"></a>00379     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, uint64_t *i, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00380"></a>00380 <span class="comment"></span>
<a name="l00381"></a>00381 <span class="comment">    /** Create a ConstExpr from a uniform bool value */</span>
<a name="l00382"></a>00382     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <span class="keywordtype">bool</span> b, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);<span class="comment"></span>
<a name="l00383"></a>00383 <span class="comment">    /** Create a ConstExpr from a varying bool value */</span>
<a name="l00384"></a>00384     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <span class="keywordtype">bool</span> *b, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00385"></a>00385 <span class="comment"></span>
<a name="l00386"></a>00386 <span class="comment">    /** Create a ConstExpr of the same type as the given old ConstExpr,</span>
<a name="l00387"></a>00387 <span class="comment">        with values given by the &quot;vales&quot; parameter. */</span>
<a name="l00388"></a>00388     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<a class="code" href="classConstExpr.html" title="Expression representing a compile-time constant value.">ConstExpr</a> *old, <span class="keywordtype">double</span> *values);
<a name="l00389"></a>00389 <span class="comment"></span>
<a name="l00390"></a>00390 <span class="comment">    /** Create ConstExpr with the same type and values as the given one,</span>
<a name="l00391"></a>00391 <span class="comment">        but at the given position. */</span>
<a name="l00392"></a>00392     <a class="code" href="classConstExpr.html#a010516080d6bc0eb505d17990eff1c20">ConstExpr</a>(<a class="code" href="classConstExpr.html" title="Expression representing a compile-time constant value.">ConstExpr</a> *old, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> pos);
<a name="l00393"></a>00393 
<a name="l00394"></a>00394     llvm::Value *<a class="code" href="classConstExpr.html#ab7c1e025525bcea04483d6bbad936f9f">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00395"></a>00395     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classConstExpr.html#aebfe3a498ef43a1e47f3971247d9e375">GetType</a>() <span class="keyword">const</span>;
<a name="l00396"></a>00396     <span class="keywordtype">void</span> <a class="code" href="classConstExpr.html#a849abf21d9b9e710eaf8ae8ffb39f834">Print</a>() <span class="keyword">const</span>;
<a name="l00397"></a>00397     llvm::Constant *<a class="code" href="classConstExpr.html#a8efa14af7143740d74b91014aa1bff93">GetConstant</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classConstExpr.html#ad8eaecdf8a562262140ba193cb4d298d">type</a>) <span class="keyword">const</span>;
<a name="l00398"></a>00398 
<a name="l00399"></a>00399     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classConstExpr.html#a749ca36fc17440ef545f1c3bf728b24a">TypeCheck</a>();
<a name="l00400"></a>00400     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classConstExpr.html#ac7c0dbc645dd375fe3a843e040201651">Optimize</a>();
<a name="l00401"></a>00401     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a10d09def76d6bf1b5f965c919c8c940c">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00402"></a>00402 <span class="comment"></span>
<a name="l00403"></a>00403 <span class="comment">    /** Return the ConstExpr&#39;s values as booleans, doing type conversion</span>
<a name="l00404"></a>00404 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00405"></a>00405 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00406"></a>00406 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00407"></a>00407     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a1a89d987d12562980dd207ab0b52582f">AsBool</a>(<span class="keywordtype">bool</span> *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00408"></a>00408 <span class="comment"></span>
<a name="l00409"></a>00409 <span class="comment">    /** Return the ConstExpr&#39;s values as int8s, doing type conversion</span>
<a name="l00410"></a>00410 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00411"></a>00411 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00412"></a>00412 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00413"></a>00413     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a4cf2748101cd8313f62dfbe573f28c82">AsInt8</a>(int8_t *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00414"></a>00414 <span class="comment"></span>
<a name="l00415"></a>00415 <span class="comment">    /** Return the ConstExpr&#39;s values as uint8s, doing type conversion</span>
<a name="l00416"></a>00416 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00417"></a>00417 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00418"></a>00418 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00419"></a>00419     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a1510ce733e605185601fea54d8d8982f">AsUInt8</a>(uint8_t *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00420"></a>00420 <span class="comment"></span>
<a name="l00421"></a>00421 <span class="comment">    /** Return the ConstExpr&#39;s values as int16s, doing type conversion</span>
<a name="l00422"></a>00422 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00423"></a>00423 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00424"></a>00424 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00425"></a>00425     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a74706244467bf3d462977b9588dcd860">AsInt16</a>(int16_t *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00426"></a>00426 <span class="comment"></span>
<a name="l00427"></a>00427 <span class="comment">    /** Return the ConstExpr&#39;s values as uint16s, doing type conversion</span>
<a name="l00428"></a>00428 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00429"></a>00429 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00430"></a>00430 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00431"></a>00431     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#ac6e88a2872be62f6597240063558e497">AsUInt16</a>(uint16_t *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00432"></a>00432 <span class="comment"></span>
<a name="l00433"></a>00433 <span class="comment">    /** Return the ConstExpr&#39;s values as int32s, doing type conversion</span>
<a name="l00434"></a>00434 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00435"></a>00435 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00436"></a>00436 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00437"></a>00437     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a020f60a6a49d042f4c5ff73f90e83c5d">AsInt32</a>(<a class="code" href="parse_8yy.html#a10e8b2d266b06d06f972396bf71af292">int32_t</a> *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00438"></a>00438 <span class="comment"></span>
<a name="l00439"></a>00439 <span class="comment">    /** Return the ConstExpr&#39;s values as uint32s, doing type conversion</span>
<a name="l00440"></a>00440 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00441"></a>00441 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00442"></a>00442 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00443"></a>00443     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#ad1410b0e96d29d7a9d2f1fb6f7a23f5f">AsUInt32</a>(uint32_t *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00444"></a>00444 <span class="comment"></span>
<a name="l00445"></a>00445 <span class="comment">    /** Return the ConstExpr&#39;s values as floats, doing type conversion</span>
<a name="l00446"></a>00446 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00447"></a>00447 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00448"></a>00448 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00449"></a>00449     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a24e75d1c1f6781c5a249bbb75237c7a1">AsFloat</a>(<span class="keywordtype">float</span> *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00450"></a>00450 <span class="comment"></span>
<a name="l00451"></a>00451 <span class="comment">    /** Return the ConstExpr&#39;s values as int64s, doing type conversion</span>
<a name="l00452"></a>00452 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00453"></a>00453 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00454"></a>00454 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00455"></a>00455     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a498cc9fc819dd91cc54442b1bafad436">AsInt64</a>(int64_t *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00456"></a>00456 <span class="comment"></span>
<a name="l00457"></a>00457 <span class="comment">    /** Return the ConstExpr&#39;s values as uint64s, doing type conversion</span>
<a name="l00458"></a>00458 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00459"></a>00459 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00460"></a>00460 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00461"></a>00461     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#aecdd71328cd80c3fad1daf81c15d7ac2">AsUInt64</a>(uint64_t *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00462"></a>00462 <span class="comment"></span>
<a name="l00463"></a>00463 <span class="comment">    /** Return the ConstExpr&#39;s values as doubles, doing type conversion</span>
<a name="l00464"></a>00464 <span class="comment">        from the actual type if needed.  If forceVarying is true, then type</span>
<a name="l00465"></a>00465 <span class="comment">        convert to &#39;varying&#39; so as to always return a number of values</span>
<a name="l00466"></a>00466 <span class="comment">        equal to the target vector width into the given pointer. */</span>
<a name="l00467"></a>00467     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#a1764cdbdcc71801cee81fb10171f5572">AsDouble</a>(<span class="keywordtype">double</span> *, <span class="keywordtype">bool</span> forceVarying = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00468"></a>00468 <span class="comment"></span>
<a name="l00469"></a>00469 <span class="comment">    /** Return the number of values in the ConstExpr; should be either 1,</span>
<a name="l00470"></a>00470 <span class="comment">        if it has uniform type, or the target&#39;s vector width if it&#39;s</span>
<a name="l00471"></a>00471 <span class="comment">        varying. */</span>
<a name="l00472"></a>00472     <span class="keywordtype">int</span> <a class="code" href="classConstExpr.html#adc914222b8baf9433171903f30f12ef9">Count</a>() <span class="keyword">const</span>;
<a name="l00473"></a>00473 
<a name="l00474"></a>00474 <span class="keyword">private</span>:
<a name="l00475"></a>00475     <a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8">AtomicType::BasicType</a> <a class="code" href="classConstExpr.html#ae87ca34b80a9e57dab15515c7b29b576">getBasicType</a>() <span class="keyword">const</span>;
<a name="l00476"></a>00476 
<a name="l00477"></a><a class="code" href="classConstExpr.html#ad8eaecdf8a562262140ba193cb4d298d">00477</a>     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classConstExpr.html#ad8eaecdf8a562262140ba193cb4d298d">type</a>;
<a name="l00478"></a>00478     <span class="keyword">union </span>{
<a name="l00479"></a><a class="code" href="classConstExpr.html#a63bc6c5962b9396a31c1a0785a8945fe">00479</a>         int8_t <a class="code" href="classConstExpr.html#a63bc6c5962b9396a31c1a0785a8945fe">int8Val</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00480"></a><a class="code" href="classConstExpr.html#afd182b02090182319c6cdc176abe27d8">00480</a>         uint8_t <a class="code" href="classConstExpr.html#afd182b02090182319c6cdc176abe27d8">uint8Val</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00481"></a><a class="code" href="classConstExpr.html#aa3ac1cd1662287dbe8528bc660cbb964">00481</a>         int16_t <a class="code" href="classConstExpr.html#aa3ac1cd1662287dbe8528bc660cbb964">int16Val</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00482"></a><a class="code" href="classConstExpr.html#a08dcdead96d0505b00210c1305028dd2">00482</a>         uint16_t <a class="code" href="classConstExpr.html#a08dcdead96d0505b00210c1305028dd2">uint16Val</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00483"></a><a class="code" href="classConstExpr.html#a9ad92c517e871a5d07da585041de79ce">00483</a>         <a class="code" href="parse_8yy.html#a10e8b2d266b06d06f972396bf71af292">int32_t</a> <a class="code" href="classConstExpr.html#a9ad92c517e871a5d07da585041de79ce">int32Val</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00484"></a><a class="code" href="classConstExpr.html#a6e9d75ca5c8597bc252dd2e4bb723549">00484</a>         uint32_t <a class="code" href="classConstExpr.html#a6e9d75ca5c8597bc252dd2e4bb723549">uint32Val</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00485"></a><a class="code" href="classConstExpr.html#a2aae572bb8a1b0a9522677a1b9bf91c2">00485</a>         <span class="keywordtype">bool</span> <a class="code" href="classConstExpr.html#a2aae572bb8a1b0a9522677a1b9bf91c2">boolVal</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00486"></a><a class="code" href="classConstExpr.html#aa50de7f6ba4305e7c9a9ea1f8db269fb">00486</a>         <span class="keywordtype">float</span> <a class="code" href="classConstExpr.html#aa50de7f6ba4305e7c9a9ea1f8db269fb">floatVal</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00487"></a><a class="code" href="classConstExpr.html#a133bfdab1f884014cb45a4994abbb4dd">00487</a>         <span class="keywordtype">double</span> <a class="code" href="classConstExpr.html#a133bfdab1f884014cb45a4994abbb4dd">doubleVal</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00488"></a><a class="code" href="classConstExpr.html#a4befdefdad28725c11eb48983e1de031">00488</a>         int64_t <a class="code" href="classConstExpr.html#a4befdefdad28725c11eb48983e1de031">int64Val</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00489"></a><a class="code" href="classConstExpr.html#aedffbd22b4275640503e0f78eb8811ab">00489</a>         uint64_t <a class="code" href="classConstExpr.html#aedffbd22b4275640503e0f78eb8811ab">uint64Val</a>[<a class="code" href="ispc_8h.html#a4d8b1e3b8361d8b5054fb55225f2c972">ISPC_MAX_NVEC</a>];
<a name="l00490"></a>00490     };
<a name="l00491"></a>00491 };
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 <span class="comment"></span>
<a name="l00494"></a>00494 <span class="comment">/** @brief Expression representing a type cast of the given expression to a</span>
<a name="l00495"></a>00495 <span class="comment">    probably-different type. */</span>
<a name="l00496"></a><a class="code" href="classTypeCastExpr.html">00496</a> <span class="keyword">class </span><a class="code" href="classTypeCastExpr.html" title="Expression representing a type cast of the given expression to a probably-different type...">TypeCastExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00497"></a>00497 <span class="keyword">public</span>:
<a name="l00498"></a>00498     <a class="code" href="classTypeCastExpr.html#ad558a1a03d31f482210e2fecb97b5783">TypeCastExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *e, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00499"></a>00499 
<a name="l00500"></a>00500     llvm::Value *<a class="code" href="classTypeCastExpr.html#a28389125c96a0c1afa25fd9ee2bb2c9a">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00501"></a>00501     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classTypeCastExpr.html#a885dff67661a38f4fa04a64df0afb1fd">GetType</a>() <span class="keyword">const</span>;
<a name="l00502"></a>00502     <span class="keywordtype">void</span> <a class="code" href="classTypeCastExpr.html#a1c8bd0f1258594150060f6af100c7c50">Print</a>() <span class="keyword">const</span>;
<a name="l00503"></a>00503     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classTypeCastExpr.html#a1ec58815a5e4bdb9be7eace2db9d8bf0">TypeCheck</a>();
<a name="l00504"></a>00504     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classTypeCastExpr.html#a8c1ffa77dffbfd6a039da548a65796ad">Optimize</a>();
<a name="l00505"></a>00505     <span class="keywordtype">int</span> <a class="code" href="classTypeCastExpr.html#a8b4f6a58d98ff96148a8d03fb2592081">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00506"></a>00506     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classTypeCastExpr.html#ad1a5da59de018cef7da32a8f31e59c5a">GetBaseSymbol</a>() <span class="keyword">const</span>;
<a name="l00507"></a>00507     llvm::Constant *<a class="code" href="classTypeCastExpr.html#a7cc8d5bcdafc2e9679ba62c28ae33f4e">GetConstant</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classTypeCastExpr.html#a032d0aaf472f8426186edeb52a220731">type</a>) <span class="keyword">const</span>;
<a name="l00508"></a>00508 
<a name="l00509"></a><a class="code" href="classTypeCastExpr.html#a032d0aaf472f8426186edeb52a220731">00509</a>     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classTypeCastExpr.html#a032d0aaf472f8426186edeb52a220731">type</a>;
<a name="l00510"></a><a class="code" href="classTypeCastExpr.html#a7793053dd14396260ecbcab9c87db852">00510</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classTypeCastExpr.html#a7793053dd14396260ecbcab9c87db852">expr</a>;
<a name="l00511"></a>00511 };
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 <span class="comment"></span>
<a name="l00514"></a>00514 <span class="comment">/** @brief Expression that represents taking a reference of a (non-reference)</span>
<a name="l00515"></a>00515 <span class="comment">    variable. */</span>
<a name="l00516"></a><a class="code" href="classReferenceExpr.html">00516</a> <span class="keyword">class </span><a class="code" href="classReferenceExpr.html" title="Expression that represents taking a reference of a (non-reference) variable.">ReferenceExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00517"></a>00517 <span class="keyword">public</span>:
<a name="l00518"></a>00518     <a class="code" href="classReferenceExpr.html#ace703bb1e12fc25ebd68f079232617d1">ReferenceExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *e, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00519"></a>00519 
<a name="l00520"></a>00520     llvm::Value *<a class="code" href="classReferenceExpr.html#a7b4debe98b864dd82081f3a23cc51ae4">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00521"></a>00521     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classReferenceExpr.html#a99d3936283e0ad4b287bac93e8bbfbb5">GetType</a>() <span class="keyword">const</span>;
<a name="l00522"></a>00522     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classReferenceExpr.html#a7c4548f09225b9ab9fc701583f16853e">GetLValueType</a>() <span class="keyword">const</span>;
<a name="l00523"></a>00523     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classReferenceExpr.html#ab0d05136e78ae2d4da318eea506b1afb">GetBaseSymbol</a>() <span class="keyword">const</span>;
<a name="l00524"></a>00524     <span class="keywordtype">void</span> <a class="code" href="classReferenceExpr.html#af96aabe6be6cd40933e53ed7a52abf3b">Print</a>() <span class="keyword">const</span>;
<a name="l00525"></a>00525     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classReferenceExpr.html#ab636a6871c0269295e98d731337beeb7">TypeCheck</a>();
<a name="l00526"></a>00526     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classReferenceExpr.html#a373bb9e573b56125c1b441bcfdb7d07f">Optimize</a>();
<a name="l00527"></a>00527     <span class="keywordtype">int</span> <a class="code" href="classReferenceExpr.html#a83f588792255826de8cd963637871fe5">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00528"></a>00528 
<a name="l00529"></a><a class="code" href="classReferenceExpr.html#a3be4bd392d625b815cf70845e3562cc5">00529</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classReferenceExpr.html#a3be4bd392d625b815cf70845e3562cc5">expr</a>;
<a name="l00530"></a>00530 };
<a name="l00531"></a>00531 
<a name="l00532"></a>00532 <span class="comment"></span>
<a name="l00533"></a>00533 <span class="comment">/** @brief Common base class that provides shared functionality for</span>
<a name="l00534"></a>00534 <span class="comment">    PtrDerefExpr and RefDerefExpr. */</span>
<a name="l00535"></a><a class="code" href="classDerefExpr.html">00535</a> <span class="keyword">class </span><a class="code" href="classDerefExpr.html" title="Common base class that provides shared functionality for PtrDerefExpr and RefDerefExpr.">DerefExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00536"></a>00536 <span class="keyword">public</span>:
<a name="l00537"></a>00537     <a class="code" href="classDerefExpr.html#a384339bca91ed6d0604a873bace423c2">DerefExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *e, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00538"></a>00538 
<a name="l00539"></a>00539     llvm::Value *<a class="code" href="classDerefExpr.html#aef7dd87ea43459bd969381041892b845">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00540"></a>00540     llvm::Value *<a class="code" href="classDerefExpr.html#ab4d0689bbc67ac108dd74be80e4d04cf">GetLValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00541"></a>00541     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classDerefExpr.html#adc77297eecf95df49d147182a71c7c79">GetLValueType</a>() <span class="keyword">const</span>;
<a name="l00542"></a>00542     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classDerefExpr.html#a3a3c56f57540c3b82f62554e37d7d85b">GetBaseSymbol</a>() <span class="keyword">const</span>;
<a name="l00543"></a>00543     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classDerefExpr.html#a75b5fd3d983578c399d3177f16cc7918">Optimize</a>();
<a name="l00544"></a>00544 
<a name="l00545"></a><a class="code" href="classDerefExpr.html#a40694a94f5cb53fd2c3416c48c982628">00545</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classDerefExpr.html#a40694a94f5cb53fd2c3416c48c982628">expr</a>;
<a name="l00546"></a>00546 };
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 <span class="comment"></span>
<a name="l00549"></a>00549 <span class="comment">/** @brief Expression that represents dereferencing a pointer to get its</span>
<a name="l00550"></a>00550 <span class="comment">    value. */</span>
<a name="l00551"></a><a class="code" href="classPtrDerefExpr.html">00551</a> <span class="keyword">class </span><a class="code" href="classPtrDerefExpr.html" title="Expression that represents dereferencing a pointer to get its value.">PtrDerefExpr</a> : <span class="keyword">public</span> <a class="code" href="classDerefExpr.html" title="Common base class that provides shared functionality for PtrDerefExpr and RefDerefExpr.">DerefExpr</a> {
<a name="l00552"></a>00552 <span class="keyword">public</span>:
<a name="l00553"></a>00553     <a class="code" href="classPtrDerefExpr.html#a9f55f2bc6d3ef74b71aa51de3c0862cf">PtrDerefExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *e, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00554"></a>00554 
<a name="l00555"></a>00555     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classPtrDerefExpr.html#acd13846b8c63c8e897a32f88c6b62288">GetType</a>() <span class="keyword">const</span>;
<a name="l00556"></a>00556     <span class="keywordtype">void</span> <a class="code" href="classPtrDerefExpr.html#af209276cb4dc08527dddccbf234c5e82">Print</a>() <span class="keyword">const</span>;
<a name="l00557"></a>00557     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classPtrDerefExpr.html#ac1206966c1f406948af00b886dfd6b7b">TypeCheck</a>();
<a name="l00558"></a>00558     <span class="keywordtype">int</span> <a class="code" href="classPtrDerefExpr.html#ac0b5f4cd2de4888cf1bd9a79ae336d71">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00559"></a>00559 };
<a name="l00560"></a>00560 
<a name="l00561"></a>00561 <span class="comment"></span>
<a name="l00562"></a>00562 <span class="comment">/** @brief Expression that represents dereferencing a reference to get its</span>
<a name="l00563"></a>00563 <span class="comment">    value. */</span>
<a name="l00564"></a><a class="code" href="classRefDerefExpr.html">00564</a> <span class="keyword">class </span><a class="code" href="classRefDerefExpr.html" title="Expression that represents dereferencing a reference to get its value.">RefDerefExpr</a> : <span class="keyword">public</span> <a class="code" href="classDerefExpr.html" title="Common base class that provides shared functionality for PtrDerefExpr and RefDerefExpr.">DerefExpr</a> {
<a name="l00565"></a>00565 <span class="keyword">public</span>:
<a name="l00566"></a>00566     <a class="code" href="classRefDerefExpr.html#ae9ecacc155c58e2459c3ab59a8070517">RefDerefExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *e, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00567"></a>00567 
<a name="l00568"></a>00568     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classRefDerefExpr.html#a914e7e43a5500fbf4de9ab3c3b607daf">GetType</a>() <span class="keyword">const</span>;
<a name="l00569"></a>00569     <span class="keywordtype">void</span> <a class="code" href="classRefDerefExpr.html#a24c5fab08be9986b44e4803e64b14e32">Print</a>() <span class="keyword">const</span>;
<a name="l00570"></a>00570     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classRefDerefExpr.html#aa003d13c9d4898d2f3f9e078c7cef4bb">TypeCheck</a>();
<a name="l00571"></a>00571     <span class="keywordtype">int</span> <a class="code" href="classRefDerefExpr.html#a578d4ea05d2ac248fccdccbf9ae20b68">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00572"></a>00572 };
<a name="l00573"></a>00573 
<a name="l00574"></a>00574 <span class="comment"></span>
<a name="l00575"></a>00575 <span class="comment">/** Expression that represents taking the address of an expression. */</span>
<a name="l00576"></a><a class="code" href="classAddressOfExpr.html">00576</a> <span class="keyword">class </span><a class="code" href="classAddressOfExpr.html">AddressOfExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00577"></a>00577 <span class="keyword">public</span>:
<a name="l00578"></a>00578     <a class="code" href="classAddressOfExpr.html#a817a94585de3fb51496e9480f2515d8c">AddressOfExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *e, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00579"></a>00579 
<a name="l00580"></a>00580     llvm::Value *<a class="code" href="classAddressOfExpr.html#a26857f67e3d124c7fce39da660160369">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00581"></a>00581     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classAddressOfExpr.html#abc0ee884a1940814173c780ae3a8451d">GetType</a>() <span class="keyword">const</span>;
<a name="l00582"></a>00582     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classAddressOfExpr.html#aaee08a1e548c2004d58245afcec362f4">GetBaseSymbol</a>() <span class="keyword">const</span>;
<a name="l00583"></a>00583     <span class="keywordtype">void</span> <a class="code" href="classAddressOfExpr.html#aec56b4f8c80d7df2f001e1d540f0270f">Print</a>() <span class="keyword">const</span>;
<a name="l00584"></a>00584     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classAddressOfExpr.html#aba6b0861592a85a5792106a9a356a986">TypeCheck</a>();
<a name="l00585"></a>00585     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classAddressOfExpr.html#ace3ad5d8bb7e7352d0f5ce50e3f25a89">Optimize</a>();
<a name="l00586"></a>00586     <span class="keywordtype">int</span> <a class="code" href="classAddressOfExpr.html#abe4e669ecf94c4b0a9ffaf3e7cddc784">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00587"></a>00587     llvm::Constant *<a class="code" href="classAddressOfExpr.html#ac9d0d4ab89d9cc9d1b8d275b4b946034">GetConstant</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *type) <span class="keyword">const</span>;
<a name="l00588"></a>00588 
<a name="l00589"></a><a class="code" href="classAddressOfExpr.html#ade0bd6fe9819b52eda25a9c4c2fd3020">00589</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classAddressOfExpr.html#ade0bd6fe9819b52eda25a9c4c2fd3020">expr</a>;
<a name="l00590"></a>00590 };
<a name="l00591"></a>00591 
<a name="l00592"></a>00592 <span class="comment"></span>
<a name="l00593"></a>00593 <span class="comment">/** Expression that returns the size of the given expression or type in</span>
<a name="l00594"></a>00594 <span class="comment">    bytes. */</span>
<a name="l00595"></a><a class="code" href="classSizeOfExpr.html">00595</a> <span class="keyword">class </span><a class="code" href="classSizeOfExpr.html">SizeOfExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00596"></a>00596 <span class="keyword">public</span>:
<a name="l00597"></a>00597     <a class="code" href="classSizeOfExpr.html#af46b2a0e9e325609aed843f49f10ac16">SizeOfExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *e, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00598"></a>00598     <a class="code" href="classSizeOfExpr.html#af46b2a0e9e325609aed843f49f10ac16">SizeOfExpr</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *t, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00599"></a>00599 
<a name="l00600"></a>00600     llvm::Value *<a class="code" href="classSizeOfExpr.html#a14b0281c512ae7b40eeb9a5b1058cd77">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00601"></a>00601     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classSizeOfExpr.html#a29be1c6dcc8f135ba0c0e63fd3e7105c">GetType</a>() <span class="keyword">const</span>;
<a name="l00602"></a>00602     <span class="keywordtype">void</span> <a class="code" href="classSizeOfExpr.html#a4de33078785434649bc6270c4eb176d9">Print</a>() <span class="keyword">const</span>;
<a name="l00603"></a>00603     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSizeOfExpr.html#acf09c917c1dafa883df28073aab4d522">TypeCheck</a>();
<a name="l00604"></a>00604     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSizeOfExpr.html#a7391c5f382632f4b981faaa86e001934">Optimize</a>();
<a name="l00605"></a>00605     <span class="keywordtype">int</span> <a class="code" href="classSizeOfExpr.html#a936982209330e40fac37c1c5df38bd4b">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00606"></a>00606 
<a name="l00607"></a>00607     <span class="comment">/* One of expr or type should be non-NULL (but not both of them).  The</span>
<a name="l00608"></a>00608 <span class="comment">       SizeOfExpr returns the size of whichever one of them isn&#39;t NULL. */</span>
<a name="l00609"></a><a class="code" href="classSizeOfExpr.html#a75506c8881928476069ab4e9bb07ae76">00609</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSizeOfExpr.html#a75506c8881928476069ab4e9bb07ae76">expr</a>;
<a name="l00610"></a><a class="code" href="classSizeOfExpr.html#a3489196e1db5164c9e2b9621226c92ea">00610</a>     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classSizeOfExpr.html#a3489196e1db5164c9e2b9621226c92ea">type</a>;
<a name="l00611"></a>00611 };
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 <span class="comment"></span>
<a name="l00614"></a>00614 <span class="comment">/** @brief Expression representing a symbol reference in the program */</span>
<a name="l00615"></a><a class="code" href="classSymbolExpr.html">00615</a> <span class="keyword">class </span><a class="code" href="classSymbolExpr.html" title="Expression representing a symbol reference in the program.">SymbolExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00616"></a>00616 <span class="keyword">public</span>:
<a name="l00617"></a>00617     <a class="code" href="classSymbolExpr.html#a4a7262071b7df8d91821e67e6fcb75e0">SymbolExpr</a>(<a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="parse_8yy.html#a670da3e561356241efb8054bd91b88a8">s</a>, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00618"></a>00618 
<a name="l00619"></a>00619     llvm::Value *<a class="code" href="classSymbolExpr.html#ad87d063e378a3adce31dc9e5e185af0d">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00620"></a>00620     llvm::Value *<a class="code" href="classSymbolExpr.html#ad86cdf5dceb9bb6638f19cb4193fc844">GetLValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00621"></a>00621     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classSymbolExpr.html#a34c9bdebbcafcb318f40f4bf65f42426">GetType</a>() <span class="keyword">const</span>;
<a name="l00622"></a>00622     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classSymbolExpr.html#a3b477da6f513990442af007f832b4de0">GetLValueType</a>() <span class="keyword">const</span>;
<a name="l00623"></a>00623     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classSymbolExpr.html#af1914db18366a395558b4f4e6b083929">GetBaseSymbol</a>() <span class="keyword">const</span>;
<a name="l00624"></a>00624     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSymbolExpr.html#ab8ba46274b1e56244baab9e3fd9d169f">TypeCheck</a>();
<a name="l00625"></a>00625     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSymbolExpr.html#a09610f84e65c3062016d30642b09cf20">Optimize</a>();
<a name="l00626"></a>00626     <span class="keywordtype">void</span> <a class="code" href="classSymbolExpr.html#a2dbebb90a83e96c0de88a264114a3099">Print</a>() <span class="keyword">const</span>;
<a name="l00627"></a>00627     <span class="keywordtype">int</span> <a class="code" href="classSymbolExpr.html#a846cb5a74470843194481112ee3b9fa7">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00628"></a>00628 
<a name="l00629"></a>00629 <span class="keyword">private</span>:
<a name="l00630"></a><a class="code" href="classSymbolExpr.html#a063f9e83d4d690fb8617a93f373fea63">00630</a>     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classSymbolExpr.html#a063f9e83d4d690fb8617a93f373fea63">symbol</a>;
<a name="l00631"></a>00631 };
<a name="l00632"></a>00632 
<a name="l00633"></a>00633 <span class="comment"></span>
<a name="l00634"></a>00634 <span class="comment">/** @brief Expression representing a function symbol in the program (generally</span>
<a name="l00635"></a>00635 <span class="comment">    used for a function call).</span>
<a name="l00636"></a>00636 <span class="comment"> */</span>    
<a name="l00637"></a><a class="code" href="classFunctionSymbolExpr.html">00637</a> <span class="keyword">class </span><a class="code" href="classFunctionSymbolExpr.html" title="Expression representing a function symbol in the program (generally used for a function call)...">FunctionSymbolExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00638"></a>00638 <span class="keyword">public</span>:
<a name="l00639"></a>00639     <a class="code" href="classFunctionSymbolExpr.html#adc3511eb43f830bc07269437e5f985d3">FunctionSymbolExpr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classFunctionSymbolExpr.html#a23dc665e0c2734daea7439ba42c75f45">name</a>, <span class="keyword">const</span> std::vector&lt;Symbol *&gt; &amp;candFuncs,
<a name="l00640"></a>00640                        <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> pos);
<a name="l00641"></a>00641 
<a name="l00642"></a>00642     llvm::Value *<a class="code" href="classFunctionSymbolExpr.html#a1eee5a80543e4a51b2ccb6c41396ccc5">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00643"></a>00643     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classFunctionSymbolExpr.html#a36c54fa6b3874295878880e92e90575b">GetType</a>() <span class="keyword">const</span>;
<a name="l00644"></a>00644     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classFunctionSymbolExpr.html#a7f6831ce09b79f8cdca14365d11a5bb1">GetBaseSymbol</a>() <span class="keyword">const</span>;
<a name="l00645"></a>00645     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classFunctionSymbolExpr.html#ad44e613dd2071288a93a8487aacbcdf8">TypeCheck</a>();
<a name="l00646"></a>00646     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classFunctionSymbolExpr.html#a16727f6e846c7a554f823c397a1a6149">Optimize</a>();
<a name="l00647"></a>00647     <span class="keywordtype">void</span> <a class="code" href="classFunctionSymbolExpr.html#a754a28381847e8d9eb7772cbc56c6774">Print</a>() <span class="keyword">const</span>;
<a name="l00648"></a>00648     <span class="keywordtype">int</span> <a class="code" href="classFunctionSymbolExpr.html#a7a69453705486679ffa3e991a748733b">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00649"></a>00649     llvm::Constant *<a class="code" href="classFunctionSymbolExpr.html#aa165c8f40585c2cc1aa6dce5b788f5d0">GetConstant</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *type) <span class="keyword">const</span>;
<a name="l00650"></a>00650 <span class="comment"></span>
<a name="l00651"></a>00651 <span class="comment">    /** Given the types of the function arguments, in the presence of</span>
<a name="l00652"></a>00652 <span class="comment">        function overloading, this method resolves which actual function</span>
<a name="l00653"></a>00653 <span class="comment">        the arguments match best.  If the argCouldBeNULL parameter is</span>
<a name="l00654"></a>00654 <span class="comment">        non-NULL, each element indicates whether the corresponding argument</span>
<a name="l00655"></a>00655 <span class="comment">        is the number zero, indicating that it could be a NULL pointer, and</span>
<a name="l00656"></a>00656 <span class="comment">        if argIsConstant is non-NULL, each element indicates whether the</span>
<a name="l00657"></a>00657 <span class="comment">        corresponding argument is a compile-time constant value.  Both of</span>
<a name="l00658"></a>00658 <span class="comment">        these parameters may be NULL (for cases where overload resolution</span>
<a name="l00659"></a>00659 <span class="comment">        is being done just given type information without the parameter</span>
<a name="l00660"></a>00660 <span class="comment">        argument expressions being available.  This function returns true</span>
<a name="l00661"></a>00661 <span class="comment">        on success.</span>
<a name="l00662"></a>00662 <span class="comment">     */</span>
<a name="l00663"></a>00663     <span class="keywordtype">bool</span> <a class="code" href="classFunctionSymbolExpr.html#aceb7cd318b78f800b7aa3b0b81672fd1">ResolveOverloads</a>(<a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> argPos,
<a name="l00664"></a>00664                           <span class="keyword">const</span> std::vector&lt;const Type *&gt; &amp;argTypes,
<a name="l00665"></a>00665                           <span class="keyword">const</span> std::vector&lt;bool&gt; *argCouldBeNULL = <a class="code" href="parse_8yy.html">NULL</a>,
<a name="l00666"></a>00666                           <span class="keyword">const</span> std::vector&lt;bool&gt; *argIsConstant = <a class="code" href="parse_8yy.html">NULL</a>);
<a name="l00667"></a>00667     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classFunctionSymbolExpr.html#a279cba96c85ccb8bec2c4d188641804b">GetMatchingFunction</a>();
<a name="l00668"></a>00668 
<a name="l00669"></a>00669 <span class="keyword">private</span>:
<a name="l00670"></a>00670     std::vector&lt;Symbol *&gt; <a class="code" href="classFunctionSymbolExpr.html#ad0a510cd40937d0ccbc7d4859ae4e378">getCandidateFunctions</a>(<span class="keywordtype">int</span> argCount) <span class="keyword">const</span>;
<a name="l00671"></a>00671     <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classFunctionSymbolExpr.html#ad69e922c2917b9afcd920b3fdf5442e9">computeOverloadCost</a>(<span class="keyword">const</span> <a class="code" href="classFunctionType.html" title="Type representing a function (return type + argument types)">FunctionType</a> *ftype,
<a name="l00672"></a>00672                                    <span class="keyword">const</span> std::vector&lt;const Type *&gt; &amp;argTypes,
<a name="l00673"></a>00673                                    <span class="keyword">const</span> std::vector&lt;bool&gt; *argCouldBeNULL,
<a name="l00674"></a>00674                             <span class="keyword">const</span> std::vector&lt;bool&gt; *argIsConstant);
<a name="l00675"></a>00675 <span class="comment"></span>
<a name="l00676"></a>00676 <span class="comment">    /** Name of the function that is being called. */</span>
<a name="l00677"></a><a class="code" href="classFunctionSymbolExpr.html#a23dc665e0c2734daea7439ba42c75f45">00677</a>     std::string <a class="code" href="classFunctionSymbolExpr.html#a23dc665e0c2734daea7439ba42c75f45">name</a>;
<a name="l00678"></a>00678 <span class="comment"></span>
<a name="l00679"></a>00679 <span class="comment">    /** All of the functions with the name given in the function call;</span>
<a name="l00680"></a>00680 <span class="comment">        there may be more then one, in which case we need to resolve which</span>
<a name="l00681"></a>00681 <span class="comment">        overload is the best match. */</span>
<a name="l00682"></a><a class="code" href="classFunctionSymbolExpr.html#a78f5eb40094e572c102215fd9e9c8d9a">00682</a>     std::vector&lt;Symbol *&gt; <a class="code" href="classFunctionSymbolExpr.html#a78f5eb40094e572c102215fd9e9c8d9a">candidateFunctions</a>;
<a name="l00683"></a>00683 <span class="comment"></span>
<a name="l00684"></a>00684 <span class="comment">    /** The actual matching function found after overload resolution. */</span>
<a name="l00685"></a><a class="code" href="classFunctionSymbolExpr.html#ada53c1fccabda44ceb4a65faa9b8fc8a">00685</a>     <a class="code" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> *<a class="code" href="classFunctionSymbolExpr.html#ada53c1fccabda44ceb4a65faa9b8fc8a">matchingFunc</a>;
<a name="l00686"></a>00686 
<a name="l00687"></a><a class="code" href="classFunctionSymbolExpr.html#a71400218b7f4dedb4d339358b05c525a">00687</a>     <span class="keywordtype">bool</span> <a class="code" href="classFunctionSymbolExpr.html#a71400218b7f4dedb4d339358b05c525a">triedToResolve</a>;
<a name="l00688"></a>00688 };
<a name="l00689"></a>00689 
<a name="l00690"></a>00690 <span class="comment"></span>
<a name="l00691"></a>00691 <span class="comment">/** @brief A sync statement in the program (waits for all launched tasks before</span>
<a name="l00692"></a>00692 <span class="comment">    proceeding). */</span>
<a name="l00693"></a><a class="code" href="classSyncExpr.html">00693</a> <span class="keyword">class </span><a class="code" href="classSyncExpr.html" title="A sync statement in the program (waits for all launched tasks before proceeding).">SyncExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00694"></a>00694 <span class="keyword">public</span>:
<a name="l00695"></a><a class="code" href="classSyncExpr.html#a61a97214bbee52ad2499fcadf892709e">00695</a>     <a class="code" href="classSyncExpr.html#a61a97214bbee52ad2499fcadf892709e">SyncExpr</a>(<a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p) : <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a>(p) { }
<a name="l00696"></a>00696 
<a name="l00697"></a>00697     llvm::Value *<a class="code" href="classSyncExpr.html#aa9a46eb62f7879b61fd56da3092b4ff5">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00698"></a>00698     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classSyncExpr.html#a9279f70fda2e643d34972bdff71b0a47">GetType</a>() <span class="keyword">const</span>;
<a name="l00699"></a>00699     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSyncExpr.html#af411fe3062afc649c104ed877bd5fd41">TypeCheck</a>();
<a name="l00700"></a>00700     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classSyncExpr.html#a12b8c56aa2ae34936242b449932e467f">Optimize</a>();
<a name="l00701"></a>00701     <span class="keywordtype">void</span> <a class="code" href="classSyncExpr.html#ad3a4bff2fbe2b44429b3765dfdf3e1bb">Print</a>() <span class="keyword">const</span>;
<a name="l00702"></a>00702     <span class="keywordtype">int</span> <a class="code" href="classSyncExpr.html#a98c9e183d66f659cdfed37e332c0de44">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00703"></a>00703 };
<a name="l00704"></a>00704 
<a name="l00705"></a>00705 <span class="comment"></span>
<a name="l00706"></a>00706 <span class="comment">/** @brief An expression that represents a NULL pointer. */</span>
<a name="l00707"></a><a class="code" href="classNullPointerExpr.html">00707</a> <span class="keyword">class </span><a class="code" href="classNullPointerExpr.html" title="An expression that represents a NULL pointer.">NullPointerExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00708"></a>00708 <span class="keyword">public</span>:
<a name="l00709"></a><a class="code" href="classNullPointerExpr.html#acebb8ef975899ecfd51351b1a30e02bb">00709</a>     <a class="code" href="classNullPointerExpr.html#acebb8ef975899ecfd51351b1a30e02bb">NullPointerExpr</a>(<a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p) : <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a>(p) { }
<a name="l00710"></a>00710     
<a name="l00711"></a>00711     llvm::Value *<a class="code" href="classNullPointerExpr.html#a712084b202968c0d33056f5b48b98051">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00712"></a>00712     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classNullPointerExpr.html#a9d5a368b03a4010a46376bd9a467d807">GetType</a>() <span class="keyword">const</span>;
<a name="l00713"></a>00713     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classNullPointerExpr.html#a8256bd3c7d8e8c7e6ad76f7b8290bca5">TypeCheck</a>();
<a name="l00714"></a>00714     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classNullPointerExpr.html#a40c6da2090595393ab5fd08a3719d696">Optimize</a>();
<a name="l00715"></a>00715     llvm::Constant *<a class="code" href="classNullPointerExpr.html#a08180a1143c37c8c10e221e691096312">GetConstant</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *type) <span class="keyword">const</span>;
<a name="l00716"></a>00716     <span class="keywordtype">void</span> <a class="code" href="classNullPointerExpr.html#aa32f15aad78ac2632020a9a11525ae83">Print</a>() <span class="keyword">const</span>;
<a name="l00717"></a>00717     <span class="keywordtype">int</span> <a class="code" href="classNullPointerExpr.html#a2ba09b53ff5f0c3883d1a1612bbaf3c7">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00718"></a>00718 };
<a name="l00719"></a>00719 
<a name="l00720"></a>00720 <span class="comment"></span>
<a name="l00721"></a>00721 <span class="comment">/** An expression representing a &quot;new&quot; expression, used for dynamically</span>
<a name="l00722"></a>00722 <span class="comment">    allocating memory. </span>
<a name="l00723"></a>00723 <span class="comment">*/</span>
<a name="l00724"></a><a class="code" href="classNewExpr.html">00724</a> <span class="keyword">class </span><a class="code" href="classNewExpr.html">NewExpr</a> : <span class="keyword">public</span> <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> {
<a name="l00725"></a>00725 <span class="keyword">public</span>:
<a name="l00726"></a>00726     <a class="code" href="classNewExpr.html#ab976b0ebbe103e70921de4bc15e261cb">NewExpr</a>(<span class="keywordtype">int</span> typeQual, <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *type, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *initializer, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *count, 
<a name="l00727"></a>00727             <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> tqPos, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> p);
<a name="l00728"></a>00728 
<a name="l00729"></a>00729     llvm::Value *<a class="code" href="classNewExpr.html#a96cc1e70111af1c1da1664fc9588256d">GetValue</a>(<a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx) <span class="keyword">const</span>;
<a name="l00730"></a>00730     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classNewExpr.html#ac33e9290b94098ec203c559ba4d1ccad">GetType</a>() <span class="keyword">const</span>;
<a name="l00731"></a>00731     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classNewExpr.html#abffd00e21baf7403ee8418c59e90ebee">TypeCheck</a>();
<a name="l00732"></a>00732     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classNewExpr.html#a62109328a6a3969b4071b9713c606889">Optimize</a>();
<a name="l00733"></a>00733     <span class="keywordtype">void</span> <a class="code" href="classNewExpr.html#a09da9f063895004478b15db5ac03a38d">Print</a>() <span class="keyword">const</span>;
<a name="l00734"></a>00734     <span class="keywordtype">int</span> <a class="code" href="classNewExpr.html#a17c78f8512422900b53fc9ab8c38b692">EstimateCost</a>() <span class="keyword">const</span>;
<a name="l00735"></a>00735 <span class="comment"></span>
<a name="l00736"></a>00736 <span class="comment">    /** Type of object to allocate storage for. */</span>
<a name="l00737"></a><a class="code" href="classNewExpr.html#a1927cb3da9e9fb5de2bc2b2a1e045257">00737</a>     <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *<a class="code" href="classNewExpr.html#a1927cb3da9e9fb5de2bc2b2a1e045257">allocType</a>;<span class="comment"></span>
<a name="l00738"></a>00738 <span class="comment">    /** Expression giving the number of elements to allocate, when the </span>
<a name="l00739"></a>00739 <span class="comment">        &quot;new Foo[expr]&quot; form is used.  This may be NULL, in which case a</span>
<a name="l00740"></a>00740 <span class="comment">        single element of the given type will be allocated. */</span>
<a name="l00741"></a><a class="code" href="classNewExpr.html#a31327255dc2a339eef839552dd637dca">00741</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classNewExpr.html#a31327255dc2a339eef839552dd637dca">countExpr</a>;<span class="comment"></span>
<a name="l00742"></a>00742 <span class="comment">    /** Optional initializer expression used to initialize the allocated</span>
<a name="l00743"></a>00743 <span class="comment">        memory. */</span>
<a name="l00744"></a><a class="code" href="classNewExpr.html#a39548fde25d84a3cc71ce8e270cc111d">00744</a>     <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="classNewExpr.html#a39548fde25d84a3cc71ce8e270cc111d">initExpr</a>;<span class="comment"></span>
<a name="l00745"></a>00745 <span class="comment">    /** Indicates whether this is a &quot;varying new&quot; or &quot;uniform new&quot;</span>
<a name="l00746"></a>00746 <span class="comment">        (i.e. whether a separate allocation is performed per program</span>
<a name="l00747"></a>00747 <span class="comment">        instance, or whether a single allocation is performed for the</span>
<a name="l00748"></a>00748 <span class="comment">        entire gang of program instances.) */</span>
<a name="l00749"></a><a class="code" href="classNewExpr.html#a55cdd98a7a22fa4bcafd2d14469e75b9">00749</a>     <span class="keywordtype">bool</span> <a class="code" href="classNewExpr.html#a55cdd98a7a22fa4bcafd2d14469e75b9">isVarying</a>;
<a name="l00750"></a>00750 };
<a name="l00751"></a>00751 
<a name="l00752"></a>00752 <span class="comment"></span>
<a name="l00753"></a>00753 <span class="comment">/** This function indicates whether it&#39;s legal to convert from fromType to</span>
<a name="l00754"></a>00754 <span class="comment">    toType.  If the optional errorMsgBase and source position parameters</span>
<a name="l00755"></a>00755 <span class="comment">    are provided, then an error message is issued if the type conversion</span>
<a name="l00756"></a>00756 <span class="comment">    isn&#39;t possible.</span>
<a name="l00757"></a>00757 <span class="comment"> */</span>
<a name="l00758"></a>00758 <span class="keywordtype">bool</span> <a class="code" href="expr_8h.html#a22c267bd1298a34e1b3fec5254903717">CanConvertTypes</a>(<span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *fromType, <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *toType,
<a name="l00759"></a>00759                      <span class="keyword">const</span> <span class="keywordtype">char</span> *errorMsgBase = NULL,
<a name="l00760"></a>00760                      <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> pos = <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a>());
<a name="l00761"></a>00761 <span class="comment"></span>
<a name="l00762"></a>00762 <span class="comment">/** This function attempts to convert the given expression to the given</span>
<a name="l00763"></a>00763 <span class="comment">    type, returning a pointer to a new expression that is the result.  If</span>
<a name="l00764"></a>00764 <span class="comment">    the required type conversion is illegal, it returns NULL and prints an</span>
<a name="l00765"></a>00765 <span class="comment">    error message using the provided string to indicate the context for</span>
<a name="l00766"></a>00766 <span class="comment">    which type conversion was being applied (e.g. &quot;function call</span>
<a name="l00767"></a>00767 <span class="comment">    parameter&quot;).</span>
<a name="l00768"></a>00768 <span class="comment"> */</span>
<a name="l00769"></a>00769 <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *<a class="code" href="expr_8h.html#a776a3d6e37bb2b78ce0d3ed4cdea9556">TypeConvertExpr</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *expr, <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *toType, <span class="keyword">const</span> <span class="keywordtype">char</span> *errorMsgBase);
<a name="l00770"></a>00770 <span class="comment"></span>
<a name="l00771"></a>00771 <span class="comment">/** Utility routine that emits code to initialize a symbol given an</span>
<a name="l00772"></a>00772 <span class="comment">    initializer expression.</span>
<a name="l00773"></a>00773 <span class="comment"></span>
<a name="l00774"></a>00774 <span class="comment">    @param lvalue    Memory location of storage for the symbol&#39;s data</span>
<a name="l00775"></a>00775 <span class="comment">    @param symName   Name of symbol (used in error messages)</span>
<a name="l00776"></a>00776 <span class="comment">    @param symType   Type of variable being initialized</span>
<a name="l00777"></a>00777 <span class="comment">    @param initExpr  Expression for the initializer</span>
<a name="l00778"></a>00778 <span class="comment">    @param ctx       FunctionEmitContext to use for generating instructions</span>
<a name="l00779"></a>00779 <span class="comment">    @param pos       Source file position of the variable being initialized</span>
<a name="l00780"></a>00780 <span class="comment">*/</span>
<a name="l00781"></a>00781 <span class="keywordtype">void</span>
<a name="l00782"></a>00782 <a class="code" href="expr_8h.html#a527118184f536ef9df67c74bc2fb5176">InitSymbol</a>(llvm::Value *lvalue, <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *symType, <a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *initExpr,
<a name="l00783"></a>00783            <a class="code" href="classFunctionEmitContext.html">FunctionEmitContext</a> *ctx, <a class="code" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> pos);
<a name="l00784"></a>00784 
<a name="l00785"></a>00785 <span class="keywordtype">bool</span> <a class="code" href="expr_8h.html#ae94c05cca3a65f90a54dac243c470446">PossiblyResolveFunctionOverloads</a>(<a class="code" href="classExpr.html" title="Expr is the abstract base class that defines the interface that all expression types must implement...">Expr</a> *expr, <span class="keyword">const</span> <a class="code" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *type);
<a name="l00786"></a>00786 
<a name="l00787"></a>00787 <span class="preprocessor">#endif // ISPC_EXPR_H</span>
</pre></div></div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 6 2012 16:03:13 for Intel SPMD Program Compiler by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
