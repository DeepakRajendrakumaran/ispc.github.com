<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Intel SPMD Program Compiler: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Todo List </h1>  </div>
</div>
<div class="contents">
<p><a class="anchor" id="_todo000003"></a> </p>
<dl>
<dt>Class <a class="el" href="classFunctionType.html">FunctionType</a>  </dt>
<dd>This class has a fair number of methods inherited from <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> that don't make sense here (e.g. IsUniformType(), GetBaseType(), LLVMType(), etc. Would be nice to refactor the inheritance hierarchy to move most of those interface methods to a sub-class of <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a>, which in turn all of the other <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> implementations inherit from. </dd>
</dl>
<p><a class="anchor" id="_todo000005"></a> </p>
<dl>
<dt>Member <a class="el" href="classFunctionType.html#a49c23ad1efed3c6b0e6d25e4905a026f">FunctionType::SetArgumentDefaults</a> (const std::vector&lt; ConstExpr * &gt; &amp;d) const  </dt>
<dd>It would be nice to pull this information together and pass it when the constructor is called; it's kind of ugly to set it like this later. </dd>
</dl>
<p><a class="anchor" id="_todo000010"></a> </p>
<dl>
<dt>Class <a class="el" href="classGatherScatterFlattenOpt.html">GatherScatterFlattenOpt</a>  </dt>
<dd>The implementation of this is pretty messy, and it sure would be nice to not have all the complexity of built-in assumptions of the structure of how the front end will have generated code, all of the instruction dyn_casts, etc. Can we do something simpler, e.g. an early pass to flatten out GEPs when the size is known, then do LLVM's constant folding, then flatten into an array, etc.? </dd>
</dl>
<p><a class="anchor" id="_todo000013"></a> </p>
<dl>
<dt>Class <a class="el" href="classGSImprovementsPass.html">GSImprovementsPass</a>  </dt>
<dd>Currently, this only looks for all program instances going to the same location and all going to a linear sequence of locations in memory. There are a number of other cases that might make sense to look for, including things that could be handled with a vector load + shuffle or things that could be handled with hybrids of e.g. 2 4-wide vector loads with AVX, etc. </dd>
</dl>
<p><a class="anchor" id="_todo000007"></a> </p>
<dl>
<dt>Class <a class="el" href="classIntrinsicsOpt.html">IntrinsicsOpt</a>  </dt>
<dd>The better thing to do would be to submit a patch to LLVM to get these; they're presumably pretty simple patterns to match. </dd>
</dl>
<p><a class="anchor" id="_todo000006"></a> </p>
<dl>
<dt>Member <a class="el" href="module_8cpp.html#a7ff434f7260de3cc9b6bf5b32dcfcb4b">lCheckForStructParameters</a> (const <a class="el" href="classFunctionType.html" title="Type representing a function (return type + argument types)">FunctionType</a> *ftype, <a class="el" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> pos) </dt>
<dd>Fix passing structs from C/C++ to ispc functions. </dd>
</dl>
<p><a class="anchor" id="_todo000008"></a> </p>
<dl>
<dt>Member <a class="el" href="opt_8cpp.html#aabbac44ab116503416aede9a33f1dd03">lGetMask</a> (llvm::Value *factor) </dt>
<dd>This will break if we ever do 32-wide compilation, in which case it don't be possible to distinguish between -1 for "don't know" and "known and all bits on". </dd>
</dl>
<p><a class="anchor" id="_todo000009"></a> </p>
<dl>
<dt>Member <a class="el" href="opt_8cpp.html#a22173061ee4fe22a8ed7f20e32b40ad8">lIsUndef</a> (llvm::Value *value) </dt>
<dd>Is it worth working harder to find more of these? It starts to get tricky, since having an undef operand doesn't necessarily mean that the result will be undefined. (And for that matter, is there an LLVM call that will do this for us?) </dd>
</dl>
<p><a class="anchor" id="_todo000012"></a> </p>
<dl>
<dt>Member <a class="el" href="opt_8cpp.html#a54409d017cb8bc7cf557285a738ce945">lSmearScalar</a> (llvm::Value *scalar, llvm::Instruction *insertBefore) </dt>
<dd>Using shufflevector to do this seems more idiomatic (and would be just a single instruction). Switch to that? </dd>
</dl>
<p><a class="anchor" id="_todo000011"></a> </p>
<dl>
<dt>Member <a class="el" href="opt_8cpp.html#a474ce319a134350cae719d1917e4b7c5">lTraverseInsertChain</a> (llvm::Value *ptrs, llvm::Value *offsets[ISPC_MAX_NVEC], LLVM_TYPE_CONST llvm::Type **scaleType, bool *leafIsVarying, llvm::Instruction *insertBefore) </dt>
<dd>All of the additional indexing magic for varying stuff should happen in the front end. </dd>
</dl>
<p><a class="anchor" id="_todo000014"></a> </p>
<dl>
<dt>Member <a class="el" href="opt_8cpp.html#afff0cc190757c3fa9b6cc085c5dd2419">lValuesAreEqual</a> (llvm::Value *v0, llvm::Value *v1, std::vector&lt; llvm::PHINode * &gt; &amp;seenPhi0, std::vector&lt; llvm::PHINode * &gt; &amp;seenPhi1) </dt>
<dd>This seems to catch all of the cases we currently need it for in practice, but it's be nice to make it a little more robust/general. In general, though, a little something called the halting problem means we won't get all of them. </dd>
</dl>
<p><a class="anchor" id="_todo000015"></a> </p>
<dl>
<dt>Member <a class="el" href="opt_8cpp.html#a9f7459259c878e75e2bf7a7862596ee8">lVectorIsLinear</a> (llvm::Value **v, int vectorLength, int stride, std::set&lt; llvm::PHINode * &gt; &amp;seenPhis) </dt>
<dd>FIXME Crazy thought: can we just build up expressions that subtract the constants [v[0], v[0]+stride, v[0]+2*stride, ...] from the given values, throw the LLVM optimizer at those, and then see if we get back an array of all zeros? </dd>
</dl>
<p><a class="anchor" id="_todo000002"></a> </p>
<dl>
<dt>Class <a class="el" href="classSOAArrayType.html">SOAArrayType</a>  </dt>
<dd>Native support for SOA stuff is still a work in progres... </dd>
</dl>
<p><a class="anchor" id="_todo000001"></a> </p>
<dl>
<dt>Class <a class="el" href="classSymbol.html">Symbol</a>  </dt>
<dd>Should we break function symbols into a separate FunctionSymbol class and then not have these members that are not applicable for function symbols (and vice versa, for non-function symbols)? </dd>
</dl>
<p><a class="anchor" id="_todo000004"></a> </p>
<dl>
<dt>Member <a class="el" href="classType.html#a078b7dc77c288701d13abaa57434da91">Type::MoreGeneralType</a> (const <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *type0, const <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> *type1, <a class="el" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> pos, const char *reason, bool forceVarying=false, int vecSize=0) </dt>
<dd>the vecSize and forceVarying parts of this should probably be factored out and done separately in the cases when needed.</dd>
</dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 20 2011 11:49:23 for Intel SPMD Program Compiler by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
