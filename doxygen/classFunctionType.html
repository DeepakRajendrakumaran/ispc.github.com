<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Intel SPMD Program Compiler: FunctionType Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Intel SPMD Program Compiler
   &#160;<span id="projectnumber">1.2.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">FunctionType Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="FunctionType" --><!-- doxytag: inherits="Type" -->
<p><a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> representing a function (return type + argument types)  
 <a href="classFunctionType.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="type_8h_source.html">type.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FunctionType:</div>
<div class="dyncontent">
<div class="center"><img src="classFunctionType__inherit__graph.png" border="0" usemap="#FunctionType_inherit__map" alt="Inheritance graph"/></div>
<map name="FunctionType_inherit__map" id="FunctionType_inherit__map">
<area shape="rect" id="node2" href="classType.html" title="Interface class that defines the type abstraction." alt="" coords="33,6,87,34"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for FunctionType:</div>
<div class="dyncontent">
<div class="center"><img src="classFunctionType__coll__graph.png" border="0" usemap="#FunctionType_coll__map" alt="Collaboration graph"/></div>
<map name="FunctionType_coll__map" id="FunctionType_coll__map">
<area shape="rect" id="node2" href="classType.html" title="Interface class that defines the type abstraction." alt="" coords="67,10,122,38"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classFunctionType-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a437497c41b32b75cdd839edd1b6fd062">FunctionType</a> (const <a class="el" href="classType.html">Type</a> *<a class="el" href="classFunctionType.html#a128c817f3a4cfdf64dbb679d7aa8e7bf">returnType</a>, const std::vector&lt; const <a class="el" href="classType.html">Type</a> * &gt; &amp;argTypes, <a class="el" href="structSourcePos.html">SourcePos</a> pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a9bfb4d1d1aa14a88cb3290bb2bb1496a">FunctionType</a> (const <a class="el" href="classType.html">Type</a> *<a class="el" href="classFunctionType.html#a128c817f3a4cfdf64dbb679d7aa8e7bf">returnType</a>, const std::vector&lt; const <a class="el" href="classType.html">Type</a> * &gt; &amp;argTypes, const std::vector&lt; std::string &gt; &amp;argNames, const std::vector&lt; <a class="el" href="classExpr.html">Expr</a> * &gt; &amp;argDefaults, const std::vector&lt; <a class="el" href="structSourcePos.html">SourcePos</a> &gt; &amp;argPos, bool <a class="el" href="classFunctionType.html#a32f0aa9227794002abea1952e6c9f347">isTask</a>, bool <a class="el" href="classFunctionType.html#ad9be8ddac0b12ed937557b231319052c">isExported</a>, bool <a class="el" href="classFunctionType.html#a82597ec6f94ce5517506e306953f7eb9">isExternC</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVariability.html">Variability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a7afbdc573cd8dfd6e87230cc15b13dbc">GetVariability</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a62671b908b8e98773d59dfa4b31e3862">IsBoolType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a03b05b6fb53707e4fb7d845416801f9c">IsFloatType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#ab13379247f598875f1ea850d7e02c471">IsIntType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a568bda9e9c775f80481d4f11c840d718">IsUnsignedType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a2e2f700616e939d2f22ebfde308f74f3">IsConstType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a0505addf60b72566c14f62cae3054e96">GetBaseType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a7b95328b75071c1bceab4059575eb70c">GetAsVaryingType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#afea1ec2e2e55becb419413e41d616733">GetAsUniformType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a6e3dfd294c860d9ab78ea1fb99e6ca86">GetAsUnboundVariabilityType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a62d1eed3bb75d4029f004290b866cf19">GetAsSOAType</a> (int width) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFunctionType.html">FunctionType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#ad1444a33e681caa1fa1ca56b3dd5dfea">ResolveUnboundVariability</a> (<a class="el" href="structVariability.html">Variability</a> v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#ae07545f58b603d22f4ddfb69d4787236">GetAsConstType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a0c03832895468cffeaebc272aa0f6ad2">GetAsNonConstType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a26fe1ec9fa3d939ccdf137ef18184afe">GetString</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a34f7649296f79dc80f636e2335e8c85c">Mangle</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a90688df9ff3674c4baa71a663bfd90b2">GetCDeclaration</a> (const std::string &amp;fname) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LLVM_TYPE_CONST llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a49b2b25b02edde4b8f9d3323b0c91485">LLVMType</a> (llvm::LLVMContext *ctx) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::DIType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a7df9a46d5c710977a8112358d11afd44">GetDIType</a> (llvm::DIDescriptor scope) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a45303f612d6eb85d73fb8cbd785330cf">GetReturnType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a6966c36fb0b5dfeee023bee7b458f870">GetReturnTypeString</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LLVM_TYPE_CONST <br class="typebreak"/>
llvm::FunctionType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a4e744bd352870ba4ebfb768fa357750f">LLVMFunctionType</a> (llvm::LLVMContext *ctx, bool includeMask=false) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#aa8626ccd2e745fce66214f69330d6437">GetNumParameters</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a144e797267311e897311b257421abf7f">GetParameterType</a> (int i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classExpr.html">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#ace8cef8f3a21e7e40560c1a69325eb47">GetParameterDefault</a> (int i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structSourcePos.html">SourcePos</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a81ab0e0a223db6730d1e2214bff8f900">GetParameterSourcePos</a> (int i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#adf5600047546512f13dbb7dd8d917248">GetParameterName</a> (int i) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a32f0aa9227794002abea1952e6c9f347">isTask</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#ad9be8ddac0b12ed937557b231319052c">isExported</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a82597ec6f94ce5517506e306953f7eb9">isExternC</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a4b3d1eb3cbf748d0c0837fbd4990d8bd">isSafe</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a06c86736884b68abdcf8151a5c2fd669">costOverride</a></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a128c817f3a4cfdf64dbb679d7aa8e7bf">returnType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::vector&lt; const <a class="el" href="classType.html">Type</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#acecace7c9b99363437672fec40dde61e">paramTypes</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a391be65a57258ed65d7d495fd68f4c19">paramNames</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classExpr.html">Expr</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a31f049bd756f444503cc4b8139716ab0">paramDefaults</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structSourcePos.html">SourcePos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionType.html#a6a5fb1fbb12940810d7f9ceeec1655a5">paramPositions</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> representing a function (return type + argument types) </p>
<p><a class="el" href="classFunctionType.html" title="Type representing a function (return type + argument types)">FunctionType</a> encapsulates the information related to a function's type, including the return type and the types of the arguments.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>This class has a fair number of methods inherited from <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> that don't make sense here (e.g. <a class="el" href="classType.html#a1b3756addee50a4a06b055c5795200ef">IsUniformType()</a>, <a class="el" href="classFunctionType.html#a0505addf60b72566c14f62cae3054e96">GetBaseType()</a>, <a class="el" href="classFunctionType.html#a49b2b25b02edde4b8f9d3323b0c91485">LLVMType()</a>, etc. Would be nice to refactor the inheritance hierarchy to move most of those interface methods to a sub-class of <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a>, which in turn all of the other <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> implementations inherit from. </dd></dl>

<p>Definition at line <a class="el" href="type_8h_source.html#l00741">741</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a437497c41b32b75cdd839edd1b6fd062"></a><!-- doxytag: member="FunctionType::FunctionType" ref="a437497c41b32b75cdd839edd1b6fd062" args="(const Type *returnType, const std::vector&lt; const Type * &gt; &amp;argTypes, SourcePos pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FunctionType::FunctionType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>returnType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classType.html">Type</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>argTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSourcePos.html">SourcePos</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02329">2329</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8h_source.html#l00812">costOverride</a>, <a class="el" href="type_8h_source.html#l00808">isSafe</a>, <a class="el" href="parse_8yy.html">NULL</a>, and <a class="el" href="type_8h_source.html#l00815">returnType</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l02429">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="a9bfb4d1d1aa14a88cb3290bb2bb1496a"></a><!-- doxytag: member="FunctionType::FunctionType" ref="a9bfb4d1d1aa14a88cb3290bb2bb1496a" args="(const Type *returnType, const std::vector&lt; const Type * &gt; &amp;argTypes, const std::vector&lt; std::string &gt; &amp;argNames, const std::vector&lt; Expr * &gt; &amp;argDefaults, const std::vector&lt; SourcePos &gt; &amp;argPos, bool isTask, bool isExported, bool isExternC)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FunctionType::FunctionType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>returnType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classType.html">Type</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>argTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>argNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classExpr.html">Expr</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>argDefaults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structSourcePos.html">SourcePos</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>argPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isExported</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isExternC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02341">2341</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8h_source.html#l00812">costOverride</a>, <a class="el" href="type_8h_source.html#l00808">isSafe</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="type_8h_source.html#l00823">paramDefaults</a>, <a class="el" href="type_8h_source.html#l00820">paramNames</a>, <a class="el" href="type_8h_source.html#l00828">paramPositions</a>, <a class="el" href="type_8h_source.html#l00819">paramTypes</a>, and <a class="el" href="type_8h_source.html#l00815">returnType</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae07545f58b603d22f4ddfb69d4787236"></a><!-- doxytag: member="FunctionType::GetAsConstType" ref="ae07545f58b603d22f4ddfb69d4787236" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionType::GetAsConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a const version of this type. If it's already const, then the old <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> pointer is returned. </p>

<p>Implements <a class="el" href="classType.html#a91db376e89247992a5975936c5054eaa">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02456">2456</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c03832895468cffeaebc272aa0f6ad2"></a><!-- doxytag: member="FunctionType::GetAsNonConstType" ref="a0c03832895468cffeaebc272aa0f6ad2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionType::GetAsNonConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a non-const version of this type. If it's already not const, then the old <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> pointer is returned. </p>

<p>Implements <a class="el" href="classType.html#ad97d28e97d0955f6b19bb24dbfcc22bf">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02462">2462</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a62d1eed3bb75d4029f004290b866cf19"></a><!-- doxytag: member="FunctionType::GetAsSOAType" ref="a62d1eed3bb75d4029f004290b866cf19" args="(int width) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionType::GetAsSOAType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classType.html#af3681d5c019998d033aec355d0157c54">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02422">2422</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="util_8h_source.html#l00113">FATAL</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="a6e3dfd294c860d9ab78ea1fb99e6ca86"></a><!-- doxytag: member="FunctionType::GetAsUnboundVariabilityType" ref="a6e3dfd294c860d9ab78ea1fb99e6ca86" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionType::GetAsUnboundVariabilityType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get an instance of the type with unbound variability. </p>

<p>Implements <a class="el" href="classType.html#a11499a547136ca713db16214f71ecbf2">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02415">2415</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="util_8h_source.html#l00113">FATAL</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="afea1ec2e2e55becb419413e41d616733"></a><!-- doxytag: member="FunctionType::GetAsUniformType" ref="afea1ec2e2e55becb419413e41d616733" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionType::GetAsUniformType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "uniform" instance of this type. If the type is already uniform, its "this" pointer will be returned. </p>

<p>Implements <a class="el" href="classType.html#ab0eff8692794d3437a91404c98985d20">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02408">2408</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="util_8h_source.html#l00113">FATAL</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="a7b95328b75071c1bceab4059575eb70c"></a><!-- doxytag: member="FunctionType::GetAsVaryingType" ref="a7b95328b75071c1bceab4059575eb70c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionType::GetAsVaryingType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "varying" instance of this type. If the type is already varying, its "this" pointer will be returned. </p>

<p>Implements <a class="el" href="classType.html#aedfa3c719db7ab073c5e1f75b4041e55">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02401">2401</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="util_8h_source.html#l00113">FATAL</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="a0505addf60b72566c14f62cae3054e96"></a><!-- doxytag: member="FunctionType::GetBaseType" ref="a0505addf60b72566c14f62cae3054e96" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionType::GetBaseType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the basic root type of the given type. For example, for an array or short-vector, this returns the element type. For a struct or atomic type, it returns itself. </p>

<p>Implements <a class="el" href="classType.html#a51af28faf17eb05982547d9b340429eb">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02394">2394</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="util_8h_source.html#l00113">FATAL</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="a90688df9ff3674c4baa71a663bfd90b2"></a><!-- doxytag: member="FunctionType::GetCDeclaration" ref="a90688df9ff3674c4baa71a663bfd90b2" args="(const std::string &amp;fname) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string FunctionType::GetCDeclaration </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a string that is the declaration of the same type in C syntax. </p>

<p>Implements <a class="el" href="classType.html#a7e35141766bbc63333953263cd85d883">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02499">2499</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l00900">PointerType::GetBaseType()</a>, <a class="el" href="classType.html#a7e35141766bbc63333953263cd85d883">Type::GetCDeclaration()</a>, <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">Type::GetString()</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="type_8h_source.html#l00820">paramNames</a>, <a class="el" href="type_8h_source.html#l00819">paramTypes</a>, and <a class="el" href="type_8h_source.html#l00815">returnType</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l01021">lPrintFunctionDeclarations()</a>.</p>

</div>
</div>
<a class="anchor" id="a7df9a46d5c710977a8112358d11afd44"></a><!-- doxytag: member="FunctionType::GetDIType" ref="a7df9a46d5c710977a8112358d11afd44" args="(llvm::DIDescriptor scope) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::DIType FunctionType::GetDIType </td>
          <td>(</td>
          <td class="paramtype">llvm::DIDescriptor&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the DIType (LLVM's debugging information structure), corresponding to this type. </p>

<p>Implements <a class="el" href="classType.html#a8b6ded269378020c769915bbbff3d73c">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02537">2537</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="util_8h_source.html#l00113">FATAL</a>.</p>

</div>
</div>
<a class="anchor" id="aa8626ccd2e745fce66214f69330d6437"></a><!-- doxytag: member="FunctionType::GetNumParameters" ref="aa8626ccd2e745fce66214f69330d6437" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FunctionType::GetNumParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8h_source.html#l00788">788</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00819">paramTypes</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00470">Module::AddFunctionDeclaration()</a>, <a class="el" href="expr_8cpp_source.html#l07593">FunctionSymbolExpr::getCandidateFunctions()</a>, <a class="el" href="expr_8cpp_source.html#l03294">FunctionCallExpr::GetValue()</a>, <a class="el" href="ctx_8cpp_source.html#l03047">lCalleeArgCount()</a>, <a class="el" href="module_8cpp_source.html#l00450">lCheckForStructParameters()</a>, <a class="el" href="type_8cpp_source.html#l02870">lCheckTypeEquality()</a>, <a class="el" href="module_8cpp_source.html#l01002">lGetExportedParamTypes()</a>, <a class="el" href="expr_8cpp_source.html#l00592">PossiblyResolveFunctionOverloads()</a>, <a class="el" href="expr_8cpp_source.html#l02760">AssignExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l03420">FunctionCallExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="ace8cef8f3a21e7e40560c1a69325eb47"></a><!-- doxytag: member="FunctionType::GetParameterDefault" ref="ace8cef8f3a21e7e40560c1a69325eb47" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classExpr.html">Expr</a> * FunctionType::GetParameterDefault </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02628">2628</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, and <a class="el" href="type_8h_source.html#l00823">paramDefaults</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00470">Module::AddFunctionDeclaration()</a>, <a class="el" href="expr_8cpp_source.html#l07593">FunctionSymbolExpr::getCandidateFunctions()</a>, <a class="el" href="expr_8cpp_source.html#l03294">FunctionCallExpr::GetValue()</a>, and <a class="el" href="expr_8cpp_source.html#l03420">FunctionCallExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="adf5600047546512f13dbb7dd8d917248"></a><!-- doxytag: member="FunctionType::GetParameterName" ref="adf5600047546512f13dbb7dd8d917248" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; FunctionType::GetParameterName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02642">2642</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, and <a class="el" href="type_8h_source.html#l00820">paramNames</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00470">Module::AddFunctionDeclaration()</a>.</p>

</div>
</div>
<a class="anchor" id="a81ab0e0a223db6730d1e2214bff8f900"></a><!-- doxytag: member="FunctionType::GetParameterSourcePos" ref="a81ab0e0a223db6730d1e2214bff8f900" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structSourcePos.html">SourcePos</a> &amp; FunctionType::GetParameterSourcePos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02635">2635</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, and <a class="el" href="type_8h_source.html#l00828">paramPositions</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00470">Module::AddFunctionDeclaration()</a>.</p>

</div>
</div>
<a class="anchor" id="a144e797267311e897311b257421abf7f"></a><!-- doxytag: member="FunctionType::GetParameterType" ref="a144e797267311e897311b257421abf7f" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * FunctionType::GetParameterType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02621">2621</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, and <a class="el" href="type_8h_source.html#l00819">paramTypes</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00470">Module::AddFunctionDeclaration()</a>, <a class="el" href="expr_8cpp_source.html#l07637">FunctionSymbolExpr::computeOverloadCost()</a>, <a class="el" href="expr_8cpp_source.html#l03294">FunctionCallExpr::GetValue()</a>, <a class="el" href="module_8cpp_source.html#l00450">lCheckForStructParameters()</a>, <a class="el" href="type_8cpp_source.html#l02870">lCheckTypeEquality()</a>, <a class="el" href="module_8cpp_source.html#l01002">lGetExportedParamTypes()</a>, <a class="el" href="expr_8cpp_source.html#l00592">PossiblyResolveFunctionOverloads()</a>, <a class="el" href="expr_8cpp_source.html#l02760">AssignExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l03420">FunctionCallExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a45303f612d6eb85d73fb8cbd785330cf"></a><!-- doxytag: member="FunctionType::GetReturnType" ref="a45303f612d6eb85d73fb8cbd785330cf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a>* FunctionType::GetReturnType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8h_source.html#l00777">777</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00815">returnType</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00470">Module::AddFunctionDeclaration()</a>, <a class="el" href="ctx_8cpp_source.html#l03068">FunctionEmitContext::CallInst()</a>, <a class="el" href="expr_8cpp_source.html#l03405">FunctionCallExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03294">FunctionCallExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l02870">lCheckTypeEquality()</a>, <a class="el" href="module_8cpp_source.html#l01002">lGetExportedParamTypes()</a>, and <a class="el" href="expr_8cpp_source.html#l03420">FunctionCallExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a6966c36fb0b5dfeee023bee7b458f870"></a><!-- doxytag: member="FunctionType::GetReturnTypeString" ref="a6966c36fb0b5dfeee023bee7b458f870" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string FunctionType::GetReturnTypeString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02545">2545</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00812">costOverride</a>, <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">Type::GetString()</a>, <a class="el" href="type_8h_source.html#l00800">isExported</a>, <a class="el" href="type_8h_source.html#l00804">isExternC</a>, <a class="el" href="type_8h_source.html#l00808">isSafe</a>, <a class="el" href="type_8h_source.html#l00796">isTask</a>, <a class="el" href="parse_8yy.html">NULL</a>, and <a class="el" href="type_8h_source.html#l00815">returnType</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00470">Module::AddFunctionDeclaration()</a>, and <a class="el" href="type_8cpp_source.html#l02468">GetString()</a>.</p>

</div>
</div>
<a class="anchor" id="a26fe1ec9fa3d939ccdf137ef18184afe"></a><!-- doxytag: member="FunctionType::GetString" ref="a26fe1ec9fa3d939ccdf137ef18184afe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string FunctionType::GetString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a text representation of the type (for example, for use in warning and error messages). </p>

<p>Implements <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02468">2468</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l02545">GetReturnTypeString()</a>, <a class="el" href="parse_8yy.html">NULL</a>, and <a class="el" href="type_8h_source.html#l00819">paramTypes</a>.</p>

<p>Referenced by <a class="el" href="builtins_8cpp_source.html#l00159">lCreateSymbol()</a>.</p>

</div>
</div>
<a class="anchor" id="a7afbdc573cd8dfd6e87230cc15b13dbc"></a><!-- doxytag: member="FunctionType::GetVariability" ref="a7afbdc573cd8dfd6e87230cc15b13dbc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVariability.html">Variability</a> FunctionType::GetVariability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the variability of the type. </p>

<p>Implements <a class="el" href="classType.html#a619effc9d2d2517bd884076eb9559b65">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02358">2358</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00053">Variability::Uniform</a>.</p>

</div>
</div>
<a class="anchor" id="a62671b908b8e98773d59dfa4b31e3862"></a><!-- doxytag: member="FunctionType::IsBoolType" ref="a62671b908b8e98773d59dfa4b31e3862" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FunctionType::IsBoolType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is boolean. In other words, this is true for individual bools and for short-vectors with underlying bool type, but not for arrays of bools. </p>

<p>Implements <a class="el" href="classType.html#a38ff6178597171c11f6e24566b251dea">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02376">2376</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e2f700616e939d2f22ebfde308f74f3"></a><!-- doxytag: member="FunctionType::IsConstType" ref="a2e2f700616e939d2f22ebfde308f74f3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FunctionType::IsConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if this type is 'const'-qualified. </p>

<p>Implements <a class="el" href="classType.html#a9a6d77fb89abc534e2ee1726cc13cf05">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02388">2388</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03b05b6fb53707e4fb7d845416801f9c"></a><!-- doxytag: member="FunctionType::IsFloatType" ref="a03b05b6fb53707e4fb7d845416801f9c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FunctionType::IsFloatType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is float or double. In other words, this is true for individual floats/doubles and for short-vectors of them, but not for arrays of them. </p>

<p>Implements <a class="el" href="classType.html#aeee9fe8b11fc75a300cf37f8b5c9f034">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02364">2364</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab13379247f598875f1ea850d7e02c471"></a><!-- doxytag: member="FunctionType::IsIntType" ref="ab13379247f598875f1ea850d7e02c471" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FunctionType::IsIntType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is an integer type. In other words, this is true for individual integers and for short-vectors of integer types, but not for arrays of integer types. </p>

<p>Implements <a class="el" href="classType.html#a3b2b570093e27170d582b67211dd6836">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02370">2370</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a568bda9e9c775f80481d4f11c840d718"></a><!-- doxytag: member="FunctionType::IsUnsignedType" ref="a568bda9e9c775f80481d4f11c840d718" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FunctionType::IsUnsignedType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is unsigned. In other words, this is true for unsigned integers and short vectors of unsigned integer types. </p>

<p>Implements <a class="el" href="classType.html#a9fb5648ec4eb5b432723cf0b3332f8d0">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02382">2382</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4e744bd352870ba4ebfb768fa357750f"></a><!-- doxytag: member="FunctionType::LLVMFunctionType" ref="a4e744bd352870ba4ebfb768fa357750f" args="(llvm::LLVMContext *ctx, bool includeMask=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_TYPE_CONST llvm::FunctionType * FunctionType::LLVMFunctionType </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeMask</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns the LLVM <a class="el" href="classFunctionType.html" title="Type representing a function (return type + argument types)">FunctionType</a> that corresponds to this function type. The <code>includeMask</code> parameter indicates whether the llvm::FunctionType should have a mask as the last argument in its function signature. </p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02568">2568</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="ispc_8h_source.html#l00424">Globals::ctx</a>, <a class="el" href="type_8cpp_source.html#l02977">Type::Equal()</a>, <a class="el" href="module_8h_source.html#l00129">Module::errorCount</a>, <a class="el" href="ispc_8cpp_source.html#l00067">g</a>, <a class="el" href="llvmutil_8h_source.html#l00071">LLVMTypes::Int32Type</a>, <a class="el" href="type_8h_source.html#l00796">isTask</a>, <a class="el" href="ispc_8h_source.html#l00099">LLVM_TYPE_CONST</a>, <a class="el" href="classType.html#aa7b08bf258938faa7e12b580b623621a">Type::LLVMType()</a>, <a class="el" href="ispc_8cpp_source.html#l00068">m</a>, <a class="el" href="llvmutil_8h_source.html#l00083">LLVMTypes::MaskType</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="type_8h_source.html#l00819">paramTypes</a>, and <a class="el" href="type_8h_source.html#l00815">returnType</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00470">Module::AddFunctionDeclaration()</a>, <a class="el" href="ctx_8cpp_source.html#l03068">FunctionEmitContext::CallInst()</a>, and <a class="el" href="type_8cpp_source.html#l01107">PointerType::LLVMType()</a>.</p>

</div>
</div>
<a class="anchor" id="a49b2b25b02edde4b8f9d3323b0c91485"></a><!-- doxytag: member="FunctionType::LLVMType" ref="a49b2b25b02edde4b8f9d3323b0c91485" args="(llvm::LLVMContext *ctx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_TYPE_CONST llvm::Type * FunctionType::LLVMType </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the LLVM type corresponding to this ispc type </p>

<p>Implements <a class="el" href="classType.html#aa7b08bf258938faa7e12b580b623621a">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02530">2530</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="util_8h_source.html#l00113">FATAL</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="a34f7649296f79dc80f636e2335e8c85c"></a><!-- doxytag: member="FunctionType::Mangle" ref="a34f7649296f79dc80f636e2335e8c85c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string FunctionType::Mangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a string that represents the mangled type (for use in mangling function symbol names for function overloading). The various Types implementations of this method should collectively ensure that all of them use mangling schemes that are guaranteed not to clash. </p>

<p>Implements <a class="el" href="classType.html#a7bd23bd909d493d271dbe1024d212c06">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02486">2486</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="module_8h_source.html#l00129">Module::errorCount</a>, <a class="el" href="ispc_8cpp_source.html#l00068">m</a>, <a class="el" href="parse_8yy.html">NULL</a>, and <a class="el" href="type_8h_source.html#l00819">paramTypes</a>.</p>

</div>
</div>
<a class="anchor" id="ad1444a33e681caa1fa1ca56b3dd5dfea"></a><!-- doxytag: member="FunctionType::ResolveUnboundVariability" ref="ad1444a33e681caa1fa1ca56b3dd5dfea" args="(Variability v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFunctionType.html">FunctionType</a> * FunctionType::ResolveUnboundVariability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVariability.html">Variability</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classType.html#adced497622fac125548ef5531495c738">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02429">2429</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8h_source.html#l00812">costOverride</a>, <a class="el" href="module_8h_source.html#l00129">Module::errorCount</a>, <a class="el" href="type_8cpp_source.html#l02329">FunctionType()</a>, <a class="el" href="type_8h_source.html#l00800">isExported</a>, <a class="el" href="type_8h_source.html#l00804">isExternC</a>, <a class="el" href="type_8h_source.html#l00808">isSafe</a>, <a class="el" href="type_8h_source.html#l00796">isTask</a>, <a class="el" href="ispc_8cpp_source.html#l00068">m</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="type_8h_source.html#l00823">paramDefaults</a>, <a class="el" href="type_8h_source.html#l00820">paramNames</a>, <a class="el" href="type_8h_source.html#l00828">paramPositions</a>, <a class="el" href="type_8h_source.html#l00819">paramTypes</a>, <a class="el" href="classType.html#adced497622fac125548ef5531495c738">Type::ResolveUnboundVariability()</a>, and <a class="el" href="type_8h_source.html#l00815">returnType</a>.</p>

<p>Referenced by <a class="el" href="decl_8cpp_source.html#l00346">Declarator::GetType()</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a06c86736884b68abdcf8151a5c2fd669"></a><!-- doxytag: member="FunctionType::costOverride" ref="a06c86736884b68abdcf8151a5c2fd669" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classFunctionType.html#a06c86736884b68abdcf8151a5c2fd669">FunctionType::costOverride</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If non-negative, this provides a user-supplied override to the cost function estimate for the function. </p>

<p>Definition at line <a class="el" href="type_8h_source.html#l00812">812</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l03558">FunctionCallExpr::EstimateCost()</a>, <a class="el" href="type_8cpp_source.html#l02329">FunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02545">GetReturnTypeString()</a>, and <a class="el" href="type_8cpp_source.html#l02429">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="ad9be8ddac0b12ed937557b231319052c"></a><!-- doxytag: member="FunctionType::isExported" ref="ad9be8ddac0b12ed937557b231319052c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classFunctionType.html#ad9be8ddac0b12ed937557b231319052c">FunctionType::isExported</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This value is true if the function had a 'export' qualifier in the source program. </p>

<p>Definition at line <a class="el" href="type_8h_source.html#l00800">800</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00470">Module::AddFunctionDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02545">GetReturnTypeString()</a>, <a class="el" href="type_8cpp_source.html#l02870">lCheckTypeEquality()</a>, <a class="el" href="module_8cpp_source.html#l01034">lIsExported()</a>, and <a class="el" href="type_8cpp_source.html#l02429">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="a82597ec6f94ce5517506e306953f7eb9"></a><!-- doxytag: member="FunctionType::isExternC" ref="a82597ec6f94ce5517506e306953f7eb9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classFunctionType.html#a82597ec6f94ce5517506e306953f7eb9">FunctionType::isExternC</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This value is true if the function was declared as an 'extern "C"' function in the source program. </p>

<p>Definition at line <a class="el" href="type_8h_source.html#l00804">804</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00470">Module::AddFunctionDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02545">GetReturnTypeString()</a>, <a class="el" href="type_8cpp_source.html#l02870">lCheckTypeEquality()</a>, <a class="el" href="module_8cpp_source.html#l01042">lIsExternC()</a>, and <a class="el" href="type_8cpp_source.html#l02429">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b3d1eb3cbf748d0c0837fbd4990d8bd"></a><!-- doxytag: member="FunctionType::isSafe" ref="a4b3d1eb3cbf748d0c0837fbd4990d8bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFunctionType.html#a4b3d1eb3cbf748d0c0837fbd4990d8bd">FunctionType::isSafe</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicates whether this function has been declared to be safe to run with an all-off mask. </p>

<p>Definition at line <a class="el" href="type_8h_source.html#l00808">808</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l02329">FunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02545">GetReturnTypeString()</a>, and <a class="el" href="type_8cpp_source.html#l02429">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="a32f0aa9227794002abea1952e6c9f347"></a><!-- doxytag: member="FunctionType::isTask" ref="a32f0aa9227794002abea1952e6c9f347" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classFunctionType.html#a32f0aa9227794002abea1952e6c9f347">FunctionType::isTask</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This value is true if the function had a 'task' qualifier in the source program. </p>

<p>Definition at line <a class="el" href="type_8h_source.html#l00796">796</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00470">Module::AddFunctionDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02545">GetReturnTypeString()</a>, <a class="el" href="expr_8cpp_source.html#l03294">FunctionCallExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l02870">lCheckTypeEquality()</a>, <a class="el" href="type_8cpp_source.html#l02568">LLVMFunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02429">ResolveUnboundVariability()</a>, and <a class="el" href="expr_8cpp_source.html#l03420">FunctionCallExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a31f049bd756f444503cc4b8139716ab0"></a><!-- doxytag: member="FunctionType::paramDefaults" ref="a31f049bd756f444503cc4b8139716ab0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classExpr.html">Expr</a> *&gt; <a class="el" href="classFunctionType.html#a31f049bd756f444503cc4b8139716ab0">FunctionType::paramDefaults</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default values of the function's arguments. For arguments without default values provided, NULL is stored. </p>

<p>Definition at line <a class="el" href="type_8h_source.html#l00823">823</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l02341">FunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02628">GetParameterDefault()</a>, and <a class="el" href="type_8cpp_source.html#l02429">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="a391be65a57258ed65d7d495fd68f4c19"></a><!-- doxytag: member="FunctionType::paramNames" ref="a391be65a57258ed65d7d495fd68f4c19" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt; <a class="el" href="classFunctionType.html#a391be65a57258ed65d7d495fd68f4c19">FunctionType::paramNames</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8h_source.html#l00820">820</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l02341">FunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02499">GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l02642">GetParameterName()</a>, and <a class="el" href="type_8cpp_source.html#l02429">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="a6a5fb1fbb12940810d7f9ceeec1655a5"></a><!-- doxytag: member="FunctionType::paramPositions" ref="a6a5fb1fbb12940810d7f9ceeec1655a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structSourcePos.html">SourcePos</a>&gt; <a class="el" href="classFunctionType.html#a6a5fb1fbb12940810d7f9ceeec1655a5">FunctionType::paramPositions</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The names provided (if any) with the function arguments in the function's signature. These should only be used for error messages and the like and so not affect testing function types for equality, etc. </p>

<p>Definition at line <a class="el" href="type_8h_source.html#l00828">828</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l02341">FunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02635">GetParameterSourcePos()</a>, and <a class="el" href="type_8cpp_source.html#l02429">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="acecace7c9b99363437672fec40dde61e"></a><!-- doxytag: member="FunctionType::paramTypes" ref="acecace7c9b99363437672fec40dde61e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;const <a class="el" href="classType.html">Type</a> *&gt; <a class="el" href="classFunctionType.html#acecace7c9b99363437672fec40dde61e">FunctionType::paramTypes</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8h_source.html#l00819">819</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l02341">FunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02499">GetCDeclaration()</a>, <a class="el" href="type_8h_source.html#l00788">GetNumParameters()</a>, <a class="el" href="type_8cpp_source.html#l02621">GetParameterType()</a>, <a class="el" href="type_8cpp_source.html#l02468">GetString()</a>, <a class="el" href="type_8cpp_source.html#l02568">LLVMFunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02486">Mangle()</a>, and <a class="el" href="type_8cpp_source.html#l02429">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="a128c817f3a4cfdf64dbb679d7aa8e7bf"></a><!-- doxytag: member="FunctionType::returnType" ref="a128c817f3a4cfdf64dbb679d7aa8e7bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a>* const <a class="el" href="classFunctionType.html#a128c817f3a4cfdf64dbb679d7aa8e7bf">FunctionType::returnType</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8h_source.html#l00815">815</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l02329">FunctionType()</a>, <a class="el" href="type_8cpp_source.html#l02499">GetCDeclaration()</a>, <a class="el" href="type_8h_source.html#l00777">GetReturnType()</a>, <a class="el" href="type_8cpp_source.html#l02545">GetReturnTypeString()</a>, <a class="el" href="type_8cpp_source.html#l02568">LLVMFunctionType()</a>, and <a class="el" href="type_8cpp_source.html#l02429">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="type_8h_source.html">type.h</a></li>
<li><a class="el" href="type_8cpp_source.html">type.cpp</a></li>
</ul>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 6 2012 16:03:15 for Intel SPMD Program Compiler by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
