<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Intel SPMD Program Compiler: PointerType Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Intel SPMD Program Compiler
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">PointerType Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="PointerType" --><!-- doxytag: inherits="Type" -->
<p><a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> implementation for pointers to other types.  
 <a href="classPointerType.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="type_8h_source.html">type.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PointerType:</div>
<div class="dyncontent">
<div class="center"><img src="classPointerType__inherit__graph.png" border="0" usemap="#PointerType_inherit__map" alt="Inheritance graph"/></div>
<map name="PointerType_inherit__map" id="PointerType_inherit__map">
<area shape="rect" id="node2" href="classType.html" title="Interface class that defines the type abstraction." alt="" coords="27,6,81,34"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for PointerType:</div>
<div class="dyncontent">
<div class="center"><img src="classPointerType__coll__graph.png" border="0" usemap="#PointerType_coll__map" alt="Collaboration graph"/></div>
<map name="PointerType_coll__map" id="PointerType_coll__map">
<area shape="rect" id="node2" href="classType.html" title="Interface class that defines the type abstraction." alt="" coords="5,99,59,127"/><area shape="rect" id="node4" href="structVariability.html" title="Variability" alt="" coords="109,99,200,127"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classPointerType-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a6e58f990b77bd957a8e0a2686ba76eba">PointerType</a> (const <a class="el" href="classType.html">Type</a> *t, <a class="el" href="structVariability.html">Variability</a> v, bool <a class="el" href="classPointerType.html#abbebbe566a8a9fc153475b0703745370">isConst</a>, bool <a class="el" href="classPointerType.html#ad8b781e7a07657061c89bd4ce379b8fe">isSlice</a>=false, bool frozen=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVariability.html">Variability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a826c51a29d9cfe08a22e6da82b43c444">GetVariability</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a38f010c5c6cb10c38cd53276116941ed">IsBoolType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a7c71a9791f34eacbddd8cc63aa47b373">IsFloatType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a63a9131bb41c41fb59b85caa9c5c55a3">IsIntType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a18c57097dfe42d3d1fe48d3068aa8841">IsUnsignedType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#ad5538a7e66b983ff3fcd1dd46905c1e7">IsConstType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#ae65fd322812acd28a23861538b8af167">IsSlice</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a129f257ee3ac4f1f241352ebe9d5bb30">IsFrozenSlice</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPointerType.html">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a4d9c12c5c726a8b95dda28a63b9229a8">GetAsSlice</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPointerType.html">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a30ee7c64e660cd6c9b644657b820d1ca">GetAsNonSlice</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPointerType.html">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a3439c84f95e5fdd3e3c3326980f83081">GetAsFrozenSlice</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classStructType.html">StructType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a189a3258f27d1f4fe47a2462995f992c">GetSliceStructType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a19d9c35984226e4ae0f003495854ab87">GetBaseType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPointerType.html">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#aa345be1efa7f75311e8015c08f62f5ff">GetAsVaryingType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPointerType.html">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#ab9f4094ef75613738d00d7a8485814b8">GetAsUniformType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPointerType.html">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a0ef290d3d666f58702f9c6d439dff452">GetAsUnboundVariabilityType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPointerType.html">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a8770971beb8b73800db6a96c8a424475">GetAsSOAType</a> (int width) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPointerType.html">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#aff7e397d4e26a3a5be4fd128389adf76">ResolveUnboundVariability</a> (<a class="el" href="structVariability.html">Variability</a> v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPointerType.html">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a070923f7fbad756358f0f08c3cfcbfd0">GetAsConstType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPointerType.html">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a23c65109649c864f5d85f814152160a1">GetAsNonConstType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#aa2aaad7775c48f38cdc61e95d6219285">GetString</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a5d5b123de5c1e412f11ef04eab996f38">Mangle</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a24b0e77c362d3a2590a11646c4fb06da">GetCDeclaration</a> (const std::string &amp;name) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LLVM_TYPE_CONST llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a9fc3f6f75d4a2a3f496af6ea5a551bf1">LLVMType</a> (llvm::LLVMContext *ctx) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::DIType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#ae8b02a8425138f3916ac97303cd1ed37">GetDIType</a> (llvm::DIDescriptor scope) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classPointerType.html">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#ac83e04fe88c4786b11c35006dba19e40">GetUniform</a> (const <a class="el" href="classType.html">Type</a> *t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classPointerType.html">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#ab00136b4bcf8302ca9fddce6cc4dbab0">GetVarying</a> (const <a class="el" href="classType.html">Type</a> *t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#aee095e680938be20bcbf9f579ad6ae6f">IsVoidPointer</a> (const <a class="el" href="classType.html">Type</a> *t)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classPointerType.html">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a647bcf895b01b89eba466a96fb9e87ad">Void</a></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structVariability.html">Variability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#aa9f936750e12b4d135c2d0df0c84a126">variability</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#abbebbe566a8a9fc153475b0703745370">isConst</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#ad8b781e7a07657061c89bd4ce379b8fe">isSlice</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#a2a9b2bd50245b39978b91aba6955f05e">isFrozen</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPointerType.html#ab350edb59139edbf35764721f44f8984">baseType</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> implementation for pointers to other types. </p>
<p>Pointers can have two additional properties beyond their variability and the type of object that they are pointing to. Both of these properties are used for internal bookkeeping and aren't directly accessible from the language.</p>
<ul>
<li>Slice: pointers that point to data with SOA layout have this property--it indicates that the pointer has two components, where the first (major) component is a regular pointer that points to an instance of the soa&lt;&gt; type being indexed, and where the second (minor) component is an integer that indicates which of the soa slices in that instance the pointer points to.</li>
</ul>
<ul>
<li>Frozen: only slice pointers may have this property--it indicates that any further indexing calculations should only be applied to the major pointer, and the value of the minor offset should be left unchanged. Pointers to lvalues from structure member access have the frozen property; see discussion in comments in the <a class="el" href="classStructMemberExpr.html">StructMemberExpr</a> class. </li>
</ul>

<p>Definition at line <a class="el" href="type_8h_source.html#l00386">386</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6e58f990b77bd957a8e0a2686ba76eba"></a><!-- doxytag: member="PointerType::PointerType" ref="a6e58f990b77bd957a8e0a2686ba76eba" args="(const Type *t, Variability v, bool isConst, bool isSlice=false, bool frozen=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PointerType::PointerType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVariability.html">Variability</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isConst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSlice</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>frozen</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00837">837</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00437">baseType</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01023">GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l00962">GetAsFrozenSlice()</a>, <a class="el" href="type_8cpp_source.html#l01032">GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l00954">GetAsNonSlice()</a>, <a class="el" href="type_8cpp_source.html#l00946">GetAsSlice()</a>, <a class="el" href="type_8cpp_source.html#l00936">GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l00926">GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l00916">GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l00906">GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l00845">GetUniform()</a>, <a class="el" href="type_8cpp_source.html#l00851">GetVarying()</a>, and <a class="el" href="type_8cpp_source.html#l01006">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a070923f7fbad756358f0f08c3cfcbfd0"></a><!-- doxytag: member="PointerType::GetAsConstType" ref="a070923f7fbad756358f0f08c3cfcbfd0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPointerType.html">PointerType</a> * PointerType::GetAsConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a const version of this type. If it's already const, then the old <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> pointer is returned. </p>

<p>Implements <a class="el" href="classType.html#a91db376e89247992a5975936c5054eaa">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01023">1023</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00437">baseType</a>, <a class="el" href="type_8h_source.html#l00435">isConst</a>, <a class="el" href="type_8h_source.html#l00436">isSlice</a>, <a class="el" href="type_8cpp_source.html#l00837">PointerType()</a>, and <a class="el" href="type_8h_source.html#l00434">variability</a>.</p>

</div>
</div>
<a class="anchor" id="a3439c84f95e5fdd3e3c3326980f83081"></a><!-- doxytag: member="PointerType::GetAsFrozenSlice" ref="a3439c84f95e5fdd3e3c3326980f83081" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPointerType.html">PointerType</a> * PointerType::GetAsFrozenSlice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00962">962</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00437">baseType</a>, <a class="el" href="type_8h_source.html#l00435">isConst</a>, <a class="el" href="type_8h_source.html#l00436">isFrozen</a>, <a class="el" href="type_8cpp_source.html#l00837">PointerType()</a>, and <a class="el" href="type_8h_source.html#l00434">variability</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l04324">StructMemberExpr::GetLValueType()</a>, and <a class="el" href="expr_8cpp_source.html#l04492">VectorMemberExpr::GetLValueType()</a>.</p>

</div>
</div>
<a class="anchor" id="a23c65109649c864f5d85f814152160a1"></a><!-- doxytag: member="PointerType::GetAsNonConstType" ref="a23c65109649c864f5d85f814152160a1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPointerType.html">PointerType</a> * PointerType::GetAsNonConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a non-const version of this type. If it's already not const, then the old <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> pointer is returned. </p>

<p>Implements <a class="el" href="classType.html#ad97d28e97d0955f6b19bb24dbfcc22bf">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01032">1032</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00437">baseType</a>, <a class="el" href="type_8h_source.html#l00435">isConst</a>, <a class="el" href="type_8h_source.html#l00436">isSlice</a>, <a class="el" href="type_8cpp_source.html#l00837">PointerType()</a>, and <a class="el" href="type_8h_source.html#l00434">variability</a>.</p>

</div>
</div>
<a class="anchor" id="a30ee7c64e660cd6c9b644657b820d1ca"></a><!-- doxytag: member="PointerType::GetAsNonSlice" ref="a30ee7c64e660cd6c9b644657b820d1ca" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPointerType.html">PointerType</a> * PointerType::GetAsNonSlice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00954">954</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00437">baseType</a>, <a class="el" href="type_8h_source.html#l00435">isConst</a>, <a class="el" href="type_8h_source.html#l00436">isSlice</a>, <a class="el" href="type_8cpp_source.html#l00837">PointerType()</a>, and <a class="el" href="type_8h_source.html#l00434">variability</a>.</p>

<p>Referenced by <a class="el" href="ctx_8cpp_source.html#l02014">FunctionEmitContext::GetElementPtrInst()</a>, <a class="el" href="type_8cpp_source.html#l00975">GetSliceStructType()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, and <a class="el" href="expr_8cpp_source.html#l01358">lEmitBinaryPointerArith()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d9c12c5c726a8b95dda28a63b9229a8"></a><!-- doxytag: member="PointerType::GetAsSlice" ref="a4d9c12c5c726a8b95dda28a63b9229a8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPointerType.html">PointerType</a> * PointerType::GetAsSlice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00946">946</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00437">baseType</a>, <a class="el" href="type_8h_source.html#l00435">isConst</a>, <a class="el" href="type_8h_source.html#l00436">isSlice</a>, <a class="el" href="type_8cpp_source.html#l00837">PointerType()</a>, and <a class="el" href="type_8h_source.html#l00434">variability</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l04084">IndexExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l03996">lConvertPtrToSliceIfNeeded()</a>, and <a class="el" href="ctx_8cpp_source.html#l02716">FunctionEmitContext::scatter()</a>.</p>

</div>
</div>
<a class="anchor" id="a8770971beb8b73800db6a96c8a424475"></a><!-- doxytag: member="PointerType::GetAsSOAType" ref="a8770971beb8b73800db6a96c8a424475" args="(int width) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPointerType.html">PointerType</a> * PointerType::GetAsSOAType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classType.html#af3681d5c019998d033aec355d0157c54">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00936">936</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00437">baseType</a>, <a class="el" href="type_8h_source.html#l00127">Type::GetSOAWidth()</a>, <a class="el" href="type_8h_source.html#l00435">isConst</a>, <a class="el" href="type_8h_source.html#l00436">isFrozen</a>, <a class="el" href="type_8h_source.html#l00436">isSlice</a>, <a class="el" href="type_8cpp_source.html#l00837">PointerType()</a>, and <a class="el" href="type_8h_source.html#l00053">Variability::SOA</a>.</p>

</div>
</div>
<a class="anchor" id="a0ef290d3d666f58702f9c6d439dff452"></a><!-- doxytag: member="PointerType::GetAsUnboundVariabilityType" ref="a0ef290d3d666f58702f9c6d439dff452" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPointerType.html">PointerType</a> * PointerType::GetAsUnboundVariabilityType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get an instance of the type with unbound variability. </p>

<p>Implements <a class="el" href="classType.html#a11499a547136ca713db16214f71ecbf2">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00926">926</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00437">baseType</a>, <a class="el" href="type_8h_source.html#l00435">isConst</a>, <a class="el" href="type_8h_source.html#l00436">isFrozen</a>, <a class="el" href="type_8h_source.html#l00436">isSlice</a>, <a class="el" href="type_8cpp_source.html#l00837">PointerType()</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Unbound</a>, and <a class="el" href="type_8h_source.html#l00434">variability</a>.</p>

</div>
</div>
<a class="anchor" id="ab9f4094ef75613738d00d7a8485814b8"></a><!-- doxytag: member="PointerType::GetAsUniformType" ref="ab9f4094ef75613738d00d7a8485814b8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPointerType.html">PointerType</a> * PointerType::GetAsUniformType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "uniform" instance of this type. If the type is already uniform, its "this" pointer will be returned. </p>

<p>Implements <a class="el" href="classType.html#ab0eff8692794d3437a91404c98985d20">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00916">916</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00437">baseType</a>, <a class="el" href="type_8h_source.html#l00435">isConst</a>, <a class="el" href="type_8h_source.html#l00436">isFrozen</a>, <a class="el" href="type_8h_source.html#l00436">isSlice</a>, <a class="el" href="type_8cpp_source.html#l00837">PointerType()</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Uniform</a>, and <a class="el" href="type_8h_source.html#l00434">variability</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01152">GetDIType()</a>, and <a class="el" href="type_8cpp_source.html#l01107">LLVMType()</a>.</p>

</div>
</div>
<a class="anchor" id="aa345be1efa7f75311e8015c08f62f5ff"></a><!-- doxytag: member="PointerType::GetAsVaryingType" ref="aa345be1efa7f75311e8015c08f62f5ff" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPointerType.html">PointerType</a> * PointerType::GetAsVaryingType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "varying" instance of this type. If the type is already varying, its "this" pointer will be returned. </p>

<p>Implements <a class="el" href="classType.html#aedfa3c719db7ab073c5e1f75b4041e55">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00906">906</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00437">baseType</a>, <a class="el" href="type_8h_source.html#l00435">isConst</a>, <a class="el" href="type_8h_source.html#l00436">isFrozen</a>, <a class="el" href="type_8h_source.html#l00436">isSlice</a>, <a class="el" href="type_8cpp_source.html#l00837">PointerType()</a>, <a class="el" href="type_8h_source.html#l00434">variability</a>, and <a class="el" href="type_8h_source.html#l00053">Variability::Varying</a>.</p>

</div>
</div>
<a class="anchor" id="a19d9c35984226e4ae0f003495854ab87"></a><!-- doxytag: member="PointerType::GetBaseType" ref="a19d9c35984226e4ae0f003495854ab87" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * PointerType::GetBaseType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the basic root type of the given type. For example, for an array or short-vector, this returns the element type. For a struct or atomic type, it returns itself. </p>

<p>Implements <a class="el" href="classType.html#a51af28faf17eb05982547d9b340429eb">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00900">900</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00437">baseType</a>.</p>

<p>Referenced by <a class="el" href="ctx_8cpp_source.html#l02172">FunctionEmitContext::AddElementOffset()</a>, <a class="el" href="expr_8cpp_source.html#l04613">MemberExpr::create()</a>, <a class="el" href="ctx_8cpp_source.html#l02436">FunctionEmitContext::gather()</a>, <a class="el" href="type_8cpp_source.html#l02493">FunctionType::GetCDeclaration()</a>, <a class="el" href="ctx_8cpp_source.html#l02014">FunctionEmitContext::GetElementPtrInst()</a>, <a class="el" href="expr_8cpp_source.html#l04084">IndexExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l04387">StructMemberExpr::getStructType()</a>, <a class="el" href="expr_8cpp_source.html#l03885">IndexExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03728">lAddVaryingOffsetsIfNeeded()</a>, <a class="el" href="type_8cpp_source.html#l02830">lCheckTypeEquality()</a>, <a class="el" href="expr_8cpp_source.html#l03996">lConvertPtrToSliceIfNeeded()</a>, <a class="el" href="expr_8cpp_source.html#l06551">lDeconstifyType()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, <a class="el" href="expr_8cpp_source.html#l01358">lEmitBinaryPointerArith()</a>, <a class="el" href="ctx_8cpp_source.html#l02382">FunctionEmitContext::LoadInst()</a>, <a class="el" href="ctx_8cpp_source.html#l02347">FunctionEmitContext::loadUniformFromSOA()</a>, <a class="el" href="expr_8cpp_source.html#l03769">lVaryingStructHasUniformMember()</a>, <a class="el" href="ctx_8cpp_source.html#l02716">FunctionEmitContext::scatter()</a>, <a class="el" href="ctx_8cpp_source.html#l02850">FunctionEmitContext::StoreInst()</a>, <a class="el" href="ctx_8cpp_source.html#l02894">FunctionEmitContext::storeUniformToSOA()</a>, <a class="el" href="expr_8cpp_source.html#l03391">FunctionCallExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l04432">VectorMemberExpr::VectorMemberExpr()</a>.</p>

</div>
</div>
<a class="anchor" id="a24b0e77c362d3a2590a11646c4fb06da"></a><!-- doxytag: member="PointerType::GetCDeclaration" ref="a24b0e77c362d3a2590a11646c4fb06da" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string PointerType::GetCDeclaration </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a string that is the declaration of the same type in C syntax. </p>

<p>Implements <a class="el" href="classType.html#a7e35141766bbc63333953263cd85d883">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01077">1077</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8h_source.html#l00437">baseType</a>, <a class="el" href="module_8h_source.html#l00129">Module::errorCount</a>, <a class="el" href="classType.html#a7e35141766bbc63333953263cd85d883">Type::GetCDeclaration()</a>, <a class="el" href="type_8h_source.html#l00435">isConst</a>, <a class="el" href="type_8h_source.html#l00436">isSlice</a>, <a class="el" href="ispc_8cpp_source.html#l00068">m</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="type_8h_source.html#l00053">Variability::SOA</a>, <a class="el" href="type_8h_source.html#l00071">Variability::soaWidth</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Uniform</a>, and <a class="el" href="type_8h_source.html#l00434">variability</a>.</p>

</div>
</div>
<a class="anchor" id="ae8b02a8425138f3916ac97303cd1ed37"></a><!-- doxytag: member="PointerType::GetDIType" ref="ae8b02a8425138f3916ac97303cd1ed37" args="(llvm::DIDescriptor scope) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::DIType PointerType::GetDIType </td>
          <td>(</td>
          <td class="paramtype">llvm::DIDescriptor&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the DIType (LLVM's debugging information structure), corresponding to this type. </p>

<p>Implements <a class="el" href="classType.html#a8b6ded269378020c769915bbbff3d73c">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01152">1152</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8h_source.html#l00437">baseType</a>, <a class="el" href="module_8h_source.html#l00139">Module::diBuilder</a>, <a class="el" href="module_8h_source.html#l00129">Module::errorCount</a>, <a class="el" href="util_8h_source.html#l00113">FATAL</a>, <a class="el" href="ispc_8cpp_source.html#l00067">g</a>, <a class="el" href="type_8cpp_source.html#l00916">GetAsUniformType()</a>, <a class="el" href="classType.html#a8b6ded269378020c769915bbbff3d73c">Type::GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l01442">ArrayType::GetDIType()</a>, <a class="el" href="ispc_8h_source.html#l00212">Target::is32Bit</a>, <a class="el" href="type_8cpp_source.html#l00072">lCreateDIArray()</a>, <a class="el" href="ispc_8cpp_source.html#l00068">m</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="type_8h_source.html#l00053">Variability::SOA</a>, <a class="el" href="type_8h_source.html#l00071">Variability::soaWidth</a>, <a class="el" href="ispc_8h_source.html#l00365">Globals::target</a>, <a class="el" href="type_8h_source.html#l00070">Variability::type</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Uniform</a>, <a class="el" href="type_8h_source.html#l00434">variability</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Varying</a>, and <a class="el" href="ispc_8h_source.html#l00228">Target::vectorWidth</a>.</p>

</div>
</div>
<a class="anchor" id="a189a3258f27d1f4fe47a2462995f992c"></a><!-- doxytag: member="PointerType::GetSliceStructType" ref="a189a3258f27d1f4fe47a2462995f992c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classStructType.html">StructType</a> * PointerType::GetSliceStructType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a structure corresponding to the pointer representation for slice pointers; the first member of this structure is a uniform or varying pointer, and the second element is either a uniform or varying int32. </p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00975">975</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="util_8h_source.html#l00113">FATAL</a>, <a class="el" href="type_8cpp_source.html#l00954">GetAsNonSlice()</a>, <a class="el" href="type_8h_source.html#l00435">isConst</a>, <a class="el" href="type_8h_source.html#l00436">isSlice</a>, <a class="el" href="type_8h_source.html#l00070">Variability::type</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Uniform</a>, <a class="el" href="type_8h_source.html#l00434">variability</a>, and <a class="el" href="type_8h_source.html#l00053">Variability::Varying</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01107">LLVMType()</a>, and <a class="el" href="ctx_8cpp_source.html#l02596">FunctionEmitContext::maskedStore()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2aaad7775c48f38cdc61e95d6219285"></a><!-- doxytag: member="PointerType::GetString" ref="aa2aaad7775c48f38cdc61e95d6219285" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string PointerType::GetString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a text representation of the type (for example, for use in warning and error messages). </p>

<p>Implements <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01041">1041</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8h_source.html#l00437">baseType</a>, <a class="el" href="module_8h_source.html#l00129">Module::errorCount</a>, <a class="el" href="type_8cpp_source.html#l00101">Variability::GetString()</a>, <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">Type::GetString()</a>, <a class="el" href="type_8h_source.html#l00435">isConst</a>, <a class="el" href="type_8h_source.html#l00436">isFrozen</a>, <a class="el" href="type_8h_source.html#l00436">isSlice</a>, <a class="el" href="ispc_8cpp_source.html#l00068">m</a>, <a class="el" href="parse_8yy.html">NULL</a>, and <a class="el" href="type_8h_source.html#l00434">variability</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, and <a class="el" href="expr_8cpp_source.html#l02214">BinaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="ac83e04fe88c4786b11c35006dba19e40"></a><!-- doxytag: member="PointerType::GetUniform" ref="ac83e04fe88c4786b11c35006dba19e40" args="(const Type *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPointerType.html">PointerType</a> * PointerType::GetUniform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper method to return a uniform pointer to the given type. </p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00845">845</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l00837">PointerType()</a>, and <a class="el" href="type_8h_source.html#l00053">Variability::Uniform</a>.</p>

<p>Referenced by <a class="el" href="ctx_8cpp_source.html#l02172">FunctionEmitContext::AddElementOffset()</a>, <a class="el" href="ctx_8cpp_source.html#l03068">FunctionEmitContext::CallInst()</a>, <a class="el" href="ctx_8cpp_source.html#l01160">FunctionEmitContext::CurrentLanesReturned()</a>, <a class="el" href="ctx_8cpp_source.html#l02014">FunctionEmitContext::GetElementPtrInst()</a>, <a class="el" href="expr_8cpp_source.html#l04012">IndexExpr::GetLValue()</a>, <a class="el" href="expr_8cpp_source.html#l04084">IndexExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l06788">ReferenceExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l07128">SymbolExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l04324">StructMemberExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l04492">VectorMemberExpr::GetLValueType()</a>, <a class="el" href="decl_8cpp_source.html#l00345">Declarator::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l06984">AddressOfExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l07885">NewExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03824">IndexExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l04678">MemberExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l04533">VectorMemberExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l00604">InitSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l02867">lEmitVaryingSelect()</a>, <a class="el" href="ctx_8cpp_source.html#l02313">lFinalSliceOffset()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="ctx_8cpp_source.html#l02382">FunctionEmitContext::LoadInst()</a>, <a class="el" href="ctx_8cpp_source.html#l02596">FunctionEmitContext::maskedStore()</a>, and <a class="el" href="ctx_8cpp_source.html#l02850">FunctionEmitContext::StoreInst()</a>.</p>

</div>
</div>
<a class="anchor" id="a826c51a29d9cfe08a22e6da82b43c444"></a><!-- doxytag: member="PointerType::GetVariability" ref="a826c51a29d9cfe08a22e6da82b43c444" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVariability.html">Variability</a> PointerType::GetVariability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the variability of the type. </p>

<p>Implements <a class="el" href="classType.html#a619effc9d2d2517bd884076eb9559b65">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00864">864</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00434">variability</a>.</p>

<p>Referenced by <a class="el" href="ctx_8cpp_source.html#l02172">FunctionEmitContext::AddElementOffset()</a>, <a class="el" href="expr_8cpp_source.html#l06551">lDeconstifyType()</a>, and <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>.</p>

</div>
</div>
<a class="anchor" id="ab00136b4bcf8302ca9fddce6cc4dbab0"></a><!-- doxytag: member="PointerType::GetVarying" ref="ab00136b4bcf8302ca9fddce6cc4dbab0" args="(const Type *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPointerType.html">PointerType</a> * PointerType::GetVarying </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper method to return a varying pointer to the given type. </p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00851">851</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l00837">PointerType()</a>, and <a class="el" href="type_8h_source.html#l00053">Variability::Varying</a>.</p>

<p>Referenced by <a class="el" href="ctx_8cpp_source.html#l02089">FunctionEmitContext::GetElementPtrInst()</a>, <a class="el" href="expr_8cpp_source.html#l04084">IndexExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l04324">StructMemberExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l04492">VectorMemberExpr::GetLValueType()</a>, <a class="el" href="expr_8cpp_source.html#l07885">NewExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04533">VectorMemberExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l03728">lAddVaryingOffsetsIfNeeded()</a>, <a class="el" href="ctx_8cpp_source.html#l02313">lFinalSliceOffset()</a>, and <a class="el" href="ctx_8cpp_source.html#l02716">FunctionEmitContext::scatter()</a>.</p>

</div>
</div>
<a class="anchor" id="a38f010c5c6cb10c38cd53276116941ed"></a><!-- doxytag: member="PointerType::IsBoolType" ref="a38f010c5c6cb10c38cd53276116941ed" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PointerType::IsBoolType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is boolean. In other words, this is true for individual bools and for short-vectors with underlying bool type, but not for arrays of bools. </p>

<p>Implements <a class="el" href="classType.html#a38ff6178597171c11f6e24566b251dea">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00870">870</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5538a7e66b983ff3fcd1dd46905c1e7"></a><!-- doxytag: member="PointerType::IsConstType" ref="ad5538a7e66b983ff3fcd1dd46905c1e7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PointerType::IsConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if this type is 'const'-qualified. </p>

<p>Implements <a class="el" href="classType.html#a9a6d77fb89abc534e2ee1726cc13cf05">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00894">894</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00435">isConst</a>.</p>

<p>Referenced by <a class="el" href="ctx_8cpp_source.html#l02172">FunctionEmitContext::AddElementOffset()</a>, and <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c71a9791f34eacbddd8cc63aa47b373"></a><!-- doxytag: member="PointerType::IsFloatType" ref="a7c71a9791f34eacbddd8cc63aa47b373" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PointerType::IsFloatType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is float or double. In other words, this is true for individual floats/doubles and for short-vectors of them, but not for arrays of them. </p>

<p>Implements <a class="el" href="classType.html#aeee9fe8b11fc75a300cf37f8b5c9f034">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00876">876</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a129f257ee3ac4f1f241352ebe9d5bb30"></a><!-- doxytag: member="PointerType::IsFrozenSlice" ref="a129f257ee3ac4f1f241352ebe9d5bb30" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PointerType::IsFrozenSlice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8h_source.html#l00408">408</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00436">isFrozen</a>.</p>

<p>Referenced by <a class="el" href="ctx_8cpp_source.html#l02014">FunctionEmitContext::GetElementPtrInst()</a>, and <a class="el" href="type_8cpp_source.html#l02830">lCheckTypeEquality()</a>.</p>

</div>
</div>
<a class="anchor" id="a63a9131bb41c41fb59b85caa9c5c55a3"></a><!-- doxytag: member="PointerType::IsIntType" ref="a63a9131bb41c41fb59b85caa9c5c55a3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PointerType::IsIntType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is an integer type. In other words, this is true for individual integers and for short-vectors of integer types, but not for arrays of integer types. </p>

<p>Implements <a class="el" href="classType.html#a3b2b570093e27170d582b67211dd6836">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00882">882</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae65fd322812acd28a23861538b8af167"></a><!-- doxytag: member="PointerType::IsSlice" ref="ae65fd322812acd28a23861538b8af167" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PointerType::IsSlice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8h_source.html#l00407">407</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00436">isSlice</a>.</p>

<p>Referenced by <a class="el" href="ctx_8cpp_source.html#l02172">FunctionEmitContext::AddElementOffset()</a>, <a class="el" href="ctx_8cpp_source.html#l02436">FunctionEmitContext::gather()</a>, <a class="el" href="ctx_8cpp_source.html#l02014">FunctionEmitContext::GetElementPtrInst()</a>, <a class="el" href="expr_8cpp_source.html#l04276">StructMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04454">VectorMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l06268">TypeCastExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l03728">lAddVaryingOffsetsIfNeeded()</a>, <a class="el" href="type_8cpp_source.html#l02830">lCheckTypeEquality()</a>, <a class="el" href="expr_8cpp_source.html#l03996">lConvertPtrToSliceIfNeeded()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, <a class="el" href="expr_8cpp_source.html#l01358">lEmitBinaryPointerArith()</a>, <a class="el" href="ctx_8cpp_source.html#l02382">FunctionEmitContext::LoadInst()</a>, <a class="el" href="ctx_8cpp_source.html#l02596">FunctionEmitContext::maskedStore()</a>, <a class="el" href="ctx_8cpp_source.html#l02716">FunctionEmitContext::scatter()</a>, and <a class="el" href="ctx_8cpp_source.html#l02850">FunctionEmitContext::StoreInst()</a>.</p>

</div>
</div>
<a class="anchor" id="a18c57097dfe42d3d1fe48d3068aa8841"></a><!-- doxytag: member="PointerType::IsUnsignedType" ref="a18c57097dfe42d3d1fe48d3068aa8841" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PointerType::IsUnsignedType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is unsigned. In other words, this is true for unsigned integers and short vectors of unsigned integer types. </p>

<p>Implements <a class="el" href="classType.html#a9fb5648ec4eb5b432723cf0b3332f8d0">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00888">888</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee095e680938be20bcbf9f579ad6ae6f"></a><!-- doxytag: member="PointerType::IsVoidPointer" ref="aee095e680938be20bcbf9f579ad6ae6f" args="(const Type *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PointerType::IsVoidPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the given type is a void * type. </p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00857">857</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l02943">Type::EqualIgnoringConst()</a>, <a class="el" href="classType.html#ab0eff8692794d3437a91404c98985d20">Type::GetAsUniformType()</a>, and <a class="el" href="type_8h_source.html#l00431">Void</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, <a class="el" href="type_8cpp_source.html#l02665">Type::MoreGeneralType()</a>, <a class="el" href="expr_8cpp_source.html#l01202">UnaryExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02214">BinaryExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l02731">AssignExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a9fc3f6f75d4a2a3f496af6ea5a551bf1"></a><!-- doxytag: member="PointerType::LLVMType" ref="a9fc3f6f75d4a2a3f496af6ea5a551bf1" args="(llvm::LLVMContext *ctx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_TYPE_CONST llvm::Type * PointerType::LLVMType </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the LLVM type corresponding to this ispc type </p>

<p>Implements <a class="el" href="classType.html#aa7b08bf258938faa7e12b580b623621a">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01107">1107</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8h_source.html#l00437">baseType</a>, <a class="el" href="module_8h_source.html#l00129">Module::errorCount</a>, <a class="el" href="util_8h_source.html#l00113">FATAL</a>, <a class="el" href="type_8cpp_source.html#l00916">GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l00975">GetSliceStructType()</a>, <a class="el" href="type_8h_source.html#l00436">isSlice</a>, <a class="el" href="ispc_8h_source.html#l00099">LLVM_TYPE_CONST</a>, <a class="el" href="type_8cpp_source.html#l02539">FunctionType::LLVMFunctionType()</a>, <a class="el" href="classType.html#aa7b08bf258938faa7e12b580b623621a">Type::LLVMType()</a>, <a class="el" href="type_8cpp_source.html#l01200">ArrayType::LLVMType()</a>, <a class="el" href="type_8cpp_source.html#l01942">StructType::LLVMType()</a>, <a class="el" href="ispc_8cpp_source.html#l00068">m</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="type_8h_source.html#l00053">Variability::SOA</a>, <a class="el" href="type_8h_source.html#l00071">Variability::soaWidth</a>, <a class="el" href="type_8h_source.html#l00070">Variability::type</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Uniform</a>, <a class="el" href="type_8h_source.html#l00434">variability</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Varying</a>, <a class="el" href="llvmutil_8h_source.html#l00065">LLVMTypes::VoidPointerType</a>, and <a class="el" href="llvmutil_8h_source.html#l00101">LLVMTypes::VoidPointerVectorType</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l03938">lConvertToSlicePointer()</a>, and <a class="el" href="expr_8cpp_source.html#l02867">lEmitVaryingSelect()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d5b123de5c1e412f11ef04eab996f38"></a><!-- doxytag: member="PointerType::Mangle" ref="a5d5b123de5c1e412f11ef04eab996f38" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string PointerType::Mangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a string that represents the mangled type (for use in mangling function symbol names for function overloading). The various Types implementations of this method should collectively ensure that all of them use mangling schemes that are guaranteed not to clash. </p>

<p>Implements <a class="el" href="classType.html#a7bd23bd909d493d271dbe1024d212c06">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01060">1060</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8h_source.html#l00437">baseType</a>, <a class="el" href="module_8h_source.html#l00129">Module::errorCount</a>, <a class="el" href="type_8h_source.html#l00436">isFrozen</a>, <a class="el" href="type_8h_source.html#l00436">isSlice</a>, <a class="el" href="ispc_8cpp_source.html#l00068">m</a>, <a class="el" href="classType.html#a7bd23bd909d493d271dbe1024d212c06">Type::Mangle()</a>, <a class="el" href="type_8cpp_source.html#l00119">Variability::MangleString()</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Unbound</a>, and <a class="el" href="type_8h_source.html#l00434">variability</a>.</p>

</div>
</div>
<a class="anchor" id="aff7e397d4e26a3a5be4fd128389adf76"></a><!-- doxytag: member="PointerType::ResolveUnboundVariability" ref="aff7e397d4e26a3a5be4fd128389adf76" args="(Variability v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPointerType.html">PointerType</a> * PointerType::ResolveUnboundVariability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVariability.html">Variability</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classType.html#adced497622fac125548ef5531495c738">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01006">1006</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8h_source.html#l00437">baseType</a>, <a class="el" href="module_8h_source.html#l00129">Module::errorCount</a>, <a class="el" href="type_8h_source.html#l00435">isConst</a>, <a class="el" href="type_8h_source.html#l00436">isFrozen</a>, <a class="el" href="type_8h_source.html#l00436">isSlice</a>, <a class="el" href="ispc_8cpp_source.html#l00068">m</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="type_8cpp_source.html#l00837">PointerType()</a>, <a class="el" href="classType.html#adced497622fac125548ef5531495c738">Type::ResolveUnboundVariability()</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Unbound</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Uniform</a>, and <a class="el" href="type_8h_source.html#l00434">variability</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ab350edb59139edbf35764721f44f8984"></a><!-- doxytag: member="PointerType::baseType" ref="ab350edb59139edbf35764721f44f8984" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a>* <a class="el" href="classPointerType.html#ab350edb59139edbf35764721f44f8984">PointerType::baseType</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8h_source.html#l00437">437</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01023">GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l00962">GetAsFrozenSlice()</a>, <a class="el" href="type_8cpp_source.html#l01032">GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l00954">GetAsNonSlice()</a>, <a class="el" href="type_8cpp_source.html#l00946">GetAsSlice()</a>, <a class="el" href="type_8cpp_source.html#l00936">GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l00926">GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l00916">GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l00906">GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l00900">GetBaseType()</a>, <a class="el" href="type_8cpp_source.html#l01077">GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l01152">GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l01041">GetString()</a>, <a class="el" href="type_8cpp_source.html#l01107">LLVMType()</a>, <a class="el" href="type_8cpp_source.html#l01060">Mangle()</a>, <a class="el" href="type_8cpp_source.html#l00837">PointerType()</a>, and <a class="el" href="type_8cpp_source.html#l01006">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="abbebbe566a8a9fc153475b0703745370"></a><!-- doxytag: member="PointerType::isConst" ref="abbebbe566a8a9fc153475b0703745370" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classPointerType.html#abbebbe566a8a9fc153475b0703745370">PointerType::isConst</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8h_source.html#l00435">435</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01023">GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l00962">GetAsFrozenSlice()</a>, <a class="el" href="type_8cpp_source.html#l01032">GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l00954">GetAsNonSlice()</a>, <a class="el" href="type_8cpp_source.html#l00946">GetAsSlice()</a>, <a class="el" href="type_8cpp_source.html#l00936">GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l00926">GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l00916">GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l00906">GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l01077">GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l00975">GetSliceStructType()</a>, <a class="el" href="type_8cpp_source.html#l01041">GetString()</a>, <a class="el" href="type_8cpp_source.html#l00894">IsConstType()</a>, and <a class="el" href="type_8cpp_source.html#l01006">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a9b2bd50245b39978b91aba6955f05e"></a><!-- doxytag: member="PointerType::isFrozen" ref="a2a9b2bd50245b39978b91aba6955f05e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classPointerType.html#a2a9b2bd50245b39978b91aba6955f05e">PointerType::isFrozen</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8h_source.html#l00436">436</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l00962">GetAsFrozenSlice()</a>, <a class="el" href="type_8cpp_source.html#l00936">GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l00926">GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l00916">GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l00906">GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l01041">GetString()</a>, <a class="el" href="type_8h_source.html#l00408">IsFrozenSlice()</a>, <a class="el" href="type_8cpp_source.html#l01060">Mangle()</a>, and <a class="el" href="type_8cpp_source.html#l01006">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8b781e7a07657061c89bd4ce379b8fe"></a><!-- doxytag: member="PointerType::isSlice" ref="ad8b781e7a07657061c89bd4ce379b8fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classPointerType.html#ad8b781e7a07657061c89bd4ce379b8fe">PointerType::isSlice</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8h_source.html#l00436">436</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01023">GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l01032">GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l00954">GetAsNonSlice()</a>, <a class="el" href="type_8cpp_source.html#l00946">GetAsSlice()</a>, <a class="el" href="type_8cpp_source.html#l00936">GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l00926">GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l00916">GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l00906">GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l01077">GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l00975">GetSliceStructType()</a>, <a class="el" href="type_8cpp_source.html#l01041">GetString()</a>, <a class="el" href="type_8h_source.html#l00407">IsSlice()</a>, <a class="el" href="type_8cpp_source.html#l01107">LLVMType()</a>, <a class="el" href="type_8cpp_source.html#l01060">Mangle()</a>, and <a class="el" href="type_8cpp_source.html#l01006">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9f936750e12b4d135c2d0df0c84a126"></a><!-- doxytag: member="PointerType::variability" ref="aa9f936750e12b4d135c2d0df0c84a126" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structVariability.html">Variability</a> <a class="el" href="classPointerType.html#aa9f936750e12b4d135c2d0df0c84a126">PointerType::variability</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8h_source.html#l00434">434</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01023">GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l00962">GetAsFrozenSlice()</a>, <a class="el" href="type_8cpp_source.html#l01032">GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l00954">GetAsNonSlice()</a>, <a class="el" href="type_8cpp_source.html#l00946">GetAsSlice()</a>, <a class="el" href="type_8cpp_source.html#l00926">GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l00916">GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l00906">GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l01077">GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l01152">GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l00975">GetSliceStructType()</a>, <a class="el" href="type_8cpp_source.html#l01041">GetString()</a>, <a class="el" href="type_8cpp_source.html#l00864">GetVariability()</a>, <a class="el" href="type_8cpp_source.html#l01107">LLVMType()</a>, <a class="el" href="type_8cpp_source.html#l01060">Mangle()</a>, and <a class="el" href="type_8cpp_source.html#l01006">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="a647bcf895b01b89eba466a96fb9e87ad"></a><!-- doxytag: member="PointerType::Void" ref="a647bcf895b01b89eba466a96fb9e87ad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPointerType.html">PointerType</a> * <a class="el" href="classPointerType.html#a647bcf895b01b89eba466a96fb9e87ad">PointerType::Void</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> 
    <span class="keyword">new</span> <a class="code" href="classPointerType.html#a6e58f990b77bd957a8e0a2686ba76eba">PointerType</a>(<a class="code" href="classAtomicType.html#a28a79cd7526ec38bf8ae805bfbb179f3">AtomicType::Void</a>, <a class="code" href="structVariability.html">Variability</a>(<a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a489d62b409bc3a0793202b0a43758e62">Variability::Uniform</a>), <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00431">431</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l07688">NullPointerExpr::GetType()</a>, <a class="el" href="type_8cpp_source.html#l00857">IsVoidPointer()</a>, and <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="type_8h_source.html">type.h</a></li>
<li><a class="el" href="type_8cpp_source.html">type.cpp</a></li>
</ul>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 20 2012 11:56:26 for Intel SPMD Program Compiler by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
