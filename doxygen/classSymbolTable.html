<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Intel SPMD Program Compiler: SymbolTable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>SymbolTable Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="SymbolTable" -->
<p><a class="el" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> table that holds all known symbols during parsing and compilation.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sym_8h_source.html">sym.h</a>&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Collaboration diagram for SymbolTable:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
<div class="center"><img src="classSymbolTable__coll__graph.png" border="0" usemap="#SymbolTable_coll__map" alt="Collaboration graph"/></div>
<map name="SymbolTable_coll__map" id="SymbolTable_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center><!-- endSectionContent --></div>

<p><a href="classSymbolTable-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a1fbe6cec5594463b766db0ac58c9aa1d">SymbolTable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a5d5ae9b5b22d87691cec9ec17cfff650">~SymbolTable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#ae8daa1cf8667258e065b8be95facb330">PushScope</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#aa79caf59c28df4805abaf2ce5df83198">PopScope</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a2d5e4d85d5e1ede45b7fd155741628ff">AddVariable</a> (<a class="el" href="classSymbol.html">Symbol</a> *symbol)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a4c89545a31f6a562bb10089b79fa5c08">LookupVariable</a> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#ab49a5dd3c4f49a5c1a2b7882dd1af736">AddFunction</a> (<a class="el" href="classSymbol.html">Symbol</a> *symbol)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#aa6d40cc2e51a74600689f6b36228368b">LookupFunction</a> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a716e77310132f022532a016e6fe1e127">LookupFunction</a> (const char *name, const <a class="el" href="classFunctionType.html">FunctionType</a> *type)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a405f262bf6a2687b2e804c92d5c99724">GetMatchingFunctions</a> (Predicate pred, std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; *matches) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#ab449fbe2b55797a074940394467a262e">AddType</a> (const char *name, const <a class="el" href="classType.html">Type</a> *type, <a class="el" href="structSourcePos.html">SourcePos</a> pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a0d086940081f34d21263eb828a3ddfed">LookupType</a> (const char *name) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a6e76946243946eace77ea44ea30329d6">ClosestVariableOrFunctionMatch</a> (const char *name) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#af496f9175cb4a1370d61d9b166050324">ClosestTypeMatch</a> (const char *name) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#aa3608c26685895932ce7db07ec3ab73d">ClosestEnumTypeMatch</a> (const char *name) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a6642684baa5464f91821d8a83595bb7b">Print</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <br class="typebreak"/>
const <a class="el" href="classType.html">Type</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a03c3d3253785b20285973345d1ebda6c">TypeMapType</a></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a1cbb54b5e068d8b3da9a35fafd91af76">closestTypeMatch</a> (const char *str, bool structsVsEnums) const </td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a79ef1f70396160a15004be66cb313b7a">variables</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <br class="typebreak"/>
std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a4508517e91f92712f53d37e0dd4854b1">functions</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSymbolTable.html#a03c3d3253785b20285973345d1ebda6c">TypeMapType</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymbolTable.html#a07d5bfbdbafae7bfe2c6126725fd5558">types</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> table that holds all known symbols during parsing and compilation. </p>
<p>A single instance of a <a class="el" href="classSymbolTable.html" title="Symbol table that holds all known symbols during parsing and compilation.">SymbolTable</a> is stored in the <a class="el" href="classModule.html">Module</a> class (<a class="el" href="classModule.html#a66a01f1bae4f9c26eb1bc95780865954">Module::symbolTable</a>); it is created in the <a class="el" href="classModule.html#a4eff728447dea74aa9bfb0de65c6d0a4">Module::Module()</a> constructor. It is then accessed via the global variable <a class="el" href="classModule.html">Module</a> *<a class="el" href="ispc_8cpp.html#a8a689c90deea0b4e040fdede6e79dc95">m</a> throughout the ispc implementation. </p>

<p>Definition at line <a class="el" href="sym_8h_source.html#l00115">115</a> of file <a class="el" href="sym_8h_source.html">sym.h</a>.</p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a03c3d3253785b20285973345d1ebda6c"></a><!-- doxytag: member="SymbolTable::TypeMapType" ref="a03c3d3253785b20285973345d1ebda6c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, const <a class="el" href="classType.html">Type</a> *&gt; <a class="el" href="classSymbolTable.html#a03c3d3253785b20285973345d1ebda6c">SymbolTable::TypeMapType</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="sym_8h_source.html#l00245">245</a> of file <a class="el" href="sym_8h_source.html">sym.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1fbe6cec5594463b766db0ac58c9aa1d"></a><!-- doxytag: member="SymbolTable::SymbolTable" ref="a1fbe6cec5594463b766db0ac58c9aa1d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymbolTable::SymbolTable </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="sym_8cpp_source.html#l00066">66</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p>References <a class="el" href="sym_8cpp_source.html#l00078">PushScope()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d5ae9b5b22d87691cec9ec17cfff650"></a><!-- doxytag: member="SymbolTable::~SymbolTable" ref="a5d5ae9b5b22d87691cec9ec17cfff650" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymbolTable::~SymbolTable </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="sym_8cpp_source.html#l00071">71</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">assert</a>, <a class="el" href="sym_8cpp_source.html#l00085">PopScope()</a>, <a class="el" href="sym_8h_source.html#l00250">types</a>, and <a class="el" href="sym_8h_source.html#l00238">variables</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab49a5dd3c4f49a5c1a2b7882dd1af736"></a><!-- doxytag: member="SymbolTable::AddFunction" ref="ab49a5dd3c4f49a5c1a2b7882dd1af736" args="(Symbol *symbol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SymbolTable::AddFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"> <em>symbol</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds the given function symbol to the symbol table. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>The function symbol to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the symbol has been added. False if another function symbol with the same name and function signature is already present in the symbol table. </dd></dl>

<p>Definition at line <a class="el" href="sym_8cpp_source.html#l00150">150</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">assert</a>, <a class="el" href="sym_8h_source.html#l00244">functions</a>, <a class="el" href="sym_8cpp_source.html#l00164">LookupFunction()</a>, <a class="el" href="sym_8h_source.html#l00076">Symbol::name</a>, <a class="el" href="parse_8yy.html">NULL</a>, and <a class="el" href="sym_8h_source.html#l00084">Symbol::type</a>.</p>

<p>Referenced by <a class="el" href="builtins_8cpp_source.html#l00201">lCreateISPCSymbol()</a>, <a class="el" href="builtins_8cpp_source.html#l00176">lCreateSymbol()</a>, and <a class="el" href="module_8cpp_source.html#l00269">lInitFunSymDecl()</a>.</p>

</div>
</div>
<a class="anchor" id="ab449fbe2b55797a074940394467a262e"></a><!-- doxytag: member="SymbolTable::AddType" ref="ab449fbe2b55797a074940394467a262e" args="(const char *name, const Type *type, SourcePos pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SymbolTable::AddType </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSourcePos.html">SourcePos</a>&#160;</td>
          <td class="paramname"> <em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds the named type to the symbol table. This is used for both struct definitions (where <code>struct Foo</code> causes type <code>Foo</code> to be added to the symbol table) as well as for <code>typedef</code>s.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the type to be added </td></tr>
    <tr><td class="paramname">type</td><td><a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> that <code>name</code> represents </td></tr>
    <tr><td class="paramname">pos</td><td>Position in source file where the type was named </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the named type was successfully added. False if a type with the same name has already been defined. </dd></dl>

<p>Definition at line <a class="el" href="sym_8cpp_source.html#l00185">185</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p>References <a class="el" href="util_8cpp_source.html#l00260">Error()</a>, <a class="el" href="sym_8h_source.html#l00250">types</a>, and <a class="el" href="util_8cpp_source.html#l00282">Warning()</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00451">Module::AddGlobal()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d5e4d85d5e1ede45b7fd155741628ff"></a><!-- doxytag: member="SymbolTable::AddVariable" ref="a2d5e4d85d5e1ede45b7fd155741628ff" args="(Symbol *symbol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SymbolTable::AddVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"> <em>symbol</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds the given variable symbol to the symbol table. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>The symbol to be added</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if successful; false if the provided symbol clashes with a symbol defined at the same scope. (Symbols may shaodow symbols in outer scopes; a warning is issued in this case, but this method still returns true.) </dd></dl>

<p>Definition at line <a class="el" href="sym_8cpp_source.html#l00097">97</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">assert</a>, <a class="el" href="util_8cpp_source.html#l00260">Error()</a>, <a class="el" href="sym_8h_source.html#l00076">Symbol::name</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="sym_8h_source.html#l00075">Symbol::pos</a>, <a class="el" href="sym_8h_source.html#l00238">variables</a>, and <a class="el" href="util_8cpp_source.html#l00282">Warning()</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00451">Module::AddGlobal()</a>, <a class="el" href="decl_8cpp_source.html#l00298">Declaration::AddSymbols()</a>, <a class="el" href="builtins_8cpp_source.html#l00378">lDefineConstantInt()</a>, <a class="el" href="builtins_8cpp_source.html#l00394">lDefineConstantIntFunc()</a>, and <a class="el" href="builtins_8cpp_source.html#l00414">lDefineProgramIndex()</a>.</p>

</div>
</div>
<a class="anchor" id="aa3608c26685895932ce7db07ec3ab73d"></a><!-- doxytag: member="SymbolTable::ClosestEnumTypeMatch" ref="aa3608c26685895932ce7db07ec3ab73d" args="(const char *name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; SymbolTable::ClosestEnumTypeMatch </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>name</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="sym_8cpp_source.html#l00266">266</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p>References <a class="el" href="sym_8cpp_source.html#l00272">closestTypeMatch()</a>.</p>

</div>
</div>
<a class="anchor" id="af496f9175cb4a1370d61d9b166050324"></a><!-- doxytag: member="SymbolTable::ClosestTypeMatch" ref="af496f9175cb4a1370d61d9b166050324" args="(const char *name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; SymbolTable::ClosestTypeMatch </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>name</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns zero or more strings with the names of types in the symbol table that nearly (but not exactly) match the given name. </p>

<p>Definition at line <a class="el" href="sym_8cpp_source.html#l00260">260</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p>References <a class="el" href="sym_8cpp_source.html#l00272">closestTypeMatch()</a>.</p>

</div>
</div>
<a class="anchor" id="a1cbb54b5e068d8b3da9a35fafd91af76"></a><!-- doxytag: member="SymbolTable::closestTypeMatch" ref="a1cbb54b5e068d8b3da9a35fafd91af76" args="(const char *str, bool structsVsEnums) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; SymbolTable::closestTypeMatch </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>structsVsEnums</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="sym_8cpp_source.html#l00272">272</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="util_8cpp_source.html#l00315">StringEditDistance()</a>, and <a class="el" href="sym_8h_source.html#l00250">types</a>.</p>

<p>Referenced by <a class="el" href="sym_8cpp_source.html#l00266">ClosestEnumTypeMatch()</a>, and <a class="el" href="sym_8cpp_source.html#l00260">ClosestTypeMatch()</a>.</p>

</div>
</div>
<a class="anchor" id="a6e76946243946eace77ea44ea30329d6"></a><!-- doxytag: member="SymbolTable::ClosestVariableOrFunctionMatch" ref="a6e76946243946eace77ea44ea30329d6" args="(const char *name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; SymbolTable::ClosestVariableOrFunctionMatch </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>name</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns zero or more strings with the names of symbols in the symbol table that nearly (but not exactly) match the given name. This is useful for issuing informative error methods when misspelled identifiers are found a programs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>String to compare variable and function symbol names against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>vector of zero or more strings that approximately match <code>name</code>. </dd></dl>

<p>Definition at line <a class="el" href="sym_8cpp_source.html#l00223">223</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p>References <a class="el" href="sym_8h_source.html#l00244">functions</a>, <a class="el" href="util_8cpp_source.html#l00315">StringEditDistance()</a>, and <a class="el" href="sym_8h_source.html#l00238">variables</a>.</p>

</div>
</div>
<a class="anchor" id="a405f262bf6a2687b2e804c92d5c99724"></a><!-- doxytag: member="SymbolTable::GetMatchingFunctions" ref="a405f262bf6a2687b2e804c92d5c99724" args="(Predicate pred, std::vector&lt; Symbol * &gt; *matches) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SymbolTable::GetMatchingFunctions </td>
          <td>(</td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"> <em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; *&#160;</td>
          <td class="paramname"> <em>matches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns all of the functions in the symbol table that match the given predicate.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>A unary predicate that returns true or false, given a <a class="el" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> pointer, based on whether the symbol should be included in the returned set of matches. It can either be a function, with signature <code>bool pred(const Symbol *s)</code>, or a unary predicate object with an <code>bool operator()(const Symbol *)</code> method.</td></tr>
    <tr><td class="paramname">matches</td><td>Pointer to a vector in which to return the matching symbols. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sym_8h_source.html#l00255">255</a> of file <a class="el" href="sym_8h_source.html">sym.h</a>.</p>

<p>References <a class="el" href="sym_8h_source.html#l00244">functions</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l01272">Module::writeHeader()</a>.</p>

</div>
</div>
<a class="anchor" id="a716e77310132f022532a016e6fe1e127"></a><!-- doxytag: member="SymbolTable::LookupFunction" ref="a716e77310132f022532a016e6fe1e127" args="(const char *name, const FunctionType *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * SymbolTable::LookupFunction </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunctionType.html">FunctionType</a> *&#160;</td>
          <td class="paramname"> <em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks for a function with the given name and type in the symbol table.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to matching <a class="el" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a>; NULL if none is found. </dd></dl>

<p>Definition at line <a class="el" href="sym_8cpp_source.html#l00172">172</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l02056">Type::Equal()</a>, <a class="el" href="sym_8h_source.html#l00244">functions</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="aa6d40cc2e51a74600689f6b36228368b"></a><!-- doxytag: member="SymbolTable::LookupFunction" ref="aa6d40cc2e51a74600689f6b36228368b" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; * SymbolTable::LookupFunction </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>name</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks for the function or functions with the given name in the symbol name. If a function has been overloaded and multiple definitions are present for a given function name, all of them will be returned and it's up the the caller to resolve which one (if any) to use.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>vector of <a class="el" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> pointers to functions with the given name. </dd></dl>

<p>Definition at line <a class="el" href="sym_8cpp_source.html#l00164">164</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p>References <a class="el" href="sym_8h_source.html#l00244">functions</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="sym_8cpp_source.html#l00150">AddFunction()</a>, <a class="el" href="module_8cpp_source.html#l00763">Module::AddFunction()</a>, <a class="el" href="module_8cpp_source.html#l00451">Module::AddGlobal()</a>, <a class="el" href="ctx_8cpp_source.html#l00691">FunctionEmitContext::LaneMask()</a>, <a class="el" href="module_8cpp_source.html#l00269">lInitFunSymDecl()</a>, and <a class="el" href="expr_8cpp_source.html#l01145">BinaryExpr::Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d086940081f34d21263eb828a3ddfed"></a><!-- doxytag: member="SymbolTable::LookupType" ref="a0d086940081f34d21263eb828a3ddfed" args="(const char *name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * SymbolTable::LookupType </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>name</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks for a type of the given name in the symbol table.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a>, if found; otherwise NULL is returned. </dd></dl>

<p>Definition at line <a class="el" href="sym_8cpp_source.html#l00211">211</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">NULL</a>, and <a class="el" href="sym_8h_source.html#l00250">types</a>.</p>

</div>
</div>
<a class="anchor" id="a4c89545a31f6a562bb10089b79fa5c08"></a><!-- doxytag: member="SymbolTable::LookupVariable" ref="a4c89545a31f6a562bb10089b79fa5c08" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * SymbolTable::LookupVariable </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>name</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks for a variable with the given name in the symbol table. This method searches outward from the innermost scope to the outermost, returning the first match found.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the variable to be searched for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the <a class="el" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a>, if a match is found. NULL if no <a class="el" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> with the given name is in the symbol table. </dd></dl>

<p>Definition at line <a class="el" href="sym_8cpp_source.html#l00132">132</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">NULL</a>, and <a class="el" href="sym_8h_source.html#l00238">variables</a>.</p>

<p>Referenced by <a class="el" href="ctx_8cpp_source.html#l00126">FunctionEmitContext::FunctionEmitContext()</a>, <a class="el" href="module_8cpp_source.html#l00616">lEmitFunctionCode()</a>, and <a class="el" href="module_8cpp_source.html#l00269">lInitFunSymDecl()</a>.</p>

</div>
</div>
<a class="anchor" id="aa79caf59c28df4805abaf2ce5df83198"></a><!-- doxytag: member="SymbolTable::PopScope" ref="aa79caf59c28df4805abaf2ce5df83198" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbolTable::PopScope </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each scope started by a call to <a class="el" href="classSymbolTable.html#ae8daa1cf8667258e065b8be95facb330">SymbolTable::PushScope()</a>, there must be a matching call to <a class="el" href="classSymbolTable.html#aa79caf59c28df4805abaf2ce5df83198">SymbolTable::PopScope()</a> at the end of that scope. </p>

<p>Definition at line <a class="el" href="sym_8cpp_source.html#l00085">85</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">assert</a>, <a class="el" href="sym_8h_source.html#l00250">types</a>, and <a class="el" href="sym_8h_source.html#l00238">variables</a>.</p>

<p>Referenced by <a class="el" href="sym_8cpp_source.html#l00071">~SymbolTable()</a>.</p>

</div>
</div>
<a class="anchor" id="a6642684baa5464f91821d8a83595bb7b"></a><!-- doxytag: member="SymbolTable::Print" ref="a6642684baa5464f91821d8a83595bb7b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbolTable::Print </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints out the entire contents of the symbol table to standard error. (Debugging method). </p>

<p>Definition at line <a class="el" href="sym_8cpp_source.html#l00306">306</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p>References <a class="el" href="sym_8h_source.html#l00244">functions</a>, <a class="el" href="parse_8yy.html">stderr</a>, <a class="el" href="sym_8h_source.html#l00250">types</a>, and <a class="el" href="sym_8h_source.html#l00238">variables</a>.</p>

</div>
</div>
<a class="anchor" id="ae8daa1cf8667258e065b8be95facb330"></a><!-- doxytag: member="SymbolTable::PushScope" ref="ae8daa1cf8667258e065b8be95facb330" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbolTable::PushScope </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The parser calls this method when it enters a new scope in the program; this allows us to track variables that shadows others in outer scopes with same name as well as to efficiently discard all of the variables declared in a particular scope when we exit that scope. </p>

<p>Definition at line <a class="el" href="sym_8cpp_source.html#l00078">78</a> of file <a class="el" href="sym_8cpp_source.html">sym.cpp</a>.</p>

<p>References <a class="el" href="sym_8h_source.html#l00250">types</a>, and <a class="el" href="sym_8h_source.html#l00238">variables</a>.</p>

<p>Referenced by <a class="el" href="sym_8cpp_source.html#l00066">SymbolTable()</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a4508517e91f92712f53d37e0dd4854b1"></a><!-- doxytag: member="SymbolTable::functions" ref="a4508517e91f92712f53d37e0dd4854b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;<a class="el" href="classSymbol.html">Symbol</a> *&gt; &gt; <a class="el" href="classSymbolTable.html#a4508517e91f92712f53d37e0dd4854b1">SymbolTable::functions</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Because there is no scoping for function symbols, functions are represented with a single STL <code>map</code> from names to symbols. A STL <code>vector</code> is used to store the function symbols for a given name since, due to function overloading, a name can have multiple function symbols associated with it. </p>

<p>Definition at line <a class="el" href="sym_8h_source.html#l00244">244</a> of file <a class="el" href="sym_8h_source.html">sym.h</a>.</p>

<p>Referenced by <a class="el" href="sym_8cpp_source.html#l00150">AddFunction()</a>, <a class="el" href="sym_8cpp_source.html#l00223">ClosestVariableOrFunctionMatch()</a>, <a class="el" href="sym_8h_source.html#l00255">GetMatchingFunctions()</a>, <a class="el" href="sym_8cpp_source.html#l00164">LookupFunction()</a>, and <a class="el" href="sym_8cpp_source.html#l00306">Print()</a>.</p>

</div>
</div>
<a class="anchor" id="a07d5bfbdbafae7bfe2c6126725fd5558"></a><!-- doxytag: member="SymbolTable::types" ref="a07d5bfbdbafae7bfe2c6126725fd5558" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSymbolTable.html#a03c3d3253785b20285973345d1ebda6c">TypeMapType</a> *&gt; <a class="el" href="classSymbolTable.html#a07d5bfbdbafae7bfe2c6126725fd5558">SymbolTable::types</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Like variables, type definitions can be scoped. A new <code>TypeMapType</code> is added to the back of the <code>types</code> <code>vector</code> each time a new scope is entered. (And it's removed when the scope exits). </p>

<p>Definition at line <a class="el" href="sym_8h_source.html#l00250">250</a> of file <a class="el" href="sym_8h_source.html">sym.h</a>.</p>

<p>Referenced by <a class="el" href="sym_8cpp_source.html#l00185">AddType()</a>, <a class="el" href="sym_8cpp_source.html#l00272">closestTypeMatch()</a>, <a class="el" href="sym_8cpp_source.html#l00211">LookupType()</a>, <a class="el" href="sym_8cpp_source.html#l00085">PopScope()</a>, <a class="el" href="sym_8cpp_source.html#l00306">Print()</a>, <a class="el" href="sym_8cpp_source.html#l00078">PushScope()</a>, and <a class="el" href="sym_8cpp_source.html#l00071">~SymbolTable()</a>.</p>

</div>
</div>
<a class="anchor" id="a79ef1f70396160a15004be66cb313b7a"></a><!-- doxytag: member="SymbolTable::variables" ref="a79ef1f70396160a15004be66cb313b7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classSymbol.html">Symbol</a> *&gt; *&gt; <a class="el" href="classSymbolTable.html#a79ef1f70396160a15004be66cb313b7a">SymbolTable::variables</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This member variable holds one <code>vector</code> of <a class="el" href="classSymbol.html" title="Representation of a program symbol.">Symbol</a> pointers for each of the current active scopes as the program is being parsed. New vectors of symbols are added and removed from the end of the main vector, so searches for symbols start looking at the end of <code>variables</code> and work backwards. </p>

<p>Definition at line <a class="el" href="sym_8h_source.html#l00238">238</a> of file <a class="el" href="sym_8h_source.html">sym.h</a>.</p>

<p>Referenced by <a class="el" href="sym_8cpp_source.html#l00097">AddVariable()</a>, <a class="el" href="sym_8cpp_source.html#l00223">ClosestVariableOrFunctionMatch()</a>, <a class="el" href="sym_8cpp_source.html#l00132">LookupVariable()</a>, <a class="el" href="sym_8cpp_source.html#l00085">PopScope()</a>, <a class="el" href="sym_8cpp_source.html#l00306">Print()</a>, <a class="el" href="sym_8cpp_source.html#l00078">PushScope()</a>, and <a class="el" href="sym_8cpp_source.html#l00071">~SymbolTable()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="sym_8h_source.html">sym.h</a></li>
<li><a class="el" href="sym_8cpp_source.html">sym.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Sep 30 2011 14:55:39 for Intel SPMD Program Compiler by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
