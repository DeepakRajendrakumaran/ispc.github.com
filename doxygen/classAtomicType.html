<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Intel SPMD Program Compiler: AtomicType Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Intel SPMD Program Compiler
   &#160;<span id="projectnumber">1.2.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">AtomicType Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="AtomicType" --><!-- doxytag: inherits="Type" -->
<p><a class="el" href="classAtomicType.html" title="AtomicType represents basic types like floats, ints, etc.">AtomicType</a> represents basic types like floats, ints, etc.  
 <a href="classAtomicType.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="type_8h_source.html">type.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AtomicType:</div>
<div class="dyncontent">
<div class="center"><img src="classAtomicType__inherit__graph.png" border="0" usemap="#AtomicType_inherit__map" alt="Inheritance graph"/></div>
<map name="AtomicType_inherit__map" id="AtomicType_inherit__map">
<area shape="rect" id="node2" href="classType.html" title="Interface class that defines the type abstraction." alt="" coords="29,6,83,34"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for AtomicType:</div>
<div class="dyncontent">
<div class="center"><img src="classAtomicType__coll__graph.png" border="0" usemap="#AtomicType_coll__map" alt="Collaboration graph"/></div>
<map name="AtomicType_coll__map" id="AtomicType_coll__map">
<area shape="rect" id="node2" href="classType.html" title="Interface class that defines the type abstraction." alt="" coords="5,99,59,127"/><area shape="rect" id="node4" href="structVariability.html" title="Variability" alt="" coords="84,99,175,127"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classAtomicType-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8">BasicType</a> { <br/>
&#160;&#160;<a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a21dcd6e5dbbe085f246fd4fa769d8807">TYPE_VOID</a>, 
<a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8accb27cd9e977f34cfab8583a6d76e1ae">TYPE_BOOL</a>, 
<a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a6ad6b5890e60ada74bb5ea61d3127c59">TYPE_INT8</a>, 
<a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a7379de3364345bdd8b35e52c33674d4a">TYPE_UINT8</a>, 
<br/>
&#160;&#160;<a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a13f725bbb76543669b6b1c42856f3be2">TYPE_INT16</a>, 
<a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a51920f987bfaa784ccdfa4b10439cc25">TYPE_UINT16</a>, 
<a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a00ab00a08272898bb6b864f11d254edb">TYPE_INT32</a>, 
<a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a6484104d64f48bf326c2779fc6a5a721">TYPE_UINT32</a>, 
<br/>
&#160;&#160;<a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a4b4c133976f4f56e639a2da34812d8c5">TYPE_FLOAT</a>, 
<a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8ae1d9efe8854a9c33eb59a4759c777233">TYPE_INT64</a>, 
<a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a972e12e27f2dfa1815a783d2eb7c9d8e">TYPE_UINT64</a>, 
<a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a0202569d2f7ba3efc4b2e8313ba8001f">TYPE_DOUBLE</a>, 
<br/>
&#160;&#160;<a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8acd2c6dcd635c236744ddc1589c10dccb">NUM_BASIC_TYPES</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVariability.html">Variability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a7e299cd168d4b2e8820e061d6643bd36">GetVariability</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#ad6ed98b78d1561bee7dffeb8f77a5ce3">IsBoolType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a2dcfce337e9ce0a0e3c749b0eb2e135f">IsFloatType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#af56b796c630a0bf50433a43ab46cb05b">IsIntType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a76f179b01685c3d41ce688a7f1baa912">IsUnsignedType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#af624e4674aa471c689550247ea6a5934">IsConstType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a49ebc38733592f94b6b58bc96757a0c6">GetBaseType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a7c18848484228e3f8524b2d62c1a218b">GetAsUniformType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#aa9f4455dfec5f9714315976603d29af9">GetAsVaryingType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a2ae86e66af57842c1e7504a92ed8acd3">GetAsUnboundVariabilityType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#af9d9ce6c4cf5bd8ddc6383a72a4c890d">GetAsSOAType</a> (int width) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a8c0195cef823dfa4d06db69149895acc">ResolveUnboundVariability</a> (<a class="el" href="structVariability.html">Variability</a> v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a5916f663a37b108719a93667e061ef7b">GetAsUnsignedType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a9ca2fda82352665890b1462ebf37ab44">GetAsConstType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a07f6d19eda86e0502144a73acd376623">GetAsNonConstType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#ae1c9926d0364ffd9041d98cf9e80c871">GetString</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#afc3a03de854dddee9c9d33fa53a6c757">Mangle</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a2265daea3aae05bc483bed01cb95bbde">GetCDeclaration</a> (const std::string &amp;name) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LLVM_TYPE_CONST llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a7c38ab920c31214ba5cf963c94e58f8e">LLVMType</a> (llvm::LLVMContext *ctx) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::DIType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#ad9578c90b6bf354eadcd11a2958cefcf">GetDIType</a> (llvm::DIDescriptor scope) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8">BasicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a513637c7273629ecc43425adc948ec5b">basicType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a4ea6e749bdc28ad68823ca2edc3bd37d">VaryingBool</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#affcc682326adef0c5ad307ac675d7be4">VaryingInt8</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a10a128dce461aaf7c9b4cb6c73eb20a8">VaryingInt16</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#ae112e2d3aaefd2a4035ce998e4c71ff3">VaryingInt32</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a909a12e11d4cd7199d5e45000d0b371c">VaryingUInt8</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a95ce8785b74c5d2fd3bd26a1db93cea8">VaryingUInt16</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a0f0ec8f289e2c824016d689987c6d774">VaryingUInt32</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a0071de02d88675b521285f25f4008c83">VaryingFloat</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a58a98c38cae3c592a6d79546fe07f6d1">VaryingInt64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#acab78bfdc4a1dfb1509bf747f04fd856">VaryingUInt64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a650ea00314faf8f7ee4f19fb8d5fe37d">VaryingDouble</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a339096fdcc4f3f30dcd30bbc9b46e212">UniformBool</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a6d27dcec3014e15f4ef64e80e05da85b">UniformInt8</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a3d6b267c6d1635dc85584003d93be6ca">UniformInt16</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#aee17c4dda27ab050f60af3c6070f3ccb">UniformInt32</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#ae98ae4be344a54e287b026a4c0bf3db1">UniformUInt8</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a47e0db1dc1b295c845ff2b9a5c7bc1d3">UniformUInt16</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#ae03bb38c60e05cef8ac0ac733ab38271">UniformUInt32</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a5ee406f291dc0cf6611f0ea0f23e8988">UniformFloat</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a80d55e131d76bbd7f828a8899190c428">UniformInt64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#aca427dd627e552a30e3c7216454b1b70">UniformUInt64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a1182126b2ce706563f986b5bf1801511">UniformDouble</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classAtomicType.html">AtomicType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a28a79cd7526ec38bf8ae805bfbb179f3">Void</a></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a> (<a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8">BasicType</a> <a class="el" href="classAtomicType.html#a513637c7273629ecc43425adc948ec5b">basicType</a>, <a class="el" href="structVariability.html">Variability</a> v, bool <a class="el" href="classAtomicType.html#a75f1720c3a5cabf341e6e84204d8f655">isConst</a>)</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structVariability.html">Variability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a1b925ca5706351acfa5ccf9db433ee77">variability</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAtomicType.html#a75f1720c3a5cabf341e6e84204d8f655">isConst</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classAtomicType.html" title="AtomicType represents basic types like floats, ints, etc.">AtomicType</a> represents basic types like floats, ints, etc. </p>
<p>AtomicTypes can be either uniform or varying. Unique instances of all of the possible <code><a class="el" href="classAtomicType.html" title="AtomicType represents basic types like floats, ints, etc.">AtomicType</a></code>s are available in the static members like <a class="el" href="classAtomicType.html#aee17c4dda27ab050f60af3c6070f3ccb">AtomicType::UniformInt32</a>. It is thus possible to compare AtomicTypes for equality with simple pointer equality tests; this is not true for the other <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> implementations. </p>

<p>Definition at line <a class="el" href="type_8h_source.html#l00245">245</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="aa4380202bca53e9468958ecfd601b3f8"></a><!-- doxytag: member="AtomicType::BasicType" ref="aa4380202bca53e9468958ecfd601b3f8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8">AtomicType::BasicType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This enumerator records the basic types that AtomicTypes can be built from. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa4380202bca53e9468958ecfd601b3f8a21dcd6e5dbbe085f246fd4fa769d8807"></a><!-- doxytag: member="TYPE_VOID" ref="aa4380202bca53e9468958ecfd601b3f8a21dcd6e5dbbe085f246fd4fa769d8807" args="" -->TYPE_VOID</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4380202bca53e9468958ecfd601b3f8accb27cd9e977f34cfab8583a6d76e1ae"></a><!-- doxytag: member="TYPE_BOOL" ref="aa4380202bca53e9468958ecfd601b3f8accb27cd9e977f34cfab8583a6d76e1ae" args="" -->TYPE_BOOL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4380202bca53e9468958ecfd601b3f8a6ad6b5890e60ada74bb5ea61d3127c59"></a><!-- doxytag: member="TYPE_INT8" ref="aa4380202bca53e9468958ecfd601b3f8a6ad6b5890e60ada74bb5ea61d3127c59" args="" -->TYPE_INT8</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4380202bca53e9468958ecfd601b3f8a7379de3364345bdd8b35e52c33674d4a"></a><!-- doxytag: member="TYPE_UINT8" ref="aa4380202bca53e9468958ecfd601b3f8a7379de3364345bdd8b35e52c33674d4a" args="" -->TYPE_UINT8</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4380202bca53e9468958ecfd601b3f8a13f725bbb76543669b6b1c42856f3be2"></a><!-- doxytag: member="TYPE_INT16" ref="aa4380202bca53e9468958ecfd601b3f8a13f725bbb76543669b6b1c42856f3be2" args="" -->TYPE_INT16</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4380202bca53e9468958ecfd601b3f8a51920f987bfaa784ccdfa4b10439cc25"></a><!-- doxytag: member="TYPE_UINT16" ref="aa4380202bca53e9468958ecfd601b3f8a51920f987bfaa784ccdfa4b10439cc25" args="" -->TYPE_UINT16</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4380202bca53e9468958ecfd601b3f8a00ab00a08272898bb6b864f11d254edb"></a><!-- doxytag: member="TYPE_INT32" ref="aa4380202bca53e9468958ecfd601b3f8a00ab00a08272898bb6b864f11d254edb" args="" -->TYPE_INT32</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4380202bca53e9468958ecfd601b3f8a6484104d64f48bf326c2779fc6a5a721"></a><!-- doxytag: member="TYPE_UINT32" ref="aa4380202bca53e9468958ecfd601b3f8a6484104d64f48bf326c2779fc6a5a721" args="" -->TYPE_UINT32</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4380202bca53e9468958ecfd601b3f8a4b4c133976f4f56e639a2da34812d8c5"></a><!-- doxytag: member="TYPE_FLOAT" ref="aa4380202bca53e9468958ecfd601b3f8a4b4c133976f4f56e639a2da34812d8c5" args="" -->TYPE_FLOAT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4380202bca53e9468958ecfd601b3f8ae1d9efe8854a9c33eb59a4759c777233"></a><!-- doxytag: member="TYPE_INT64" ref="aa4380202bca53e9468958ecfd601b3f8ae1d9efe8854a9c33eb59a4759c777233" args="" -->TYPE_INT64</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4380202bca53e9468958ecfd601b3f8a972e12e27f2dfa1815a783d2eb7c9d8e"></a><!-- doxytag: member="TYPE_UINT64" ref="aa4380202bca53e9468958ecfd601b3f8a972e12e27f2dfa1815a783d2eb7c9d8e" args="" -->TYPE_UINT64</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4380202bca53e9468958ecfd601b3f8a0202569d2f7ba3efc4b2e8313ba8001f"></a><!-- doxytag: member="TYPE_DOUBLE" ref="aa4380202bca53e9468958ecfd601b3f8a0202569d2f7ba3efc4b2e8313ba8001f" args="" -->TYPE_DOUBLE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4380202bca53e9468958ecfd601b3f8acd2c6dcd635c236744ddc1589c10dccb"></a><!-- doxytag: member="NUM_BASIC_TYPES" ref="aa4380202bca53e9468958ecfd601b3f8acd2c6dcd635c236744ddc1589c10dccb" args="" -->NUM_BASIC_TYPES</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="type_8h_source.html#l00277">277</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a280d855b37d6bf334c98c2767a4f50e9"></a><!-- doxytag: member="AtomicType::AtomicType" ref="a280d855b37d6bf334c98c2767a4f50e9" args="(BasicType basicType, Variability v, bool isConst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtomicType::AtomicType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8">BasicType</a>&#160;</td>
          <td class="paramname"><em>basicType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVariability.html">Variability</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isConst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00189">189</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l00259">GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l00268">GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l00310">GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l00301">GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l00292">GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l00235">GetAsUnsignedType()</a>, <a class="el" href="type_8cpp_source.html#l00283">GetAsVaryingType()</a>, and <a class="el" href="type_8cpp_source.html#l00319">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9ca2fda82352665890b1462ebf37ab44"></a><!-- doxytag: member="AtomicType::GetAsConstType" ref="a9ca2fda82352665890b1462ebf37ab44" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * AtomicType::GetAsConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a const version of this type. If it's already const, then the old <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> pointer is returned. </p>

<p>Implements <a class="el" href="classType.html#a91db376e89247992a5975936c5054eaa">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00259">259</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l00189">AtomicType()</a>, <a class="el" href="type_8h_source.html#l00293">basicType</a>, <a class="el" href="type_8cpp_source.html#l02977">Type::Equal()</a>, <a class="el" href="type_8h_source.html#l00310">isConst</a>, and <a class="el" href="type_8h_source.html#l00309">variability</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01601">VectorType::GetAsConstType()</a>.</p>

</div>
</div>
<a class="anchor" id="a07f6d19eda86e0502144a73acd376623"></a><!-- doxytag: member="AtomicType::GetAsNonConstType" ref="a07f6d19eda86e0502144a73acd376623" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * AtomicType::GetAsNonConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a non-const version of this type. If it's already not const, then the old <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> pointer is returned. </p>

<p>Implements <a class="el" href="classType.html#ad97d28e97d0955f6b19bb24dbfcc22bf">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00268">268</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l00189">AtomicType()</a>, <a class="el" href="type_8h_source.html#l00293">basicType</a>, <a class="el" href="type_8cpp_source.html#l02977">Type::Equal()</a>, <a class="el" href="type_8h_source.html#l00310">isConst</a>, and <a class="el" href="type_8h_source.html#l00309">variability</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01607">VectorType::GetAsNonConstType()</a>.</p>

</div>
</div>
<a class="anchor" id="af9d9ce6c4cf5bd8ddc6383a72a4c890d"></a><!-- doxytag: member="AtomicType::GetAsSOAType" ref="af9d9ce6c4cf5bd8ddc6383a72a4c890d" args="(int width) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * AtomicType::GetAsSOAType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classType.html#af3681d5c019998d033aec355d0157c54">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00310">310</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8cpp_source.html#l00189">AtomicType()</a>, <a class="el" href="type_8h_source.html#l00293">basicType</a>, <a class="el" href="type_8h_source.html#l00310">isConst</a>, <a class="el" href="type_8h_source.html#l00053">Variability::SOA</a>, and <a class="el" href="type_8h_source.html#l00309">variability</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01589">VectorType::GetAsSOAType()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ae86e66af57842c1e7504a92ed8acd3"></a><!-- doxytag: member="AtomicType::GetAsUnboundVariabilityType" ref="a2ae86e66af57842c1e7504a92ed8acd3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * AtomicType::GetAsUnboundVariabilityType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get an instance of the type with unbound variability. </p>

<p>Implements <a class="el" href="classType.html#a11499a547136ca713db16214f71ecbf2">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00301">301</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8cpp_source.html#l00189">AtomicType()</a>, <a class="el" href="type_8h_source.html#l00293">basicType</a>, <a class="el" href="type_8cpp_source.html#l02977">Type::Equal()</a>, <a class="el" href="type_8h_source.html#l00310">isConst</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Unbound</a>, and <a class="el" href="type_8h_source.html#l00309">variability</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01583">VectorType::GetAsUnboundVariabilityType()</a>, and <a class="el" href="decl_8cpp_source.html#l00130">DeclSpecs::GetBaseType()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c18848484228e3f8524b2d62c1a218b"></a><!-- doxytag: member="AtomicType::GetAsUniformType" ref="a7c18848484228e3f8524b2d62c1a218b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * AtomicType::GetAsUniformType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "uniform" instance of this type. If the type is already uniform, its "this" pointer will be returned. </p>

<p>Implements <a class="el" href="classType.html#ab0eff8692794d3437a91404c98985d20">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00292">292</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8cpp_source.html#l00189">AtomicType()</a>, <a class="el" href="type_8h_source.html#l00293">basicType</a>, <a class="el" href="type_8cpp_source.html#l02977">Type::Equal()</a>, <a class="el" href="type_8h_source.html#l00310">isConst</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Uniform</a>, and <a class="el" href="type_8h_source.html#l00309">variability</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01577">VectorType::GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l00462">GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l01717">VectorType::getVectorMemoryCount()</a>, and <a class="el" href="type_8cpp_source.html#l00422">LLVMType()</a>.</p>

</div>
</div>
<a class="anchor" id="a5916f663a37b108719a93667e061ef7b"></a><!-- doxytag: member="AtomicType::GetAsUnsignedType" ref="a5916f663a37b108719a93667e061ef7b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * AtomicType::GetAsUnsignedType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this is a signed integer type, return the unsigned version of the type. Otherwise, return the original type. </p>

<p>Reimplemented from <a class="el" href="classType.html#a127bfce35f03cb94bd25fbe07efb941a">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00235">235</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8cpp_source.html#l00189">AtomicType()</a>, <a class="el" href="type_8h_source.html#l00293">basicType</a>, <a class="el" href="util_8h_source.html#l00113">FATAL</a>, <a class="el" href="type_8h_source.html#l00310">isConst</a>, <a class="el" href="type_8cpp_source.html#l00207">IsIntType()</a>, <a class="el" href="type_8cpp_source.html#l00216">IsUnsignedType()</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="type_8h_source.html#l00282">TYPE_INT16</a>, <a class="el" href="type_8h_source.html#l00284">TYPE_INT32</a>, <a class="el" href="type_8h_source.html#l00287">TYPE_INT64</a>, <a class="el" href="type_8h_source.html#l00280">TYPE_INT8</a>, <a class="el" href="type_8h_source.html#l00283">TYPE_UINT16</a>, <a class="el" href="type_8h_source.html#l00285">TYPE_UINT32</a>, <a class="el" href="type_8h_source.html#l00288">TYPE_UINT64</a>, <a class="el" href="type_8h_source.html#l00281">TYPE_UINT8</a>, and <a class="el" href="type_8h_source.html#l00309">variability</a>.</p>

</div>
</div>
<a class="anchor" id="aa9f4455dfec5f9714315976603d29af9"></a><!-- doxytag: member="AtomicType::GetAsVaryingType" ref="aa9f4455dfec5f9714315976603d29af9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * AtomicType::GetAsVaryingType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "varying" instance of this type. If the type is already varying, its "this" pointer will be returned. </p>

<p>Implements <a class="el" href="classType.html#aedfa3c719db7ab073c5e1f75b4041e55">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00283">283</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8cpp_source.html#l00189">AtomicType()</a>, <a class="el" href="type_8h_source.html#l00293">basicType</a>, <a class="el" href="type_8cpp_source.html#l02977">Type::Equal()</a>, <a class="el" href="type_8h_source.html#l00310">isConst</a>, <a class="el" href="type_8h_source.html#l00309">variability</a>, and <a class="el" href="type_8h_source.html#l00053">Variability::Varying</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01571">VectorType::GetAsVaryingType()</a>.</p>

</div>
</div>
<a class="anchor" id="a49ebc38733592f94b6b58bc96757a0c6"></a><!-- doxytag: member="AtomicType::GetBaseType" ref="a49ebc38733592f94b6b58bc96757a0c6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * AtomicType::GetBaseType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For AtomicTypes, the base type is just the same as the <a class="el" href="classAtomicType.html" title="AtomicType represents basic types like floats, ints, etc.">AtomicType</a> itself. </p>

<p>Implements <a class="el" href="classType.html#a51af28faf17eb05982547d9b340429eb">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00277">277</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2265daea3aae05bc483bed01cb95bbde"></a><!-- doxytag: member="AtomicType::GetCDeclaration" ref="a2265daea3aae05bc483bed01cb95bbde" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string AtomicType::GetCDeclaration </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a string that is the declaration of the same type in C syntax. </p>

<p>Implements <a class="el" href="classType.html#a7e35141766bbc63333953263cd85d883">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00381">381</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8h_source.html#l00293">basicType</a>, <a class="el" href="module_8h_source.html#l00129">Module::errorCount</a>, <a class="el" href="util_8h_source.html#l00113">FATAL</a>, <a class="el" href="type_8h_source.html#l00310">isConst</a>, <a class="el" href="type_8cpp_source.html#l00059">lShouldPrintName()</a>, <a class="el" href="ispc_8cpp_source.html#l00068">m</a>, <a class="el" href="type_8h_source.html#l00053">Variability::SOA</a>, <a class="el" href="type_8h_source.html#l00071">Variability::soaWidth</a>, <a class="el" href="type_8h_source.html#l00279">TYPE_BOOL</a>, <a class="el" href="type_8h_source.html#l00289">TYPE_DOUBLE</a>, <a class="el" href="type_8h_source.html#l00286">TYPE_FLOAT</a>, <a class="el" href="type_8h_source.html#l00282">TYPE_INT16</a>, <a class="el" href="type_8h_source.html#l00284">TYPE_INT32</a>, <a class="el" href="type_8h_source.html#l00287">TYPE_INT64</a>, <a class="el" href="type_8h_source.html#l00280">TYPE_INT8</a>, <a class="el" href="type_8h_source.html#l00283">TYPE_UINT16</a>, <a class="el" href="type_8h_source.html#l00285">TYPE_UINT32</a>, <a class="el" href="type_8h_source.html#l00288">TYPE_UINT64</a>, <a class="el" href="type_8h_source.html#l00281">TYPE_UINT8</a>, <a class="el" href="type_8h_source.html#l00278">TYPE_VOID</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Uniform</a>, and <a class="el" href="type_8h_source.html#l00309">variability</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01631">VectorType::GetCDeclaration()</a>.</p>

</div>
</div>
<a class="anchor" id="ad9578c90b6bf354eadcd11a2958cefcf"></a><!-- doxytag: member="AtomicType::GetDIType" ref="ad9578c90b6bf354eadcd11a2958cefcf" args="(llvm::DIDescriptor scope) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::DIType AtomicType::GetDIType </td>
          <td>(</td>
          <td class="paramtype">llvm::DIDescriptor&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the DIType (LLVM's debugging information structure), corresponding to this type. </p>

<p>Implements <a class="el" href="classType.html#a8b6ded269378020c769915bbbff3d73c">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00462">462</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8h_source.html#l00293">basicType</a>, <a class="el" href="module_8h_source.html#l00139">Module::diBuilder</a>, <a class="el" href="util_8h_source.html#l00113">FATAL</a>, <a class="el" href="ispc_8cpp_source.html#l00067">g</a>, <a class="el" href="type_8cpp_source.html#l00292">GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l00462">GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l01442">ArrayType::GetDIType()</a>, <a class="el" href="ispc_8cpp_source.html#l00068">m</a>, <a class="el" href="type_8h_source.html#l00053">Variability::SOA</a>, <a class="el" href="type_8h_source.html#l00071">Variability::soaWidth</a>, <a class="el" href="ispc_8h_source.html#l00365">Globals::target</a>, <a class="el" href="type_8h_source.html#l00070">Variability::type</a>, <a class="el" href="type_8h_source.html#l00279">TYPE_BOOL</a>, <a class="el" href="type_8h_source.html#l00289">TYPE_DOUBLE</a>, <a class="el" href="type_8h_source.html#l00286">TYPE_FLOAT</a>, <a class="el" href="type_8h_source.html#l00282">TYPE_INT16</a>, <a class="el" href="type_8h_source.html#l00284">TYPE_INT32</a>, <a class="el" href="type_8h_source.html#l00287">TYPE_INT64</a>, <a class="el" href="type_8h_source.html#l00280">TYPE_INT8</a>, <a class="el" href="type_8h_source.html#l00283">TYPE_UINT16</a>, <a class="el" href="type_8h_source.html#l00285">TYPE_UINT32</a>, <a class="el" href="type_8h_source.html#l00288">TYPE_UINT64</a>, <a class="el" href="type_8h_source.html#l00281">TYPE_UINT8</a>, <a class="el" href="type_8h_source.html#l00278">TYPE_VOID</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Unbound</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Uniform</a>, <a class="el" href="type_8h_source.html#l00309">variability</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Varying</a>, and <a class="el" href="ispc_8h_source.html#l00228">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l00462">GetDIType()</a>, and <a class="el" href="type_8cpp_source.html#l01684">VectorType::GetDIType()</a>.</p>

</div>
</div>
<a class="anchor" id="ae1c9926d0364ffd9041d98cf9e80c871"></a><!-- doxytag: member="AtomicType::GetString" ref="ae1c9926d0364ffd9041d98cf9e80c871" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string AtomicType::GetString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a text representation of the type (for example, for use in warning and error messages). </p>

<p>Implements <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00328">328</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00293">basicType</a>, <a class="el" href="util_8h_source.html#l00113">FATAL</a>, <a class="el" href="type_8cpp_source.html#l00101">Variability::GetString()</a>, <a class="el" href="type_8h_source.html#l00310">isConst</a>, <a class="el" href="type_8h_source.html#l00279">TYPE_BOOL</a>, <a class="el" href="type_8h_source.html#l00289">TYPE_DOUBLE</a>, <a class="el" href="type_8h_source.html#l00286">TYPE_FLOAT</a>, <a class="el" href="type_8h_source.html#l00282">TYPE_INT16</a>, <a class="el" href="type_8h_source.html#l00284">TYPE_INT32</a>, <a class="el" href="type_8h_source.html#l00287">TYPE_INT64</a>, <a class="el" href="type_8h_source.html#l00280">TYPE_INT8</a>, <a class="el" href="type_8h_source.html#l00283">TYPE_UINT16</a>, <a class="el" href="type_8h_source.html#l00285">TYPE_UINT32</a>, <a class="el" href="type_8h_source.html#l00288">TYPE_UINT64</a>, <a class="el" href="type_8h_source.html#l00281">TYPE_UINT8</a>, <a class="el" href="type_8h_source.html#l00278">TYPE_VOID</a>, and <a class="el" href="type_8h_source.html#l00309">variability</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01613">VectorType::GetString()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e299cd168d4b2e8820e061d6643bd36"></a><!-- doxytag: member="AtomicType::GetVariability" ref="a7e299cd168d4b2e8820e061d6643bd36" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVariability.html">Variability</a> AtomicType::GetVariability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the variability of the type. </p>

<p>Implements <a class="el" href="classType.html#a619effc9d2d2517bd884076eb9559b65">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00195">195</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00309">variability</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01529">VectorType::GetVariability()</a>, and <a class="el" href="type_8cpp_source.html#l02870">lCheckTypeEquality()</a>.</p>

</div>
</div>
<a class="anchor" id="ad6ed98b78d1561bee7dffeb8f77a5ce3"></a><!-- doxytag: member="AtomicType::IsBoolType" ref="ad6ed98b78d1561bee7dffeb8f77a5ce3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AtomicType::IsBoolType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is boolean. In other words, this is true for individual bools and for short-vectors with underlying bool type, but not for arrays of bools. </p>

<p>Implements <a class="el" href="classType.html#a38ff6178597171c11f6e24566b251dea">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00223">223</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00293">basicType</a>, and <a class="el" href="type_8h_source.html#l00279">TYPE_BOOL</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01553">VectorType::IsBoolType()</a>.</p>

</div>
</div>
<a class="anchor" id="af624e4674aa471c689550247ea6a5934"></a><!-- doxytag: member="AtomicType::IsConstType" ref="af624e4674aa471c689550247ea6a5934" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AtomicType::IsConstType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if this type is 'const'-qualified. </p>

<p>Implements <a class="el" href="classType.html#a9a6d77fb89abc534e2ee1726cc13cf05">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00229">229</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00310">isConst</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01559">VectorType::IsConstType()</a>.</p>

</div>
</div>
<a class="anchor" id="a2dcfce337e9ce0a0e3c749b0eb2e135f"></a><!-- doxytag: member="AtomicType::IsFloatType" ref="a2dcfce337e9ce0a0e3c749b0eb2e135f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AtomicType::IsFloatType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is float or double. In other words, this is true for individual floats/doubles and for short-vectors of them, but not for arrays of them. </p>

<p>Implements <a class="el" href="classType.html#aeee9fe8b11fc75a300cf37f8b5c9f034">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00201">201</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00293">basicType</a>, <a class="el" href="type_8h_source.html#l00289">TYPE_DOUBLE</a>, and <a class="el" href="type_8h_source.html#l00286">TYPE_FLOAT</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01535">VectorType::IsFloatType()</a>.</p>

</div>
</div>
<a class="anchor" id="af56b796c630a0bf50433a43ab46cb05b"></a><!-- doxytag: member="AtomicType::IsIntType" ref="af56b796c630a0bf50433a43ab46cb05b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AtomicType::IsIntType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is an integer type. In other words, this is true for individual integers and for short-vectors of integer types, but not for arrays of integer types. </p>

<p>Implements <a class="el" href="classType.html#a3b2b570093e27170d582b67211dd6836">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00207">207</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00293">basicType</a>, <a class="el" href="type_8h_source.html#l00282">TYPE_INT16</a>, <a class="el" href="type_8h_source.html#l00284">TYPE_INT32</a>, <a class="el" href="type_8h_source.html#l00287">TYPE_INT64</a>, <a class="el" href="type_8h_source.html#l00280">TYPE_INT8</a>, <a class="el" href="type_8h_source.html#l00283">TYPE_UINT16</a>, <a class="el" href="type_8h_source.html#l00285">TYPE_UINT32</a>, <a class="el" href="type_8h_source.html#l00288">TYPE_UINT64</a>, and <a class="el" href="type_8h_source.html#l00281">TYPE_UINT8</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l00235">GetAsUnsignedType()</a>, <a class="el" href="type_8cpp_source.html#l01541">VectorType::IsIntType()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, and <a class="el" href="expr_8cpp_source.html#l06615">TypeCastExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a76f179b01685c3d41ce688a7f1baa912"></a><!-- doxytag: member="AtomicType::IsUnsignedType" ref="a76f179b01685c3d41ce688a7f1baa912" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AtomicType::IsUnsignedType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is unsigned. In other words, this is true for unsigned integers and short vectors of unsigned integer types. </p>

<p>Implements <a class="el" href="classType.html#a9fb5648ec4eb5b432723cf0b3332f8d0">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00216">216</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00293">basicType</a>, <a class="el" href="type_8h_source.html#l00283">TYPE_UINT16</a>, <a class="el" href="type_8h_source.html#l00285">TYPE_UINT32</a>, <a class="el" href="type_8h_source.html#l00288">TYPE_UINT64</a>, and <a class="el" href="type_8h_source.html#l00281">TYPE_UINT8</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l00235">GetAsUnsignedType()</a>, and <a class="el" href="type_8cpp_source.html#l01547">VectorType::IsUnsignedType()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c38ab920c31214ba5cf963c94e58f8e"></a><!-- doxytag: member="AtomicType::LLVMType" ref="a7c38ab920c31214ba5cf963c94e58f8e" args="(llvm::LLVMContext *ctx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_TYPE_CONST llvm::Type * AtomicType::LLVMType </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the LLVM type corresponding to this ispc type </p>

<p>Implements <a class="el" href="classType.html#aa7b08bf258938faa7e12b580b623621a">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00422">422</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8h_source.html#l00293">basicType</a>, <a class="el" href="llvmutil_8h_source.html#l00067">LLVMTypes::BoolType</a>, <a class="el" href="llvmutil_8h_source.html#l00085">LLVMTypes::BoolVectorType</a>, <a class="el" href="llvmutil_8h_source.html#l00074">LLVMTypes::DoubleType</a>, <a class="el" href="llvmutil_8h_source.html#l00092">LLVMTypes::DoubleVectorType</a>, <a class="el" href="util_8h_source.html#l00113">FATAL</a>, <a class="el" href="llvmutil_8h_source.html#l00073">LLVMTypes::FloatType</a>, <a class="el" href="llvmutil_8h_source.html#l00091">LLVMTypes::FloatVectorType</a>, <a class="el" href="type_8cpp_source.html#l00292">GetAsUniformType()</a>, <a class="el" href="llvmutil_8h_source.html#l00070">LLVMTypes::Int16Type</a>, <a class="el" href="llvmutil_8h_source.html#l00088">LLVMTypes::Int16VectorType</a>, <a class="el" href="llvmutil_8h_source.html#l00071">LLVMTypes::Int32Type</a>, <a class="el" href="llvmutil_8h_source.html#l00089">LLVMTypes::Int32VectorType</a>, <a class="el" href="llvmutil_8h_source.html#l00072">LLVMTypes::Int64Type</a>, <a class="el" href="llvmutil_8h_source.html#l00090">LLVMTypes::Int64VectorType</a>, <a class="el" href="llvmutil_8h_source.html#l00069">LLVMTypes::Int8Type</a>, <a class="el" href="llvmutil_8h_source.html#l00087">LLVMTypes::Int8VectorType</a>, <a class="el" href="type_8cpp_source.html#l01200">ArrayType::LLVMType()</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="type_8h_source.html#l00071">Variability::soaWidth</a>, <a class="el" href="type_8h_source.html#l00070">Variability::type</a>, <a class="el" href="type_8h_source.html#l00279">TYPE_BOOL</a>, <a class="el" href="type_8h_source.html#l00289">TYPE_DOUBLE</a>, <a class="el" href="type_8h_source.html#l00286">TYPE_FLOAT</a>, <a class="el" href="type_8h_source.html#l00282">TYPE_INT16</a>, <a class="el" href="type_8h_source.html#l00284">TYPE_INT32</a>, <a class="el" href="type_8h_source.html#l00287">TYPE_INT64</a>, <a class="el" href="type_8h_source.html#l00280">TYPE_INT8</a>, <a class="el" href="type_8h_source.html#l00283">TYPE_UINT16</a>, <a class="el" href="type_8h_source.html#l00285">TYPE_UINT32</a>, <a class="el" href="type_8h_source.html#l00288">TYPE_UINT64</a>, <a class="el" href="type_8h_source.html#l00281">TYPE_UINT8</a>, <a class="el" href="type_8h_source.html#l00278">TYPE_VOID</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Unbound</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Uniform</a>, <a class="el" href="type_8h_source.html#l00309">variability</a>, and <a class="el" href="type_8h_source.html#l00053">Variability::Varying</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01652">VectorType::LLVMType()</a>.</p>

</div>
</div>
<a class="anchor" id="afc3a03de854dddee9c9d33fa53a6c757"></a><!-- doxytag: member="AtomicType::Mangle" ref="afc3a03de854dddee9c9d33fa53a6c757" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string AtomicType::Mangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a string that represents the mangled type (for use in mangling function symbol names for function overloading). The various Types implementations of this method should collectively ensure that all of them use mangling schemes that are guaranteed not to clash. </p>

<p>Implements <a class="el" href="classType.html#a7bd23bd909d493d271dbe1024d212c06">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00356">356</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00293">basicType</a>, <a class="el" href="util_8h_source.html#l00113">FATAL</a>, <a class="el" href="type_8h_source.html#l00310">isConst</a>, <a class="el" href="type_8cpp_source.html#l00119">Variability::MangleString()</a>, <a class="el" href="type_8h_source.html#l00279">TYPE_BOOL</a>, <a class="el" href="type_8h_source.html#l00289">TYPE_DOUBLE</a>, <a class="el" href="type_8h_source.html#l00286">TYPE_FLOAT</a>, <a class="el" href="type_8h_source.html#l00282">TYPE_INT16</a>, <a class="el" href="type_8h_source.html#l00284">TYPE_INT32</a>, <a class="el" href="type_8h_source.html#l00287">TYPE_INT64</a>, <a class="el" href="type_8h_source.html#l00280">TYPE_INT8</a>, <a class="el" href="type_8h_source.html#l00283">TYPE_UINT16</a>, <a class="el" href="type_8h_source.html#l00285">TYPE_UINT32</a>, <a class="el" href="type_8h_source.html#l00288">TYPE_UINT64</a>, <a class="el" href="type_8h_source.html#l00281">TYPE_UINT8</a>, <a class="el" href="type_8h_source.html#l00278">TYPE_VOID</a>, and <a class="el" href="type_8h_source.html#l00309">variability</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01622">VectorType::Mangle()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c0195cef823dfa4d06db69149895acc"></a><!-- doxytag: member="AtomicType::ResolveUnboundVariability" ref="a8c0195cef823dfa4d06db69149895acc" args="(Variability v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * AtomicType::ResolveUnboundVariability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVariability.html">Variability</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classType.html#adced497622fac125548ef5531495c738">Type</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l00319">319</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00061">Assert</a>, <a class="el" href="type_8cpp_source.html#l00189">AtomicType()</a>, <a class="el" href="type_8h_source.html#l00293">basicType</a>, <a class="el" href="type_8h_source.html#l00310">isConst</a>, <a class="el" href="type_8h_source.html#l00053">Variability::Unbound</a>, and <a class="el" href="type_8h_source.html#l00309">variability</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01595">VectorType::ResolveUnboundVariability()</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a513637c7273629ecc43425adc948ec5b"></a><!-- doxytag: member="AtomicType::basicType" ref="a513637c7273629ecc43425adc948ec5b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8">BasicType</a> <a class="el" href="classAtomicType.html#a513637c7273629ecc43425adc948ec5b">AtomicType::basicType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8h_source.html#l00293">293</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l00259">GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l00268">GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l00310">GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l00301">GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l00292">GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l00235">GetAsUnsignedType()</a>, <a class="el" href="type_8cpp_source.html#l00283">GetAsVaryingType()</a>, <a class="el" href="expr_8cpp_source.html#l05202">ConstExpr::getBasicType()</a>, <a class="el" href="type_8cpp_source.html#l00381">GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l00462">GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l00328">GetString()</a>, <a class="el" href="type_8cpp_source.html#l00223">IsBoolType()</a>, <a class="el" href="type_8cpp_source.html#l00201">IsFloatType()</a>, <a class="el" href="type_8cpp_source.html#l00207">IsIntType()</a>, <a class="el" href="type_8cpp_source.html#l00216">IsUnsignedType()</a>, <a class="el" href="type_8cpp_source.html#l02870">lCheckTypeEquality()</a>, <a class="el" href="expr_8cpp_source.html#l07523">lIsMatchWithTypeWidening()</a>, <a class="el" href="expr_8cpp_source.html#l00817">lLLVMConstantValue()</a>, <a class="el" href="type_8cpp_source.html#l00422">LLVMType()</a>, <a class="el" href="expr_8cpp_source.html#l05772">lTypeConvAtomic()</a>, <a class="el" href="type_8cpp_source.html#l00356">Mangle()</a>, <a class="el" href="type_8cpp_source.html#l02694">Type::MoreGeneralType()</a>, <a class="el" href="expr_8cpp_source.html#l06688">TypeCastExpr::Optimize()</a>, <a class="el" href="type_8cpp_source.html#l00319">ResolveUnboundVariability()</a>, and <a class="el" href="expr_8cpp_source.html#l06615">TypeCastExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a75f1720c3a5cabf341e6e84204d8f655"></a><!-- doxytag: member="AtomicType::isConst" ref="a75f1720c3a5cabf341e6e84204d8f655" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classAtomicType.html#a75f1720c3a5cabf341e6e84204d8f655">AtomicType::isConst</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8h_source.html#l00310">310</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l00259">GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l00268">GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l00310">GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l00301">GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l00292">GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l00235">GetAsUnsignedType()</a>, <a class="el" href="type_8cpp_source.html#l00283">GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l00381">GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l00328">GetString()</a>, <a class="el" href="type_8cpp_source.html#l00229">IsConstType()</a>, <a class="el" href="type_8cpp_source.html#l00356">Mangle()</a>, and <a class="el" href="type_8cpp_source.html#l00319">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="a339096fdcc4f3f30dcd30bbc9b46e212"></a><!-- doxytag: member="AtomicType::UniformBool" ref="a339096fdcc4f3f30dcd30bbc9b46e212" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#a339096fdcc4f3f30dcd30bbc9b46e212">AtomicType::UniformBool</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8accb27cd9e977f34cfab8583a6d76e1ae">AtomicType::TYPE_BOOL</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a489d62b409bc3a0793202b0a43758e62">Variability::Uniform</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00295">295</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l05080">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l02939">SelectExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l02011">lConstFoldBinLogicalOp()</a>, <a class="el" href="stmt_8cpp_source.html#l02437">lEncodeType()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="expr_8cpp_source.html#l00799">lMatchingBoolType()</a>, <a class="el" href="expr_8cpp_source.html#l01145">UnaryExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l02093">BinaryExpr::Optimize()</a>, <a class="el" href="stmt_8cpp_source.html#l00424">IfStmt::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l00897">DoStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02238">BinaryExpr::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l01098">ForStmt::TypeCheck()</a>, and <a class="el" href="stmt_8cpp_source.html#l02672">AssertStmt::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a1182126b2ce706563f986b5bf1801511"></a><!-- doxytag: member="AtomicType::UniformDouble" ref="a1182126b2ce706563f986b5bf1801511" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#a1182126b2ce706563f986b5bf1801511">AtomicType::UniformDouble</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a0202569d2f7ba3efc4b2e8313ba8001f">AtomicType::TYPE_DOUBLE</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a489d62b409bc3a0793202b0a43758e62">Variability::Uniform</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00305">305</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l05060">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="stmt_8cpp_source.html#l02437">lEncodeType()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, and <a class="el" href="expr_8cpp_source.html#l02093">BinaryExpr::Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ee406f291dc0cf6611f0ea0f23e8988"></a><!-- doxytag: member="AtomicType::UniformFloat" ref="a5ee406f291dc0cf6611f0ea0f23e8988" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#a5ee406f291dc0cf6611f0ea0f23e8988">AtomicType::UniformFloat</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a4b4c133976f4f56e639a2da34812d8c5">AtomicType::TYPE_FLOAT</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a489d62b409bc3a0793202b0a43758e62">Variability::Uniform</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00302">302</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l05000">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="stmt_8cpp_source.html#l02437">lEncodeType()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, and <a class="el" href="expr_8cpp_source.html#l02093">BinaryExpr::Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a3d6b267c6d1635dc85584003d93be6ca"></a><!-- doxytag: member="AtomicType::UniformInt16" ref="a3d6b267c6d1635dc85584003d93be6ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#a3d6b267c6d1635dc85584003d93be6ca">AtomicType::UniformInt16</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a13f725bbb76543669b6b1c42856f3be2">AtomicType::TYPE_INT16</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a489d62b409bc3a0793202b0a43758e62">Variability::Uniform</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00297">297</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l04917">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="stmt_8cpp_source.html#l02467">lProcessPrintArg()</a>, and <a class="el" href="expr_8cpp_source.html#l01145">UnaryExpr::Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="aee17c4dda27ab050f60af3c6070f3ccb"></a><!-- doxytag: member="AtomicType::UniformInt32" ref="aee17c4dda27ab050f60af3c6070f3ccb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#aee17c4dda27ab050f60af3c6070f3ccb">AtomicType::UniformInt32</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a00ab00a08272898bb6b864f11d254edb">AtomicType::TYPE_INT32</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a489d62b409bc3a0793202b0a43758e62">Variability::Uniform</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00298">298</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l04957">ConstExpr::ConstExpr()</a>, <a class="el" href="stmt_8cpp_source.html#l02793">CreateForeachActiveStmt()</a>, <a class="el" href="decl_8cpp_source.html#l00130">DeclSpecs::GetBaseType()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l01900">BinaryExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l00149">lArrayToPointer()</a>, <a class="el" href="builtins_8cpp_source.html#l00640">lDefineConstantInt()</a>, <a class="el" href="builtins_8cpp_source.html#l00657">lDefineConstantIntFunc()</a>, <a class="el" href="expr_8cpp_source.html#l00989">lEmitPrePostIncDec()</a>, <a class="el" href="stmt_8cpp_source.html#l02437">lEncodeType()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="stmt_8cpp_source.html#l02467">lProcessPrintArg()</a>, <a class="el" href="expr_8cpp_source.html#l01145">UnaryExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l02093">BinaryExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l02238">BinaryExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02760">AssignExpr::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l01803">ForeachStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l03420">FunctionCallExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l04192">IndexExpr::TypeCheck()</a>, and <a class="el" href="stmt_8cpp_source.html#l02149">SwitchStmt::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a80d55e131d76bbd7f828a8899190c428"></a><!-- doxytag: member="AtomicType::UniformInt64" ref="a80d55e131d76bbd7f828a8899190c428" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#a80d55e131d76bbd7f828a8899190c428">AtomicType::UniformInt64</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8ae1d9efe8854a9c33eb59a4759c777233">AtomicType::TYPE_INT64</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a489d62b409bc3a0793202b0a43758e62">Variability::Uniform</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00303">303</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l05020">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l01900">BinaryExpr::GetType()</a>, <a class="el" href="stmt_8cpp_source.html#l02437">lEncodeType()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="expr_8cpp_source.html#l01145">UnaryExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l02238">BinaryExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02760">AssignExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l04192">IndexExpr::TypeCheck()</a>, and <a class="el" href="stmt_8cpp_source.html#l02149">SwitchStmt::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d27dcec3014e15f4ef64e80e05da85b"></a><!-- doxytag: member="AtomicType::UniformInt8" ref="a6d27dcec3014e15f4ef64e80e05da85b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#a6d27dcec3014e15f4ef64e80e05da85b">AtomicType::UniformInt8</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a6ad6b5890e60ada74bb5ea61d3127c59">AtomicType::TYPE_INT8</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a489d62b409bc3a0793202b0a43758e62">Variability::Uniform</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00296">296</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l04877">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="stmt_8cpp_source.html#l02467">lProcessPrintArg()</a>, and <a class="el" href="expr_8cpp_source.html#l01145">UnaryExpr::Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a47e0db1dc1b295c845ff2b9a5c7bc1d3"></a><!-- doxytag: member="AtomicType::UniformUInt16" ref="a47e0db1dc1b295c845ff2b9a5c7bc1d3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#a47e0db1dc1b295c845ff2b9a5c7bc1d3">AtomicType::UniformUInt16</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a51920f987bfaa784ccdfa4b10439cc25">AtomicType::TYPE_UINT16</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a489d62b409bc3a0793202b0a43758e62">Variability::Uniform</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00300">300</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l04937">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="stmt_8cpp_source.html#l02467">lProcessPrintArg()</a>, and <a class="el" href="expr_8cpp_source.html#l01145">UnaryExpr::Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="ae03bb38c60e05cef8ac0ac733ab38271"></a><!-- doxytag: member="AtomicType::UniformUInt32" ref="ae03bb38c60e05cef8ac0ac733ab38271" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#ae03bb38c60e05cef8ac0ac733ab38271">AtomicType::UniformUInt32</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a6484104d64f48bf326c2779fc6a5a721">AtomicType::TYPE_UINT32</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a489d62b409bc3a0793202b0a43758e62">Variability::Uniform</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00301">301</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l04977">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l07273">SizeOfExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l06313">TypeCastExpr::GetValue()</a>, <a class="el" href="stmt_8cpp_source.html#l02437">lEncodeType()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="expr_8cpp_source.html#l01145">UnaryExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l02093">BinaryExpr::Optimize()</a>, and <a class="el" href="expr_8cpp_source.html#l08054">NewExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="aca427dd627e552a30e3c7216454b1b70"></a><!-- doxytag: member="AtomicType::UniformUInt64" ref="aca427dd627e552a30e3c7216454b1b70" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#aca427dd627e552a30e3c7216454b1b70">AtomicType::UniformUInt64</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a972e12e27f2dfa1815a783d2eb7c9d8e">AtomicType::TYPE_UINT64</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a489d62b409bc3a0793202b0a43758e62">Variability::Uniform</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00304">304</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l05040">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l07273">SizeOfExpr::GetType()</a>, <a class="el" href="stmt_8cpp_source.html#l02437">lEncodeType()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="expr_8cpp_source.html#l01145">UnaryExpr::Optimize()</a>, <a class="el" href="stmt_8cpp_source.html#l02149">SwitchStmt::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l08054">NewExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="ae98ae4be344a54e287b026a4c0bf3db1"></a><!-- doxytag: member="AtomicType::UniformUInt8" ref="ae98ae4be344a54e287b026a4c0bf3db1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#ae98ae4be344a54e287b026a4c0bf3db1">AtomicType::UniformUInt8</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a7379de3364345bdd8b35e52c33674d4a">AtomicType::TYPE_UINT8</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a489d62b409bc3a0793202b0a43758e62">Variability::Uniform</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00299">299</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l04897">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="stmt_8cpp_source.html#l02467">lProcessPrintArg()</a>, and <a class="el" href="expr_8cpp_source.html#l01145">UnaryExpr::Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a1b925ca5706351acfa5ccf9db433ee77"></a><!-- doxytag: member="AtomicType::variability" ref="a1b925ca5706351acfa5ccf9db433ee77" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structVariability.html">Variability</a> <a class="el" href="classAtomicType.html#a1b925ca5706351acfa5ccf9db433ee77">AtomicType::variability</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="type_8h_source.html#l00309">309</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l00259">GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l00268">GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l00310">GetAsSOAType()</a>, <a class="el" href="type_8cpp_source.html#l00301">GetAsUnboundVariabilityType()</a>, <a class="el" href="type_8cpp_source.html#l00292">GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l00235">GetAsUnsignedType()</a>, <a class="el" href="type_8cpp_source.html#l00283">GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l00381">GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l00462">GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l00328">GetString()</a>, <a class="el" href="type_8cpp_source.html#l00195">GetVariability()</a>, <a class="el" href="type_8cpp_source.html#l00422">LLVMType()</a>, <a class="el" href="type_8cpp_source.html#l00356">Mangle()</a>, and <a class="el" href="type_8cpp_source.html#l00319">ResolveUnboundVariability()</a>.</p>

</div>
</div>
<a class="anchor" id="a4ea6e749bdc28ad68823ca2edc3bd37d"></a><!-- doxytag: member="AtomicType::VaryingBool" ref="a4ea6e749bdc28ad68823ca2edc3bd37d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#a4ea6e749bdc28ad68823ca2edc3bd37d">AtomicType::VaryingBool</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8accb27cd9e977f34cfab8583a6d76e1ae">AtomicType::TYPE_BOOL</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a3fbef7594ed5b2a737aaa0f9b325a940">Variability::Varying</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00295">295</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l05089">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l02939">SelectExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l02011">lConstFoldBinLogicalOp()</a>, <a class="el" href="builtins_8cpp_source.html#l00182">lCreateISPCSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l01598">lEmitLogicalOp()</a>, <a class="el" href="stmt_8cpp_source.html#l02437">lEncodeType()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="expr_8cpp_source.html#l00799">lMatchingBoolType()</a>, <a class="el" href="ctx_8cpp_source.html#l02596">FunctionEmitContext::maskedStore()</a>, <a class="el" href="expr_8cpp_source.html#l01145">UnaryExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l02093">BinaryExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l03101">SelectExpr::Optimize()</a>, <a class="el" href="stmt_8cpp_source.html#l00424">IfStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02238">BinaryExpr::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l00897">DoStmt::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l01098">ForStmt::TypeCheck()</a>, and <a class="el" href="stmt_8cpp_source.html#l02672">AssertStmt::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a650ea00314faf8f7ee4f19fb8d5fe37d"></a><!-- doxytag: member="AtomicType::VaryingDouble" ref="a650ea00314faf8f7ee4f19fb8d5fe37d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#a650ea00314faf8f7ee4f19fb8d5fe37d">AtomicType::VaryingDouble</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a0202569d2f7ba3efc4b2e8313ba8001f">AtomicType::TYPE_DOUBLE</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a3fbef7594ed5b2a737aaa0f9b325a940">Variability::Varying</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00305">305</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l05069">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="stmt_8cpp_source.html#l02437">lEncodeType()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="ctx_8cpp_source.html#l02596">FunctionEmitContext::maskedStore()</a>, <a class="el" href="expr_8cpp_source.html#l02093">BinaryExpr::Optimize()</a>, and <a class="el" href="expr_8cpp_source.html#l03101">SelectExpr::Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a0071de02d88675b521285f25f4008c83"></a><!-- doxytag: member="AtomicType::VaryingFloat" ref="a0071de02d88675b521285f25f4008c83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#a0071de02d88675b521285f25f4008c83">AtomicType::VaryingFloat</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a4b4c133976f4f56e639a2da34812d8c5">AtomicType::TYPE_FLOAT</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a3fbef7594ed5b2a737aaa0f9b325a940">Variability::Varying</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00302">302</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l05009">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="stmt_8cpp_source.html#l02437">lEncodeType()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="ctx_8cpp_source.html#l02596">FunctionEmitContext::maskedStore()</a>, <a class="el" href="expr_8cpp_source.html#l02093">BinaryExpr::Optimize()</a>, and <a class="el" href="expr_8cpp_source.html#l03101">SelectExpr::Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a10a128dce461aaf7c9b4cb6c73eb20a8"></a><!-- doxytag: member="AtomicType::VaryingInt16" ref="a10a128dce461aaf7c9b4cb6c73eb20a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#a10a128dce461aaf7c9b4cb6c73eb20a8">AtomicType::VaryingInt16</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a13f725bbb76543669b6b1c42856f3be2">AtomicType::TYPE_INT16</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a3fbef7594ed5b2a737aaa0f9b325a940">Variability::Varying</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00297">297</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l04926">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, and <a class="el" href="ctx_8cpp_source.html#l02596">FunctionEmitContext::maskedStore()</a>.</p>

</div>
</div>
<a class="anchor" id="ae112e2d3aaefd2a4035ce998e4c71ff3"></a><!-- doxytag: member="AtomicType::VaryingInt32" ref="ae112e2d3aaefd2a4035ce998e4c71ff3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#ae112e2d3aaefd2a4035ce998e4c71ff3">AtomicType::VaryingInt32</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a00ab00a08272898bb6b864f11d254edb">AtomicType::TYPE_INT32</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a3fbef7594ed5b2a737aaa0f9b325a940">Variability::Varying</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00298">298</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l04966">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="builtins_8cpp_source.html#l00182">lCreateISPCSymbol()</a>, <a class="el" href="builtins_8cpp_source.html#l00676">lDefineProgramIndex()</a>, <a class="el" href="expr_8cpp_source.html#l00989">lEmitPrePostIncDec()</a>, <a class="el" href="stmt_8cpp_source.html#l02437">lEncodeType()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="stmt_8cpp_source.html#l02467">lProcessPrintArg()</a>, <a class="el" href="ctx_8cpp_source.html#l02596">FunctionEmitContext::maskedStore()</a>, <a class="el" href="expr_8cpp_source.html#l01145">UnaryExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l02093">BinaryExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l03101">SelectExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l04192">IndexExpr::TypeCheck()</a>, and <a class="el" href="stmt_8cpp_source.html#l02149">SwitchStmt::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a58a98c38cae3c592a6d79546fe07f6d1"></a><!-- doxytag: member="AtomicType::VaryingInt64" ref="a58a98c38cae3c592a6d79546fe07f6d1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#a58a98c38cae3c592a6d79546fe07f6d1">AtomicType::VaryingInt64</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8ae1d9efe8854a9c33eb59a4759c777233">AtomicType::TYPE_INT64</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a3fbef7594ed5b2a737aaa0f9b325a940">Variability::Varying</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00303">303</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l05029">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="stmt_8cpp_source.html#l02437">lEncodeType()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="ctx_8cpp_source.html#l02596">FunctionEmitContext::maskedStore()</a>, <a class="el" href="expr_8cpp_source.html#l03101">SelectExpr::Optimize()</a>, and <a class="el" href="stmt_8cpp_source.html#l02149">SwitchStmt::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="affcc682326adef0c5ad307ac675d7be4"></a><!-- doxytag: member="AtomicType::VaryingInt8" ref="affcc682326adef0c5ad307ac675d7be4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#affcc682326adef0c5ad307ac675d7be4">AtomicType::VaryingInt8</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a6ad6b5890e60ada74bb5ea61d3127c59">AtomicType::TYPE_INT8</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a3fbef7594ed5b2a737aaa0f9b325a940">Variability::Varying</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00296">296</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l04886">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, and <a class="el" href="ctx_8cpp_source.html#l02596">FunctionEmitContext::maskedStore()</a>.</p>

</div>
</div>
<a class="anchor" id="a95ce8785b74c5d2fd3bd26a1db93cea8"></a><!-- doxytag: member="AtomicType::VaryingUInt16" ref="a95ce8785b74c5d2fd3bd26a1db93cea8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#a95ce8785b74c5d2fd3bd26a1db93cea8">AtomicType::VaryingUInt16</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a51920f987bfaa784ccdfa4b10439cc25">AtomicType::TYPE_UINT16</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a3fbef7594ed5b2a737aaa0f9b325a940">Variability::Varying</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00300">300</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l04946">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, and <a class="el" href="ctx_8cpp_source.html#l02596">FunctionEmitContext::maskedStore()</a>.</p>

</div>
</div>
<a class="anchor" id="a0f0ec8f289e2c824016d689987c6d774"></a><!-- doxytag: member="AtomicType::VaryingUInt32" ref="a0f0ec8f289e2c824016d689987c6d774" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#a0f0ec8f289e2c824016d689987c6d774">AtomicType::VaryingUInt32</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a6484104d64f48bf326c2779fc6a5a721">AtomicType::TYPE_UINT32</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a3fbef7594ed5b2a737aaa0f9b325a940">Variability::Varying</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00301">301</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l04988">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l06313">TypeCastExpr::GetValue()</a>, <a class="el" href="stmt_8cpp_source.html#l02437">lEncodeType()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="ctx_8cpp_source.html#l02596">FunctionEmitContext::maskedStore()</a>, <a class="el" href="expr_8cpp_source.html#l01145">UnaryExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l02093">BinaryExpr::Optimize()</a>, and <a class="el" href="expr_8cpp_source.html#l03101">SelectExpr::Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="acab78bfdc4a1dfb1509bf747f04fd856"></a><!-- doxytag: member="AtomicType::VaryingUInt64" ref="acab78bfdc4a1dfb1509bf747f04fd856" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#acab78bfdc4a1dfb1509bf747f04fd856">AtomicType::VaryingUInt64</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a972e12e27f2dfa1815a783d2eb7c9d8e">AtomicType::TYPE_UINT64</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a3fbef7594ed5b2a737aaa0f9b325a940">Variability::Varying</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00304">304</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l05049">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="stmt_8cpp_source.html#l02437">lEncodeType()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="ctx_8cpp_source.html#l02596">FunctionEmitContext::maskedStore()</a>, and <a class="el" href="expr_8cpp_source.html#l03101">SelectExpr::Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a909a12e11d4cd7199d5e45000d0b371c"></a><!-- doxytag: member="AtomicType::VaryingUInt8" ref="a909a12e11d4cd7199d5e45000d0b371c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#a909a12e11d4cd7199d5e45000d0b371c">AtomicType::VaryingUInt8</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a7379de3364345bdd8b35e52c33674d4a">AtomicType::TYPE_UINT8</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a3fbef7594ed5b2a737aaa0f9b325a940">Variability::Varying</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00299">299</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l04906">ConstExpr::ConstExpr()</a>, <a class="el" href="expr_8cpp_source.html#l05555">ConstExpr::GetConstant()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, and <a class="el" href="ctx_8cpp_source.html#l02596">FunctionEmitContext::maskedStore()</a>.</p>

</div>
</div>
<a class="anchor" id="a28a79cd7526ec38bf8ae805bfbb179f3"></a><!-- doxytag: member="AtomicType::Void" ref="a28a79cd7526ec38bf8ae805bfbb179f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAtomicType.html">AtomicType</a> * <a class="el" href="classAtomicType.html#a28a79cd7526ec38bf8ae805bfbb179f3">AtomicType::Void</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> 
    <span class="keyword">new</span> <a class="code" href="classAtomicType.html#a280d855b37d6bf334c98c2767a4f50e9">AtomicType</a>(<a class="code" href="classAtomicType.html#aa4380202bca53e9468958ecfd601b3f8a21dcd6e5dbbe085f246fd4fa769d8807">TYPE_VOID</a>, <a class="code" href="structVariability.html#a2d2fe5cdb9baa8161a605de691d0d1f8a489d62b409bc3a0793202b0a43758e62">Variability::Uniform</a>, <span class="keyword">false</span>)
</pre></div>
<p>Definition at line <a class="el" href="type_8h_source.html#l00306">306</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00470">Module::AddFunctionDeclaration()</a>, <a class="el" href="module_8cpp_source.html#l00222">Module::AddGlobalVariable()</a>, <a class="el" href="ctx_8cpp_source.html#l01160">FunctionEmitContext::CurrentLanesReturned()</a>, <a class="el" href="ctx_8cpp_source.html#l00209">FunctionEmitContext::FunctionEmitContext()</a>, <a class="el" href="decl_8cpp_source.html#l00724">GetStructTypesNamesPositions()</a>, <a class="el" href="decl_8cpp_source.html#l00346">Declarator::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l07799">SyncExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l03294">FunctionCallExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l06313">TypeCastExpr::GetValue()</a>, <a class="el" href="decl_8cpp_source.html#l00652">Declaration::GetVariableDeclarations()</a>, <a class="el" href="decl_8cpp_source.html#l00067">lApplyTypeQualifiers()</a>, <a class="el" href="expr_8cpp_source.html#l00187">lDoTypeConv()</a>, <a class="el" href="builtins_8cpp_source.html#l00081">lLLVMTypeToISPCType()</a>, <a class="el" href="ctx_8cpp_source.html#l03251">FunctionEmitContext::ReturnInst()</a>, and <a class="el" href="expr_8cpp_source.html#l06615">TypeCastExpr::TypeCheck()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="type_8h_source.html">type.h</a></li>
<li><a class="el" href="type_8cpp_source.html">type.cpp</a></li>
</ul>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 6 2012 16:03:15 for Intel SPMD Program Compiler by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
