<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Intel SPMD Program Compiler: opt.cpp File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Intel SPMD Program Compiler
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">opt.cpp File Reference</div>  </div>
</div>
<div class="contents">

<p>Implementations of various ispc optimization passes that operate on the LLVM IR.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="opt_8h_source.html">opt.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ctx_8h_source.html">ctx.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sym_8h_source.html">sym.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="module_8h_source.html">module.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="llvmutil_8h_source.html">llvmutil.h</a>&quot;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;map&gt;</code><br/>
<code>#include &lt;set&gt;</code><br/>
<code>#include &lt;llvm/Pass.h&gt;</code><br/>
<code>#include &lt;llvm/Module.h&gt;</code><br/>
<code>#include &lt;llvm/PassManager.h&gt;</code><br/>
<code>#include &lt;llvm/PassRegistry.h&gt;</code><br/>
<code>#include &lt;llvm/Assembly/PrintModulePass.h&gt;</code><br/>
<code>#include &lt;llvm/Function.h&gt;</code><br/>
<code>#include &lt;llvm/BasicBlock.h&gt;</code><br/>
<code>#include &lt;llvm/Instructions.h&gt;</code><br/>
<code>#include &lt;llvm/Intrinsics.h&gt;</code><br/>
<code>#include &lt;llvm/Constants.h&gt;</code><br/>
<code>#include &lt;llvm/Analysis/ConstantFolding.h&gt;</code><br/>
<code>#include &lt;llvm/Target/TargetLibraryInfo.h&gt;</code><br/>
<code>#include &lt;llvm/ADT/Triple.h&gt;</code><br/>
<code>#include &lt;llvm/Transforms/Scalar.h&gt;</code><br/>
<code>#include &lt;llvm/Transforms/IPO.h&gt;</code><br/>
<code>#include &lt;llvm/Transforms/Utils/BasicBlockUtils.h&gt;</code><br/>
<code>#include &lt;llvm/Target/TargetOptions.h&gt;</code><br/>
<code>#include &lt;llvm/Target/TargetData.h&gt;</code><br/>
<code>#include &lt;llvm/Target/TargetMachine.h&gt;</code><br/>
<code>#include &lt;llvm/Analysis/Verifier.h&gt;</code><br/>
<code>#include &lt;llvm/Analysis/Passes.h&gt;</code><br/>
<code>#include &lt;llvm/Support/raw_ostream.h&gt;</code><br/>
<code>#include &lt;llvm/DebugInfo.h&gt;</code><br/>
<code>#include &lt;llvm/Support/Dwarf.h&gt;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for opt.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="opt_8cpp__incl.png" border="0" usemap="#opt_8cpp" alt=""/></div>
<map name="opt_8cpp" id="opt_8cpp">
<area shape="rect" id="node3" href="opt_8h.html" title="Declarations related to optimization passes." alt="" coords="1217,161,1273,189"/><area shape="rect" id="node17" href="ctx_8h.html" title="Declaration of the FunctionEmitContext class." alt="" coords="525,83,581,111"/><area shape="rect" id="node30" href="sym_8h.html" title="header file with declarations for symbol and symbol table classes." alt="" coords="134,83,196,111"/><area shape="rect" id="node39" href="module_8h.html" title="Declaration of the Module class, which is the ispc&#45;side representation of the results of compiling a ..." alt="" coords="1041,83,1127,111"/><area shape="rect" id="node44" href="util_8h.html" title="util.h" alt="" coords="1136,161,1192,189"/><area shape="rect" id="node47" href="llvmutil_8h.html" title="Header file with declarations for various LLVM utility stuff." alt="" coords="1252,83,1337,111"/><area shape="rect" id="node5" href="ispc_8h.html" title="Main ispc.header file." alt="" coords="235,238,296,266"/><area shape="rect" id="node33" href="decl_8h.html" title="Declarations related to type declarations; the parser basically creates instances of these classes..." alt="" coords="33,161,95,189"/></map>
</div>
</div>
<p><a href="opt_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrinsicsOpt.html">IntrinsicsOpt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIntrinsicsOpt_1_1MaskInstruction.html">IntrinsicsOpt::MaskInstruction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIntrinsicsOpt_1_1BlendInstruction.html">IntrinsicsOpt::BlendInstruction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVSelMovmskOpt.html">VSelMovmskOpt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImproveMemoryOpsPass.html">ImproveMemoryOpsPass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGatherCoalescePass.html">GatherCoalescePass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplacePseudoMemoryOpsPass.html">ReplacePseudoMemoryOpsPass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIsCompileTimeConstantPass.html">IsCompileTimeConstantPass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMakeInternalFuncsStaticPass.html">MakeInternalFuncsStaticPass</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ae372e90b62c1e8b51dc5d95bf7f5ba48">PRId64</a>&#160;&#160;&#160;&quot;lld&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ac582131d7a7c8ee57e73180d1714f9d5">PRIu64</a>&#160;&#160;&#160;&quot;llu&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#adbde12d4ee08327c1d87560313eaa0fc">DEBUG_START_PASS</a>(NAME)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#aab4fdb7921688a9b90ade286db3f343c">DEBUG_END_PASS</a>(NAME)</td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a49b78092c0a6c04e2786364fe785528f">MaskStatus</a> { <a class="el" href="opt_8cpp.html#a49b78092c0a6c04e2786364fe785528fad6559206fa18d70e41882be07ac8dbe6">ALL_ON</a>, 
<a class="el" href="opt_8cpp.html#a49b78092c0a6c04e2786364fe785528fa64dec3992d128eb947b5210be53f3275">ALL_OFF</a>, 
<a class="el" href="opt_8cpp.html#a49b78092c0a6c04e2786364fe785528fa55c2b4d0f7ac387d0c7216f597dfacd3">MIXED</a>, 
<a class="el" href="opt_8cpp.html#a49b78092c0a6c04e2786364fe785528fa6ce26a62afab55d7606ad4e92428b30c">UNKNOWN</a>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ae101f1887eb612fd966ca6af38124b06">CreateIntrinsicsOptPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#aecd61ed536c82b2319f160531809b13e">CreateVSelMovmskOptPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a6a7636b3f63934e8c5b6280257c021c3">CreateImproveMemoryOpsPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a0f6f3aa04ee26b88fe08079daad024ac">CreateGatherCoalescePass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a2b10cef179367feaac22d91ad8a9a2fe">CreateReplacePseudoMemoryOpsPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a9748d87e99ad21e87701c8de501b9231">CreateIsCompileTimeConstantPass</a> (bool isLastTry)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ac2100b660388956a7963ac9fe6839cb5">CreateMakeInternalFuncsStaticPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ae626137870c4cecf7e885cc2e5a5d433">lCopyMetadata</a> (llvm::Value *vto, const llvm::Instruction *from)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a9ce816b84cb0c2ca769c486be11dde5f">lGetSourcePosFromMetadata</a> (const llvm::Instruction *inst, <a class="el" href="structSourcePos.html">SourcePos</a> *pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Instruction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a8c19662e48244e08880bd61669b26839">lCallInst</a> (llvm::Function *func, llvm::Value *arg0, llvm::Value *arg1, const char *name, llvm::Instruction *insertBefore=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Instruction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a6e4af755e19b1128d1b71e55688f249a">lCallInst</a> (llvm::Function *func, llvm::Value *arg0, llvm::Value *arg1, llvm::Value *arg2, const char *name, llvm::Instruction *insertBefore=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Instruction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a424642b393fa76f892d1a76e0192e349">lCallInst</a> (llvm::Function *func, llvm::Value *arg0, llvm::Value *arg1, llvm::Value *arg2, llvm::Value *arg3, llvm::Value *arg4, const char *name, llvm::Instruction *insertBefore=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Instruction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#af3b6debc19799c60ba11126bf7123a7e">lCallInst</a> (llvm::Function *func, llvm::Value *arg0, llvm::Value *arg1, llvm::Value *arg2, llvm::Value *arg3, llvm::Value *arg4, llvm::Value *arg5, const char *name, llvm::Instruction *insertBefore=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Instruction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a3c01ae41fd09d742d341f5f5293838f2">lGEPInst</a> (llvm::Value *ptr, llvm::Value *offset, const char *name, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a7351c1b2da2303d0d65d7953ddf187ee">lConstElementsToMask</a> (const llvm::SmallVector&lt; llvm::Constant *, ISPC_MAX_NVEC &gt; &amp;elements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a04415f5411b9d1e3c664116804a1c72e">lGetMask</a> (llvm::Value *factor, uint64_t *mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="opt_8cpp.html#a49b78092c0a6c04e2786364fe785528f">MaskStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a3d02f9665198cc4b6fd98ae63ea7a983">lGetMaskStatus</a> (llvm::Value *mask, int vecWidth=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a2a7faa9c8af29d05713e5d15fdff1810">Optimize</a> (llvm::Module *module, int optLevel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a22173061ee4fe22a8ed7f20e32b40ad8">lIsUndef</a> (llvm::Value *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a30ccca7ed1dca9f3ff30ebb445cfcaab">lCheckForActualPointer</a> (llvm::Value *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a568fd43a32e1a91745ca4cd1d8fc6a32">lGetBasePointer</a> (llvm::Value *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#af47f2481f316b98aa8a37354e1e1473c">lGetConstantAddExprBaseOffset</a> (llvm::Constant *op0, llvm::Constant *op1, llvm::Constant **delta)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a5cce8aeb24479c1f288199fba4f5e4c2">lExtractFromInserts</a> (llvm::Value *v, unsigned int index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ac6ced32908e9773085ec13530d64b96c">lGetBasePtrAndOffsets</a> (llvm::Value *ptrs, llvm::Value **offsets, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#adce013e717663e5e455ad1d4b6ddb35a">lExtractConstantOffset</a> (llvm::Value *vec, llvm::Value **constOffset, llvm::Value **variableOffset, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a3bdaa6f11aebf4775d0f369602f3b026">lIsIntegerSplat</a> (llvm::Value *v, int *splat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a6b7adc00a1832b7937542e9f70d7a008">lExtract248Scale</a> (llvm::Value *splatOperand, int splatValue, llvm::Value *otherOperand, llvm::Value **result)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a8e57e1615411b94fc8171f6180b9d762">lExtractOffsetVector248Scale</a> (llvm::Value **vec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a780f599aabf28e9c16d7f3de9d853a92">lVectorIs32BitInts</a> (llvm::Value *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a6f14dd2deb4b07e1ab1beedb817ad014">lOffsets32BitSafe</a> (llvm::Value **variableOffsetPtr, llvm::Value **constOffsetPtr, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a416fbd7585671f21b02c2e4c4af0e60c">lGSToGSBaseOffsets</a> (llvm::CallInst *callInst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#afc6d92c9ffeab46f08584419178582fe">lGSBaseOffsetsGetMoreConst</a> (llvm::CallInst *callInst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#accadb004816ea7494e811c3a2d311641">lComputeCommonPointer</a> (llvm::Value *base, llvm::Value *offsets, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a483d09d1f5b53eab2fe5f2e1c2597e3a">lGSToLoadStore</a> (llvm::CallInst *callInst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#aa1fbd436abbd761d1097793a6d261d66">lImproveMaskedStore</a> (llvm::CallInst *callInst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a0ef5259b06f72e3a8d5eddb1a73ea3e9">lImproveMaskedLoad</a> (llvm::CallInst *callInst, llvm::BasicBlock::iterator iter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a6925a69b3ebc6616ffa6a0dce8fa675b">lVectorLoadIsEfficient</a> (std::set&lt; int64_t &gt;::iterator iter, std::set&lt; int64_t &gt;::iterator end, std::set&lt; int64_t &gt;::iterator *newIter, int vectorWidth)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ae037d63652cb821b0bfe3afc19a9257e">lSelectLoads</a> (const std::vector&lt; int64_t &gt; &amp;loadOffsets, std::vector&lt; <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &gt; *loads)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ac6bd161dcb83c2ac4c5bd2b3cd3bb9b4">lCoalescePerfInfo</a> (const std::vector&lt; llvm::CallInst * &gt; &amp;coalesceGroup, const std::vector&lt; <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &gt; &amp;loadOps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a35652ce326fb0932c7e92e493ed716f2">lGEPAndLoad</a> (llvm::Value *basePtr, int64_t offset, int align, llvm::Instruction *insertBefore, llvm::Type *type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ac39cdb1c2043099b4968cd306c410521">lEmitLoads</a> (llvm::Value *basePtr, std::vector&lt; <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &gt; &amp;loadOps, int elementSize, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::vector<br class="typebreak"/>
&lt; <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ae7ff7a0156aa50b53b494e4a41c61dfb">lSplit8WideLoads</a> (const std::vector&lt; <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &gt; &amp;loadOps, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a56e2dfbfb31b14076ea41ff614566ec3">lApplyLoad1</a> (llvm::Value *result, const <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &amp;load, const int64_t offsets[4], bool set[4], llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a52415e4178be7c02fcfbd27336074477">lApplyLoad2</a> (llvm::Value *result, const <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &amp;load, const int64_t offsets[4], bool set[4], llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a8f5600490e1539fe212af8a715b621e0">lApplyLoad4</a> (llvm::Value *result, const <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &amp;load, const int64_t offsets[4], bool set[4], llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a956a2733c9595b6fee9d579ecb8ef2b0">lAssemble4Vector</a> (const std::vector&lt; <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &gt; &amp;loadOps, const int64_t offsets[4], llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a6784c06adaa910d91df9b9a1303d7dff">lAssembleResultVectors</a> (const std::vector&lt; <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &gt; &amp;loadOps, const std::vector&lt; int64_t &gt; &amp;constOffsets, std::vector&lt; llvm::Value * &gt; &amp;results, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a750e741d5d8196d5aaa5a557e434750a">lComputeBasePtr</a> (llvm::CallInst *gatherInst, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a20477c5575b29732597e1bb3d7e787df">lExtractConstOffsets</a> (const std::vector&lt; llvm::CallInst * &gt; &amp;coalesceGroup, int elementSize, std::vector&lt; int64_t &gt; *constOffsets)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a89b4a898512197020c886ae55ad4a7e7">lCoalesceGathers</a> (const std::vector&lt; llvm::CallInst * &gt; &amp;coalesceGroup)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a4e9c006f2dbccb2cad3e63ac8ada1dbd">lInstructionMayWriteToMemory</a> (llvm::Instruction *inst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a432c7725f35dbabfc537a1f2b91b85ca">lIsSafeToBlend</a> (llvm::Value *lvalue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a280822c558759501011ceb299035d26c">lReplacePseudoMaskedStore</a> (llvm::CallInst *callInst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a9cccdfb4848eb19c4edd227272f38c6d">lReplacePseudoGS</a> (llvm::CallInst *callInst)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Implementations of various ispc optimization passes that operate on the LLVM IR. </p>

<p>Definition in file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="aab4fdb7921688a9b90ade286db3f343c"></a><!-- doxytag: member="opt.cpp::DEBUG_END_PASS" ref="aab4fdb7921688a9b90ade286db3f343c" args="(NAME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_END_PASS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">NAME</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (<a class="code" href="ispc_8h.html#a246cb09c0c20eb8144838277e8733c86">g</a>-&gt;<a class="code" href="structGlobals.html#a5fa83e18d8ae90aa4dd2f2c5cd88386d">debugPrint</a> &amp;&amp;                                       \
        (getenv(<span class="stringliteral">&quot;FUNC&quot;</span>) == NULL ||                             \
         !strncmp(bb.getParent()-&gt;getName().str().c_str(), getenv(<span class="stringliteral">&quot;FUNC&quot;</span>), \
                  strlen(getenv(<span class="stringliteral">&quot;FUNC&quot;</span>))))) {                           \
        fprintf(stderr, <span class="stringliteral">&quot;End of &quot;</span> NAME <span class="stringliteral">&quot; %s\n&quot;</span>, modifiedAny ? <span class="stringliteral">&quot;** CHANGES **&quot;</span> : <span class="stringliteral">&quot;&quot;</span>); \
        fprintf(stderr, <span class="stringliteral">&quot;---------------\n&quot;</span>);                  \
        bb.dump();                                             \
        fprintf(stderr, <span class="stringliteral">&quot;---------------\n\n&quot;</span>);                \
    } <span class="keywordflow">else</span>
</pre></div>
<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00115">115</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00680">IntrinsicsOpt::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l00899">VSelMovmskOpt::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l02388">ImproveMemoryOpsPass::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l03353">GatherCoalescePass::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l03730">ReplacePseudoMemoryOpsPass::runOnBasicBlock()</a>, and <a class="el" href="opt_8cpp_source.html#l03797">IsCompileTimeConstantPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="adbde12d4ee08327c1d87560313eaa0fc"></a><!-- doxytag: member="opt.cpp::DEBUG_START_PASS" ref="adbde12d4ee08327c1d87560313eaa0fc" args="(NAME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_START_PASS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">NAME</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (<a class="code" href="ispc_8h.html#a246cb09c0c20eb8144838277e8733c86">g</a>-&gt;<a class="code" href="structGlobals.html#a5fa83e18d8ae90aa4dd2f2c5cd88386d">debugPrint</a> &amp;&amp;                                       \
        (getenv(<span class="stringliteral">&quot;FUNC&quot;</span>) == NULL ||                             \
         !strncmp(bb.getParent()-&gt;getName().str().c_str(), getenv(<span class="stringliteral">&quot;FUNC&quot;</span>), \
                  strlen(getenv(<span class="stringliteral">&quot;FUNC&quot;</span>))))) {                           \
        fprintf(stderr, <span class="stringliteral">&quot;Start of &quot;</span> NAME <span class="stringliteral">&quot;\n&quot;</span>);                \
        fprintf(stderr, <span class="stringliteral">&quot;---------------\n&quot;</span>);                  \
        bb.dump();                                             \
        fprintf(stderr, <span class="stringliteral">&quot;---------------\n\n&quot;</span>);                \
    } <span class="keywordflow">else</span>
</pre></div>
<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00104">104</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00680">IntrinsicsOpt::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l00899">VSelMovmskOpt::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l02388">ImproveMemoryOpsPass::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l03353">GatherCoalescePass::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l03730">ReplacePseudoMemoryOpsPass::runOnBasicBlock()</a>, and <a class="el" href="opt_8cpp_source.html#l03797">IsCompileTimeConstantPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ae372e90b62c1e8b51dc5d95bf7f5ba48"></a><!-- doxytag: member="opt.cpp::PRId64" ref="ae372e90b62c1e8b51dc5d95bf7f5ba48" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PRId64&#160;&#160;&#160;&quot;lld&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00088">88</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02838">lApplyLoad1()</a>, <a class="el" href="opt_8cpp_source.html#l02863">lApplyLoad2()</a>, <a class="el" href="opt_8cpp_source.html#l02930">lApplyLoad4()</a>, <a class="el" href="opt_8cpp_source.html#l02971">lAssemble4Vector()</a>, <a class="el" href="opt_8cpp_source.html#l02742">lEmitLoads()</a>, and <a class="el" href="opt_8cpp_source.html#l02606">lSelectLoads()</a>.</p>

</div>
</div>
<a class="anchor" id="ac582131d7a7c8ee57e73180d1714f9d5"></a><!-- doxytag: member="opt.cpp::PRIu64" ref="ac582131d7a7c8ee57e73180d1714f9d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PRIu64&#160;&#160;&#160;&quot;llu&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00091">91</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a49b78092c0a6c04e2786364fe785528f"></a><!-- doxytag: member="opt.cpp::MaskStatus" ref="a49b78092c0a6c04e2786364fe785528f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="opt_8cpp.html#a49b78092c0a6c04e2786364fe785528f">MaskStatus</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a49b78092c0a6c04e2786364fe785528fad6559206fa18d70e41882be07ac8dbe6"></a><!-- doxytag: member="ALL_ON" ref="a49b78092c0a6c04e2786364fe785528fad6559206fa18d70e41882be07ac8dbe6" args="" -->ALL_ON</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a49b78092c0a6c04e2786364fe785528fa64dec3992d128eb947b5210be53f3275"></a><!-- doxytag: member="ALL_OFF" ref="a49b78092c0a6c04e2786364fe785528fa64dec3992d128eb947b5210be53f3275" args="" -->ALL_OFF</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a49b78092c0a6c04e2786364fe785528fa55c2b4d0f7ac387d0c7216f597dfacd3"></a><!-- doxytag: member="MIXED" ref="a49b78092c0a6c04e2786364fe785528fa55c2b4d0f7ac387d0c7216f597dfacd3" args="" -->MIXED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a49b78092c0a6c04e2786364fe785528fa6ce26a62afab55d7606ad4e92428b30c"></a><!-- doxytag: member="UNKNOWN" ref="a49b78092c0a6c04e2786364fe785528fa6ce26a62afab55d7606ad4e92428b30c" args="" -->UNKNOWN</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00362">362</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0f6f3aa04ee26b88fe08079daad024ac"></a><!-- doxytag: member="opt.cpp::CreateGatherCoalescePass" ref="a0f6f3aa04ee26b88fe08079daad024ac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateGatherCoalescePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l03499">3499</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00391">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a6a7636b3f63934e8c5b6280257c021c3"></a><!-- doxytag: member="opt.cpp::CreateImproveMemoryOpsPass" ref="a6a7636b3f63934e8c5b6280257c021c3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateImproveMemoryOpsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02432">2432</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00391">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="ae101f1887eb612fd966ca6af38124b06"></a><!-- doxytag: member="opt.cpp::CreateIntrinsicsOptPass" ref="ae101f1887eb612fd966ca6af38124b06" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateIntrinsicsOptPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00870">870</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00391">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a9748d87e99ad21e87701c8de501b9231"></a><!-- doxytag: member="opt.cpp::CreateIsCompileTimeConstantPass" ref="a9748d87e99ad21e87701c8de501b9231" args="(bool isLastTry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateIsCompileTimeConstantPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLastTry</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l03864">3864</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00391">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="ac2100b660388956a7963ac9fe6839cb5"></a><!-- doxytag: member="opt.cpp::CreateMakeInternalFuncsStaticPass" ref="ac2100b660388956a7963ac9fe6839cb5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateMakeInternalFuncsStaticPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l03965">3965</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00391">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b10cef179367feaac22d91ad8a9a2fe"></a><!-- doxytag: member="opt.cpp::CreateReplacePseudoMemoryOpsPass" ref="a2b10cef179367feaac22d91ad8a9a2fe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateReplacePseudoMemoryOpsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l03759">3759</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00391">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="aecd61ed536c82b2319f160531809b13e"></a><!-- doxytag: member="opt.cpp::CreateVSelMovmskOptPass" ref="aecd61ed536c82b2319f160531809b13e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateVSelMovmskOptPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00959">959</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00391">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a56e2dfbfb31b14076ea41ff614566ec3"></a><!-- doxytag: member="opt.cpp::lApplyLoad1" ref="a56e2dfbfb31b14076ea41ff614566ec3" args="(llvm::Value *result, const CoalescedLoadOp &amp;load, const int64_t offsets[4], bool set[4], llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lApplyLoad1 </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &amp;&#160;</td>
          <td class="paramname"><em>load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>offsets</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>set</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a 1-wide load of a 32-bit value, merge its value into the result vector for any and all elements for which it applies. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02838">2838</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="opt_8cpp_source.html#l02487">CoalescedLoadOp::count</a>, <a class="el" href="util_8cpp_source.html#l00390">Debug()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00207">LLVMInt32()</a>, <a class="el" href="opt_8cpp_source.html#l02490">CoalescedLoadOp::load</a>, <a class="el" href="opt_8cpp_source.html#l00088">PRId64</a>, and <a class="el" href="opt_8cpp_source.html#l02484">CoalescedLoadOp::start</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02971">lAssemble4Vector()</a>.</p>

</div>
</div>
<a class="anchor" id="a52415e4178be7c02fcfbd27336074477"></a><!-- doxytag: member="opt.cpp::lApplyLoad2" ref="a52415e4178be7c02fcfbd27336074477" args="(llvm::Value *result, const CoalescedLoadOp &amp;load, const int64_t offsets[4], bool set[4], llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lApplyLoad2 </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &amp;&#160;</td>
          <td class="paramname"><em>load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>offsets</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>set</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Similarly, incorporate the values from a 2-wide load into any vector elements that they apply to. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02863">2863</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="opt_8cpp_source.html#l02487">CoalescedLoadOp::count</a>, <a class="el" href="util_8cpp_source.html#l00390">Debug()</a>, <a class="el" href="opt_8cpp_source.html#l02494">CoalescedLoadOp::element0</a>, <a class="el" href="opt_8cpp_source.html#l02494">CoalescedLoadOp::element1</a>, <a class="el" href="llvmutil_8h_source.html#l00064">LLVMTypes::Int32Type</a>, <a class="el" href="llvmutil_8h_source.html#l00065">LLVMTypes::Int64Type</a>, <a class="el" href="llvmutil_8cpp_source.html#l00207">LLVMInt32()</a>, <a class="el" href="opt_8cpp_source.html#l02490">CoalescedLoadOp::load</a>, <a class="el" href="opt_8cpp_source.html#l00088">PRId64</a>, and <a class="el" href="opt_8cpp_source.html#l02484">CoalescedLoadOp::start</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02971">lAssemble4Vector()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f5600490e1539fe212af8a715b621e0"></a><!-- doxytag: member="opt.cpp::lApplyLoad4" ref="a8f5600490e1539fe212af8a715b621e0" args="(llvm::Value *result, const CoalescedLoadOp &amp;load, const int64_t offsets[4], bool set[4], llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lApplyLoad4 </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &amp;&#160;</td>
          <td class="paramname"><em>load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>offsets</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>set</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>And handle a 4-wide load </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02930">2930</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="opt_8cpp_source.html#l02487">CoalescedLoadOp::count</a>, <a class="el" href="util_8cpp_source.html#l00390">Debug()</a>, <a class="el" href="parse_8yy_source.html#l310999">int32_t</a>, <a class="el" href="llvmutil_8cpp_source.html#l01540">LLVMShuffleVectors()</a>, <a class="el" href="opt_8cpp_source.html#l02490">CoalescedLoadOp::load</a>, <a class="el" href="opt_8cpp_source.html#l00088">PRId64</a>, and <a class="el" href="opt_8cpp_source.html#l02484">CoalescedLoadOp::start</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02971">lAssemble4Vector()</a>.</p>

</div>
</div>
<a class="anchor" id="a956a2733c9595b6fee9d579ecb8ef2b0"></a><!-- doxytag: member="opt.cpp::lAssemble4Vector" ref="a956a2733c9595b6fee9d579ecb8ef2b0" args="(const std::vector&lt; CoalescedLoadOp &gt; &amp;loadOps, const int64_t offsets[4], llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lAssemble4Vector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>loadOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>offsets</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>We're need to fill in the values for a 4-wide result vector. This function looks at all of the generated loads and extracts the appropriate elements from the appropriate loads to assemble the result. Here the offsets[] parameter gives the 4 offsets from the base pointer for the four elements of the result. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02971">2971</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="opt_8cpp_source.html#l02487">CoalescedLoadOp::count</a>, <a class="el" href="util_8cpp_source.html#l00390">Debug()</a>, <a class="el" href="util_8h_source.html#l00113">FATAL</a>, <a class="el" href="llvmutil_8h_source.html#l00064">LLVMTypes::Int32Type</a>, <a class="el" href="opt_8cpp_source.html#l02838">lApplyLoad1()</a>, <a class="el" href="opt_8cpp_source.html#l02863">lApplyLoad2()</a>, <a class="el" href="opt_8cpp_source.html#l02930">lApplyLoad4()</a>, and <a class="el" href="opt_8cpp_source.html#l00088">PRId64</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l03143">lAssembleResultVectors()</a>.</p>

</div>
</div>
<a class="anchor" id="a6784c06adaa910d91df9b9a1303d7dff"></a><!-- doxytag: member="opt.cpp::lAssembleResultVectors" ref="a6784c06adaa910d91df9b9a1303d7dff" args="(const std::vector&lt; CoalescedLoadOp &gt; &amp;loadOps, const std::vector&lt; int64_t &gt; &amp;constOffsets, std::vector&lt; llvm::Value * &gt; &amp;results, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void lAssembleResultVectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>loadOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>constOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given the set of loads that we've done and the set of result values to be computed, this function computes the final llvm::Value *s for each result vector. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l03143">3143</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="util_8h_source.html#l00113">FATAL</a>, <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="opt_8cpp_source.html#l02971">lAssemble4Vector()</a>, <a class="el" href="llvmutil_8cpp_source.html#l01517">LLVMConcatVectors()</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="ispc_8h_source.html#l00377">Globals::target</a>, and <a class="el" href="ispc_8h_source.html#l00235">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l03249">lCoalesceGathers()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c19662e48244e08880bd61669b26839"></a><!-- doxytag: member="opt.cpp::lCallInst" ref="a8c19662e48244e08880bd61669b26839" args="(llvm::Function *func, llvm::Value *arg0, llvm::Value *arg1, const char *name, llvm::Instruction *insertBefore=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Instruction* lCallInst </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00210">210</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01677">lGSToGSBaseOffsets()</a>, <a class="el" href="opt_8cpp_source.html#l02010">lGSToLoadStore()</a>, and <a class="el" href="opt_8cpp_source.html#l03565">lReplacePseudoMaskedStore()</a>.</p>

</div>
</div>
<a class="anchor" id="a6e4af755e19b1128d1b71e55688f249a"></a><!-- doxytag: member="opt.cpp::lCallInst" ref="a6e4af755e19b1128d1b71e55688f249a" args="(llvm::Function *func, llvm::Value *arg0, llvm::Value *arg1, llvm::Value *arg2, const char *name, llvm::Instruction *insertBefore=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Instruction* lCallInst </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00219">219</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a424642b393fa76f892d1a76e0192e349"></a><!-- doxytag: member="opt.cpp::lCallInst" ref="a424642b393fa76f892d1a76e0192e349" args="(llvm::Function *func, llvm::Value *arg0, llvm::Value *arg1, llvm::Value *arg2, llvm::Value *arg3, llvm::Value *arg4, const char *name, llvm::Instruction *insertBefore=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Instruction* lCallInst </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00240">240</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af3b6debc19799c60ba11126bf7123a7e"></a><!-- doxytag: member="opt.cpp::lCallInst" ref="af3b6debc19799c60ba11126bf7123a7e" args="(llvm::Function *func, llvm::Value *arg0, llvm::Value *arg1, llvm::Value *arg2, llvm::Value *arg3, llvm::Value *arg4, llvm::Value *arg5, const char *name, llvm::Instruction *insertBefore=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Instruction* lCallInst </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00250">250</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a30ccca7ed1dca9f3ff30ebb445cfcaab"></a><!-- doxytag: member="opt.cpp::lCheckForActualPointer" ref="a30ccca7ed1dca9f3ff30ebb445cfcaab" args="(llvm::Value *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lCheckForActualPointer </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check to make sure that this value is actually a pointer in the end. We need to make sure that given an expression like vec(offset) + ptr2int(ptr), <a class="el" href="opt_8cpp.html#a568fd43a32e1a91745ca4cd1d8fc6a32">lGetBasePointer()</a> doesn't return vec(offset) for the base pointer such that we then treat ptr2int(ptr) as an offset. This ends up being important so that we don't generate LLVM GEP instructions like "gep inttoptr 8, i64 %ptr", which in turn can lead to incorrect code since LLVM's pointer aliasing analysis assumes that operands after the first one to a GEP aren't pointers. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01000">1000</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01024">lGetBasePointer()</a>.</p>

</div>
</div>
<a class="anchor" id="a89b4a898512197020c886ae55ad4a7e7"></a><!-- doxytag: member="opt.cpp::lCoalesceGathers" ref="a89b4a898512197020c886ae55ad4a7e7" args="(const std::vector&lt; llvm::CallInst * &gt; &amp;coalesceGroup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lCoalesceGathers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::CallInst * &gt; &amp;&#160;</td>
          <td class="paramname"><em>coalesceGroup</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Actually do the coalescing. We have a set of gathers all accessing addresses of the form:</p>
<p>(ptr + {1,2,4,8} * varyingOffset) + constOffset, a.k.a. basePtr + constOffset</p>
<p>where varyingOffset actually has the same value across all of the SIMD lanes and where the part in parenthesis has the same value for all of the gathers in the group. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l03249">3249</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="llvmutil_8h_source.html#l00085">LLVMTypes::DoubleVectorType</a>, <a class="el" href="util_8h_source.html#l00113">FATAL</a>, <a class="el" href="llvmutil_8h_source.html#l00084">LLVMTypes::FloatVectorType</a>, <a class="el" href="llvmutil_8h_source.html#l00082">LLVMTypes::Int32VectorType</a>, <a class="el" href="llvmutil_8h_source.html#l00083">LLVMTypes::Int64VectorType</a>, <a class="el" href="opt_8cpp_source.html#l03143">lAssembleResultVectors()</a>, <a class="el" href="opt_8cpp_source.html#l02660">lCoalescePerfInfo()</a>, <a class="el" href="opt_8cpp_source.html#l03192">lComputeBasePtr()</a>, <a class="el" href="opt_8cpp_source.html#l02742">lEmitLoads()</a>, <a class="el" href="opt_8cpp_source.html#l03220">lExtractConstOffsets()</a>, <a class="el" href="opt_8cpp_source.html#l02606">lSelectLoads()</a>, <a class="el" href="opt_8cpp_source.html#l02808">lSplit8WideLoads()</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l03353">GatherCoalescePass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ac6bd161dcb83c2ac4c5bd2b3cd3bb9b4"></a><!-- doxytag: member="opt.cpp::lCoalescePerfInfo" ref="ac6bd161dcb83c2ac4c5bd2b3cd3bb9b4" args="(const std::vector&lt; llvm::CallInst * &gt; &amp;coalesceGroup, const std::vector&lt; CoalescedLoadOp &gt; &amp;loadOps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void lCoalescePerfInfo </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::CallInst * &gt; &amp;&#160;</td>
          <td class="paramname"><em>coalesceGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>loadOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Print a performance message with the details of the result of coalescing over a group of gathers. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02660">2660</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00124">SourcePos::first_line</a>, <a class="el" href="opt_8cpp_source.html#l00176">lGetSourcePosFromMetadata()</a>, and <a class="el" href="util_8cpp_source.html#l00418">PerformanceWarning()</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l03249">lCoalesceGathers()</a>.</p>

</div>
</div>
<a class="anchor" id="a750e741d5d8196d5aaa5a557e434750a"></a><!-- doxytag: member="opt.cpp::lComputeBasePtr" ref="a750e741d5d8196d5aaa5a557e434750a" args="(llvm::CallInst *gatherInst, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lComputeBasePtr </td>
          <td>(</td>
          <td class="paramtype">llvm::CallInst *&#160;</td>
          <td class="paramname"><em>gatherInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a call to a gather function, extract the base pointer, the 2/4/8 scale, and the first varying offsets value to use them to compute that scalar base pointer that is shared by all of the gathers in the group. (Thus, this base pointer plus the constant offsets term for each gather gives the set of addresses to use for each gather. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l03192">3192</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="llvmutil_8h_source.html#l00065">LLVMTypes::Int64Type</a>, <a class="el" href="opt_8cpp_source.html#l00261">lGEPInst()</a>, and <a class="el" href="llvmutil_8cpp_source.html#l01504">LLVMExtractFirstVectorElement()</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l03249">lCoalesceGathers()</a>.</p>

</div>
</div>
<a class="anchor" id="accadb004816ea7494e811c3a2d311641"></a><!-- doxytag: member="opt.cpp::lComputeCommonPointer" ref="accadb004816ea7494e811c3a2d311641" args="(llvm::Value *base, llvm::Value *offsets, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lComputeCommonPointer </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01987">1987</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="opt_8cpp_source.html#l00261">lGEPInst()</a>, and <a class="el" href="llvmutil_8cpp_source.html#l01504">LLVMExtractFirstVectorElement()</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02010">lGSToLoadStore()</a>.</p>

</div>
</div>
<a class="anchor" id="a7351c1b2da2303d0d65d7953ddf187ee"></a><!-- doxytag: member="opt.cpp::lConstElementsToMask" ref="a7351c1b2da2303d0d65d7953ddf187ee" args="(const llvm::SmallVector&lt; llvm::Constant *, ISPC_MAX_NVEC &gt; &amp;elements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t lConstElementsToMask </td>
          <td>(</td>
          <td class="paramtype">const llvm::SmallVector&lt; llvm::Constant *, ISPC_MAX_NVEC &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a vector of constant values (int, float, or bool) representing an execution mask, convert it to a bitvector where the 0th bit corresponds to the first vector value and so forth. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00275">275</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00311">lGetMask()</a>.</p>

</div>
</div>
<a class="anchor" id="ae626137870c4cecf7e885cc2e5a5d433"></a><!-- doxytag: member="opt.cpp::lCopyMetadata" ref="ae626137870c4cecf7e885cc2e5a5d433" args="(llvm::Value *vto, const llvm::Instruction *from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void lCopyMetadata </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>vto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::Instruction *&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This utility routine copies the metadata (if any) attached to the 'from' instruction in the IR to the 'to' instruction.</p>
<p>For flexibility, this function takes an llvm::Value rather than an llvm::Instruction for the 'to' parameter; at some places in the code below, we sometimes use a llvm::Value to start out storing a value and then later store instructions. If a llvm::Value is passed to this, the routine just returns without doing anything; if it is in fact an LLVM::Instruction, then the metadata can be copied to it. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00142">142</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01677">lGSToGSBaseOffsets()</a>, <a class="el" href="opt_8cpp_source.html#l02010">lGSToLoadStore()</a>, <a class="el" href="opt_8cpp_source.html#l02325">lImproveMaskedLoad()</a>, <a class="el" href="opt_8cpp_source.html#l02247">lImproveMaskedStore()</a>, <a class="el" href="opt_8cpp_source.html#l03565">lReplacePseudoMaskedStore()</a>, and <a class="el" href="opt_8cpp_source.html#l00680">IntrinsicsOpt::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ac39cdb1c2043099b4968cd306c410521"></a><!-- doxytag: member="opt.cpp::lEmitLoads" ref="ac39cdb1c2043099b4968cd306c410521" args="(llvm::Value *basePtr, std::vector&lt; CoalescedLoadOp &gt; &amp;loadOps, int elementSize, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void lEmitLoads </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>basePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>loadOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02742">2742</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="util_8cpp_source.html#l00390">Debug()</a>, <a class="el" href="util_8h_source.html#l00113">FATAL</a>, <a class="el" href="llvmutil_8h_source.html#l00064">LLVMTypes::Int32Type</a>, <a class="el" href="llvmutil_8h_source.html#l00065">LLVMTypes::Int64Type</a>, <a class="el" href="opt_8cpp_source.html#l02726">lGEPAndLoad()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00221">LLVMInt64()</a>, and <a class="el" href="opt_8cpp_source.html#l00088">PRId64</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l03249">lCoalesceGathers()</a>.</p>

</div>
</div>
<a class="anchor" id="a6b7adc00a1832b7937542e9f70d7a008"></a><!-- doxytag: member="opt.cpp::lExtract248Scale" ref="a6b7adc00a1832b7937542e9f70d7a008" args="(llvm::Value *splatOperand, int splatValue, llvm::Value *otherOperand, llvm::Value **result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lExtract248Scale </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>splatOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splatValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>otherOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01386">1386</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="llvmutil_8h_source.html#l00082">LLVMTypes::Int32VectorType</a>, <a class="el" href="llvmutil_8cpp_source.html#l00207">LLVMInt32()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00323">LLVMInt32Vector()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00399">LLVMInt64Vector()</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01436">lExtractOffsetVector248Scale()</a>.</p>

</div>
</div>
<a class="anchor" id="adce013e717663e5e455ad1d4b6ddb35a"></a><!-- doxytag: member="opt.cpp::lExtractConstantOffset" ref="adce013e717663e5e455ad1d4b6ddb35a" args="(llvm::Value *vec, llvm::Value **constOffset, llvm::Value **variableOffset, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void lExtractConstantOffset </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value **&#160;</td>
          <td class="paramname"><em>constOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value **&#160;</td>
          <td class="paramname"><em>variableOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a vector expression in vec, separate it into a compile-time constant component and a variable component, returning the two parts in constOffset and *variableOffset. (It should be the case that the sum of these two is exactly equal to the original vector.)</p>
<p>This routine only handles some (important) patterns; in some cases it will fail and return components that are actually compile-time constants in *variableOffset.</p>
<p>Finally, if there aren't any constant (or, respectivaly, variable) components, the corresponding return value may be set to NULL. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01232">1232</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="llvmutil_8cpp_source.html#l01558">LLVMGetName()</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01849">lGSBaseOffsetsGetMoreConst()</a>, and <a class="el" href="opt_8cpp_source.html#l01677">lGSToGSBaseOffsets()</a>.</p>

</div>
</div>
<a class="anchor" id="a20477c5575b29732597e1bb3d7e787df"></a><!-- doxytag: member="opt.cpp::lExtractConstOffsets" ref="a20477c5575b29732597e1bb3d7e787df" args="(const std::vector&lt; llvm::CallInst * &gt; &amp;coalesceGroup, int elementSize, std::vector&lt; int64_t &gt; *constOffsets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void lExtractConstOffsets </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::CallInst * &gt; &amp;&#160;</td>
          <td class="paramname"><em>coalesceGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>constOffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extract the constant offsets (from the common base pointer) from each of the gathers in a set to be coalesced. These come in as byte offsets, but we'll transform them into offsets in terms of the size of the base scalar type being gathered. (e.g. for an i32 gather, we might have offsets like &lt;0,4,16,20&gt;, which would be transformed to &lt;0,1,4,5&gt; here.) </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l03220">3220</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="llvmutil_8cpp_source.html#l00643">LLVMExtractVectorInts()</a>, <a class="el" href="ispc_8h_source.html#l00377">Globals::target</a>, and <a class="el" href="ispc_8h_source.html#l00235">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l03249">lCoalesceGathers()</a>.</p>

</div>
</div>
<a class="anchor" id="a5cce8aeb24479c1f288199fba4f5e4c2"></a><!-- doxytag: member="opt.cpp::lExtractFromInserts" ref="a5cce8aeb24479c1f288199fba4f5e4c2" args="(llvm::Value *v, unsigned int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lExtractFromInserts </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01077">1077</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01096">lGetBasePtrAndOffsets()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e57e1615411b94fc8171f6180b9d762"></a><!-- doxytag: member="opt.cpp::lExtractOffsetVector248Scale" ref="a8e57e1615411b94fc8171f6180b9d762" args="(llvm::Value **vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lExtractOffsetVector248Scale </td>
          <td>(</td>
          <td class="paramtype">llvm::Value **&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a vector of integer offsets to a base pointer being used for a gather or a scatter, see if its root operation is a multiply by a vector of some value by all 2s/4s/8s. If not, return NULL.</p>
<p>If it is return an i32 value of 2, 4, 8 from the function and modify vec so that it points to the operand that is being multiplied by 2/4/8.</p>
<p>We go through all this trouble so that we can pass the i32 scale factor to the {gather,scatter}_base_offsets function as a separate scale factor for the offsets. This in turn is used in a way so that the LLVM x86 code generator matches it to apply x86's free scale by 2x, 4x, or 8x to one of two registers being added together for an addressing calculation. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01436">1436</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="opt_8cpp_source.html#l01386">lExtract248Scale()</a>, <a class="el" href="opt_8cpp_source.html#l01360">lIsIntegerSplat()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00207">LLVMInt32()</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01677">lGSToGSBaseOffsets()</a>.</p>

</div>
</div>
<a class="anchor" id="a35652ce326fb0932c7e92e493ed716f2"></a><!-- doxytag: member="opt.cpp::lGEPAndLoad" ref="a35652ce326fb0932c7e92e493ed716f2" args="(llvm::Value *basePtr, int64_t offset, int align, llvm::Instruction *insertBefore, llvm::Type *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* lGEPAndLoad </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>basePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Utility routine that computes an offset from a base pointer and then returns the result of a load of the given type from the resulting location:</p>
<p>return *((type *)(basePtr + offset)) </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02726">2726</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="opt_8cpp_source.html#l00261">lGEPInst()</a>, and <a class="el" href="llvmutil_8cpp_source.html#l00221">LLVMInt64()</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02742">lEmitLoads()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c01ae41fd09d742d341f5f5293838f2"></a><!-- doxytag: member="opt.cpp::lGEPInst" ref="a3c01ae41fd09d742d341f5f5293838f2" args="(llvm::Value *ptr, llvm::Value *offset, const char *name, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Instruction* lGEPInst </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00261">261</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l03192">lComputeBasePtr()</a>, <a class="el" href="opt_8cpp_source.html#l01987">lComputeCommonPointer()</a>, and <a class="el" href="opt_8cpp_source.html#l02726">lGEPAndLoad()</a>.</p>

</div>
</div>
<a class="anchor" id="a568fd43a32e1a91745ca4cd1d8fc6a32"></a><!-- doxytag: member="opt.cpp::lGetBasePointer" ref="a568fd43a32e1a91745ca4cd1d8fc6a32" args="(llvm::Value *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lGetBasePointer </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a llvm::Value representing a varying pointer, this function checks to see if all of the elements of the vector have the same value (i.e. there's a common base pointer). If so, it returns the common pointer value; otherwise it returns NULL. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01024">1024</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="ispc_8h_source.html#l00064">ISPC_MAX_NVEC</a>, <a class="el" href="opt_8cpp_source.html#l01000">lCheckForActualPointer()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00599">LLVMFlattenInsertChain()</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="ispc_8h_source.html#l00377">Globals::target</a>, and <a class="el" href="ispc_8h_source.html#l00235">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01096">lGetBasePtrAndOffsets()</a>.</p>

</div>
</div>
<a class="anchor" id="ac6ced32908e9773085ec13530d64b96c"></a><!-- doxytag: member="opt.cpp::lGetBasePtrAndOffsets" ref="ac6ced32908e9773085ec13530d64b96c" args="(llvm::Value *ptrs, llvm::Value **offsets, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lGetBasePtrAndOffsets </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>ptrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a varying pointer in ptrs, this function checks to see if it can be determined to be indexing from a common uniform base pointer. If so, the function returns the base pointer llvm::Value and initializes offsets with an int vector of the per-lane offsets </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01096">1096</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="ispc_8h_source.html#l00394">Globals::debugPrint</a>, <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="ispc_8h_source.html#l00219">Target::is32Bit</a>, <a class="el" href="ispc_8h_source.html#l00064">ISPC_MAX_NVEC</a>, <a class="el" href="opt_8cpp_source.html#l01077">lExtractFromInserts()</a>, <a class="el" href="opt_8cpp_source.html#l01024">lGetBasePointer()</a>, <a class="el" href="opt_8cpp_source.html#l01059">lGetConstantAddExprBaseOffset()</a>, <a class="el" href="llvmutil_8cpp_source.html#l01385">LLVMDumpValue()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00207">LLVMInt32()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00323">LLVMInt32Vector()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00221">LLVMInt64()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00399">LLVMInt64Vector()</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="parse_8yy.html">stderr</a>, and <a class="el" href="ispc_8h_source.html#l00377">Globals::target</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01677">lGSToGSBaseOffsets()</a>.</p>

</div>
</div>
<a class="anchor" id="af47f2481f316b98aa8a37354e1e1473c"></a><!-- doxytag: member="opt.cpp::lGetConstantAddExprBaseOffset" ref="af47f2481f316b98aa8a37354e1e1473c" args="(llvm::Constant *op0, llvm::Constant *op1, llvm::Constant **delta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Constant* lGetConstantAddExprBaseOffset </td>
          <td>(</td>
          <td class="paramtype">llvm::Constant *&#160;</td>
          <td class="paramname"><em>op0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Constant *&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Constant **&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given the two operands to a constant add expression, see if we have the form "base pointer + offset", whee op0 is the base pointer and op1 is the offset; if so return the base and the offset. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01059">1059</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01096">lGetBasePtrAndOffsets()</a>.</p>

</div>
</div>
<a class="anchor" id="a04415f5411b9d1e3c664116804a1c72e"></a><!-- doxytag: member="opt.cpp::lGetMask" ref="a04415f5411b9d1e3c664116804a1c72e" args="(llvm::Value *factor, uint64_t *mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lGetMask </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given an llvm::Value represinting a vector mask, see if the value is a constant. If so, return true and set *bits to be the integer mask found by taking the high bits of the mask values in turn and concatenating them into a single integer. In other words, given the 4-wide mask: &lt; 0xffffffff, 0, 0, 0xffffffff &gt;, we have 0b1001 = 9. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00311">311</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="ispc_8cpp_source.html#l00429">Target::GetTargetMachine()</a>, <a class="el" href="opt_8cpp_source.html#l00275">lConstElementsToMask()</a>, <a class="el" href="parse_8yy.html">NULL</a>, and <a class="el" href="ispc_8h_source.html#l00377">Globals::target</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00368">lGetMaskStatus()</a>, <a class="el" href="opt_8cpp_source.html#l00680">IntrinsicsOpt::runOnBasicBlock()</a>, and <a class="el" href="opt_8cpp_source.html#l00899">VSelMovmskOpt::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a3d02f9665198cc4b6fd98ae63ea7a983"></a><!-- doxytag: member="opt.cpp::lGetMaskStatus" ref="a3d02f9665198cc4b6fd98ae63ea7a983" args="(llvm::Value *mask, int vecWidth=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="opt_8cpp.html#a49b78092c0a6c04e2786364fe785528f">MaskStatus</a> lGetMaskStatus </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vecWidth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines if the given mask value is all on, all off, mixed, or unknown at compile time. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00368">368</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="opt_8cpp_source.html#l00362">ALL_OFF</a>, <a class="el" href="opt_8cpp_source.html#l00362">ALL_ON</a>, <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="opt_8cpp_source.html#l00311">lGetMask()</a>, <a class="el" href="opt_8cpp_source.html#l00362">MIXED</a>, <a class="el" href="ispc_8h_source.html#l00377">Globals::target</a>, <a class="el" href="opt_8cpp_source.html#l00362">UNKNOWN</a>, and <a class="el" href="ispc_8h_source.html#l00235">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02325">lImproveMaskedLoad()</a>, <a class="el" href="opt_8cpp_source.html#l02247">lImproveMaskedStore()</a>, <a class="el" href="opt_8cpp_source.html#l00899">VSelMovmskOpt::runOnBasicBlock()</a>, and <a class="el" href="opt_8cpp_source.html#l03353">GatherCoalescePass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ce816b84cb0c2ca769c486be11dde5f"></a><!-- doxytag: member="opt.cpp::lGetSourcePosFromMetadata" ref="a9ce816b84cb0c2ca769c486be11dde5f" args="(const llvm::Instruction *inst, SourcePos *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lGetSourcePosFromMetadata </td>
          <td>(</td>
          <td class="paramtype">const llvm::Instruction *&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSourcePos.html">SourcePos</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>We have a protocol with the front-end LLVM IR code generation process that allows us to encode the source file position that corresponds with instructions. (For example, this allows us to issue performance warnings related to things like scatter and gather after optimization has been performed, so that we aren't warning about scatters and gathers that have been improved to stores and loads by optimization passes.) Note that this is slightly redundant with the source file position encoding generated for debugging symbols, though we don't always generate debugging information but we do always generate this position data.</p>
<p>This function finds the <a class="el" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> that the metadata in the instruction (if present) corresponds to. See the implementation of <a class="el" href="classFunctionEmitContext.html#a9ee143b924166a394849030280512e00">FunctionEmitContext::addGSMetadata()</a>, which encodes the source position during code generation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>Instruction to try to find the source position of </td></tr>
    <tr><td class="paramname">pos</td><td>Output variable in which to store the position </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if source file position metadata was present and *pos has been set. False otherwise. </dd></dl>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00176">176</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, and <a class="el" href="lex_8ll_source.html#l180317">filename</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02660">lCoalescePerfInfo()</a>, <a class="el" href="opt_8cpp_source.html#l02010">lGSToLoadStore()</a>, <a class="el" href="opt_8cpp_source.html#l03628">lReplacePseudoGS()</a>, and <a class="el" href="opt_8cpp_source.html#l03353">GatherCoalescePass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="afc6d92c9ffeab46f08584419178582fe"></a><!-- doxytag: member="opt.cpp::lGSBaseOffsetsGetMoreConst" ref="afc6d92c9ffeab46f08584419178582fe" args="(llvm::CallInst *callInst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lGSBaseOffsetsGetMoreConst </td>
          <td>(</td>
          <td class="paramtype">llvm::CallInst *&#160;</td>
          <td class="paramname"><em>callInst</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Try to improve the decomposition between compile-time constant and compile-time unknown offsets in calls to the __pseudo_*_base_offsets* functions. Other other optimizations have run, we will sometimes be able to pull more terms out of the unknown part and add them into the compile-time-known part. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01849">1849</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="parse_8yy_source.html#l310999">int32_t</a>, <a class="el" href="llvmutil_8h_source.html#l00083">LLVMTypes::Int64VectorType</a>, <a class="el" href="opt_8cpp_source.html#l01232">lExtractConstantOffset()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00323">LLVMInt32Vector()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00399">LLVMInt64Vector()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00476">LLVMIntAsType()</a>, <a class="el" href="ispc_8cpp_source.html#l00066">m</a>, <a class="el" href="module_8h_source.html#l00151">Module::module</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02388">ImproveMemoryOpsPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a416fbd7585671f21b02c2e4c4af0e60c"></a><!-- doxytag: member="opt.cpp::lGSToGSBaseOffsets" ref="a416fbd7585671f21b02c2e4c4af0e60c" args="(llvm::CallInst *callInst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lGSToGSBaseOffsets </td>
          <td>(</td>
          <td class="paramtype">llvm::CallInst *&#160;</td>
          <td class="paramname"><em>callInst</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01677">1677</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="ispc_8h_source.html#l00295">Opt::force32BitAddressing</a>, <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="opt_8cpp_source.html#l00210">lCallInst()</a>, <a class="el" href="opt_8cpp_source.html#l00142">lCopyMetadata()</a>, <a class="el" href="opt_8cpp_source.html#l01232">lExtractConstantOffset()</a>, <a class="el" href="opt_8cpp_source.html#l01436">lExtractOffsetVector248Scale()</a>, <a class="el" href="opt_8cpp_source.html#l01096">lGetBasePtrAndOffsets()</a>, <a class="el" href="llvmutil_8cpp_source.html#l01558">LLVMGetName()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00476">LLVMIntAsType()</a>, <a class="el" href="opt_8cpp_source.html#l01624">lOffsets32BitSafe()</a>, <a class="el" href="ispc_8cpp_source.html#l00066">m</a>, <a class="el" href="module_8h_source.html#l00151">Module::module</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="ispc_8h_source.html#l00375">Globals::opt</a>, and <a class="el" href="llvmutil_8h_source.html#l00058">LLVMTypes::VoidPointerType</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02388">ImproveMemoryOpsPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a483d09d1f5b53eab2fe5f2e1c2597e3a"></a><!-- doxytag: member="opt.cpp::lGSToLoadStore" ref="a483d09d1f5b53eab2fe5f2e1c2597e3a" args="(llvm::CallInst *callInst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lGSToLoadStore </td>
          <td>(</td>
          <td class="paramtype">llvm::CallInst *&#160;</td>
          <td class="paramname"><em>callInst</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After earlier optimization passes have run, we are sometimes able to determine that gathers/scatters are actually accessing memory in a more regular fashion and then change the operation to something simpler and more efficient. For example, if all of the lanes in a gather are reading from the same location, we can instead do a scalar load and broadcast. This pass examines gathers and scatters and tries to simplify them if at all possible.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Currently, this only looks for all program instances going to the same location and all going to a linear sequence of locations in memory. There are a number of other cases that might make sense to look for, including things that could be handled with a vector load + shuffle or things that could be handled with hybrids of e.g. 2 4-wide vector loads with AVX, etc. </dd></dl>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02010">2010</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="util_8cpp_source.html#l00390">Debug()</a>, <a class="el" href="llvmutil_8h_source.html#l00067">LLVMTypes::DoubleType</a>, <a class="el" href="llvmutil_8h_source.html#l00092">LLVMTypes::DoubleVectorPointerType</a>, <a class="el" href="llvmutil_8h_source.html#l00066">LLVMTypes::FloatType</a>, <a class="el" href="llvmutil_8h_source.html#l00091">LLVMTypes::FloatVectorPointerType</a>, <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="llvmutil_8h_source.html#l00063">LLVMTypes::Int16Type</a>, <a class="el" href="llvmutil_8h_source.html#l00088">LLVMTypes::Int16VectorPointerType</a>, <a class="el" href="parse_8yy_source.html#l310999">int32_t</a>, <a class="el" href="llvmutil_8h_source.html#l00064">LLVMTypes::Int32Type</a>, <a class="el" href="llvmutil_8h_source.html#l00089">LLVMTypes::Int32VectorPointerType</a>, <a class="el" href="llvmutil_8h_source.html#l00065">LLVMTypes::Int64Type</a>, <a class="el" href="llvmutil_8h_source.html#l00090">LLVMTypes::Int64VectorPointerType</a>, <a class="el" href="llvmutil_8h_source.html#l00083">LLVMTypes::Int64VectorType</a>, <a class="el" href="llvmutil_8h_source.html#l00062">LLVMTypes::Int8Type</a>, <a class="el" href="llvmutil_8h_source.html#l00087">LLVMTypes::Int8VectorPointerType</a>, <a class="el" href="opt_8cpp_source.html#l00210">lCallInst()</a>, <a class="el" href="opt_8cpp_source.html#l01987">lComputeCommonPointer()</a>, <a class="el" href="opt_8cpp_source.html#l00142">lCopyMetadata()</a>, <a class="el" href="opt_8cpp_source.html#l00176">lGetSourcePosFromMetadata()</a>, <a class="el" href="llvmutil_8cpp_source.html#l01558">LLVMGetName()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00207">LLVMInt32()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00221">LLVMInt64()</a>, <a class="el" href="llvmutil_8cpp_source.html#l01346">LLVMVectorIsLinear()</a>, <a class="el" href="llvmutil_8cpp_source.html#l01076">LLVMVectorValuesAllEqual()</a>, <a class="el" href="ispc_8cpp_source.html#l00066">m</a>, <a class="el" href="module_8h_source.html#l00151">Module::module</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="ispc_8h_source.html#l00377">Globals::target</a>, <a class="el" href="ispc_8h_source.html#l00235">Target::vectorWidth</a>, and <a class="el" href="util_8cpp_source.html#l00402">Warning()</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02388">ImproveMemoryOpsPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a0ef5259b06f72e3a8d5eddb1a73ea3e9"></a><!-- doxytag: member="opt.cpp::lImproveMaskedLoad" ref="a0ef5259b06f72e3a8d5eddb1a73ea3e9" args="(llvm::CallInst *callInst, llvm::BasicBlock::iterator iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lImproveMaskedLoad </td>
          <td>(</td>
          <td class="paramtype">llvm::CallInst *&#160;</td>
          <td class="paramname"><em>callInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::BasicBlock::iterator&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02325">2325</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="opt_8cpp_source.html#l00362">ALL_OFF</a>, <a class="el" href="opt_8cpp_source.html#l00362">ALL_ON</a>, <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="opt_8cpp_source.html#l00142">lCopyMetadata()</a>, <a class="el" href="opt_8cpp_source.html#l00368">lGetMaskStatus()</a>, <a class="el" href="ispc_8cpp_source.html#l00066">m</a>, <a class="el" href="module_8h_source.html#l00151">Module::module</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02388">ImproveMemoryOpsPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="aa1fbd436abbd761d1097793a6d261d66"></a><!-- doxytag: member="opt.cpp::lImproveMaskedStore" ref="aa1fbd436abbd761d1097793a6d261d66" args="(llvm::CallInst *callInst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lImproveMaskedStore </td>
          <td>(</td>
          <td class="paramtype">llvm::CallInst *&#160;</td>
          <td class="paramname"><em>callInst</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Masked stores are generally more complex than regular stores; for example, they require multiple instructions to simulate under SSE. This optimization detects cases where masked stores can be replaced with regular stores or removed entirely, for the cases of an 'all on' mask and an 'all off' mask, respectively. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02247">2247</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="opt_8cpp_source.html#l00362">ALL_OFF</a>, <a class="el" href="opt_8cpp_source.html#l00362">ALL_ON</a>, <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="opt_8cpp_source.html#l00142">lCopyMetadata()</a>, <a class="el" href="opt_8cpp_source.html#l00368">lGetMaskStatus()</a>, <a class="el" href="ispc_8cpp_source.html#l00066">m</a>, <a class="el" href="module_8h_source.html#l00151">Module::module</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02388">ImproveMemoryOpsPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e9c006f2dbccb2cad3e63ac8ada1dbd"></a><!-- doxytag: member="opt.cpp::lInstructionMayWriteToMemory" ref="a4e9c006f2dbccb2cad3e63ac8ada1dbd" args="(llvm::Instruction *inst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lInstructionMayWriteToMemory </td>
          <td>(</td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given an instruction, returns true if the instructon may write to memory. This is a conservative test in that it may return true for some instructions that don't actually end up writing to memory, but should never return false for an instruction that does write to memory. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l03326">3326</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l03353">GatherCoalescePass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a3bdaa6f11aebf4775d0f369602f3b026"></a><!-- doxytag: member="opt.cpp::lIsIntegerSplat" ref="a3bdaa6f11aebf4775d0f369602f3b026" args="(llvm::Value *v, int *splat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lIsIntegerSplat </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>splat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01360">1360</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01436">lExtractOffsetVector248Scale()</a>.</p>

</div>
</div>
<a class="anchor" id="a432c7725f35dbabfc537a1f2b91b85ca"></a><!-- doxytag: member="opt.cpp::lIsSafeToBlend" ref="a432c7725f35dbabfc537a1f2b91b85ca" args="(llvm::Value *lvalue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lIsSafeToBlend </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>lvalue</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine attempts to determine if the given pointer in lvalue is pointing to stack-allocated memory. It's conservative in that it should never return true for non-stack allocated memory, but may return false for memory that actually is stack allocated. The basic strategy is to traverse through the operands and see if the pointer originally comes from an AllocaInst. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l03531">3531</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="ispc_8h_source.html#l00377">Globals::target</a>, and <a class="el" href="ispc_8h_source.html#l00235">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l03565">lReplacePseudoMaskedStore()</a>.</p>

</div>
</div>
<a class="anchor" id="a22173061ee4fe22a8ed7f20e32b40ad8"></a><!-- doxytag: member="opt.cpp::lIsUndef" ref="a22173061ee4fe22a8ed7f20e32b40ad8" args="(llvm::Value *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lIsUndef </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given an llvm::Value, return true if we can determine that it's an undefined value. This only makes a weak attempt at chasing this down, only detecting flat-out undef values, and bitcasts of undef values.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Is it worth working harder to find more of these? It starts to get tricky, since having an undef operand doesn't necessarily mean that the result will be undefined. (And for that matter, is there an LLVM call that will do this for us?) </dd></dl>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00667">667</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00680">IntrinsicsOpt::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f14dd2deb4b07e1ab1beedb817ad014"></a><!-- doxytag: member="opt.cpp::lOffsets32BitSafe" ref="a6f14dd2deb4b07e1ab1beedb817ad014" args="(llvm::Value **variableOffsetPtr, llvm::Value **constOffsetPtr, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lOffsets32BitSafe </td>
          <td>(</td>
          <td class="paramtype">llvm::Value **&#160;</td>
          <td class="paramname"><em>variableOffsetPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value **&#160;</td>
          <td class="paramname"><em>constOffsetPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check to see if the two offset vectors can safely be represented with 32-bit values. If so, return true and update the pointed-to llvm::Value *s to be the 32-bit equivalents. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01624">1624</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="llvmutil_8h_source.html#l00082">LLVMTypes::Int32VectorType</a>, <a class="el" href="llvmutil_8cpp_source.html#l01558">LLVMGetName()</a>, <a class="el" href="opt_8cpp_source.html#l01606">lVectorIs32BitInts()</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01677">lGSToGSBaseOffsets()</a>.</p>

</div>
</div>
<a class="anchor" id="a9cccdfb4848eb19c4edd227272f38c6d"></a><!-- doxytag: member="opt.cpp::lReplacePseudoGS" ref="a9cccdfb4848eb19c4edd227272f38c6d" args="(llvm::CallInst *callInst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lReplacePseudoGS </td>
          <td>(</td>
          <td class="paramtype">llvm::CallInst *&#160;</td>
          <td class="paramname"><em>callInst</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l03628">3628</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="opt_8cpp_source.html#l00176">lGetSourcePosFromMetadata()</a>, <a class="el" href="ispc_8cpp_source.html#l00066">m</a>, <a class="el" href="module_8h_source.html#l00151">Module::module</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="util_8cpp_source.html#l00418">PerformanceWarning()</a>, <a class="el" href="ispc_8h_source.html#l00377">Globals::target</a>, and <a class="el" href="ispc_8h_source.html#l00235">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l03730">ReplacePseudoMemoryOpsPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a280822c558759501011ceb299035d26c"></a><!-- doxytag: member="opt.cpp::lReplacePseudoMaskedStore" ref="a280822c558759501011ceb299035d26c" args="(llvm::CallInst *callInst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lReplacePseudoMaskedStore </td>
          <td>(</td>
          <td class="paramtype">llvm::CallInst *&#160;</td>
          <td class="paramname"><em>callInst</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l03565">3565</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00150">Assert</a>, <a class="el" href="ispc_8h_source.html#l00320">Opt::disableBlendedMaskedStores</a>, <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="opt_8cpp_source.html#l00210">lCallInst()</a>, <a class="el" href="opt_8cpp_source.html#l00142">lCopyMetadata()</a>, <a class="el" href="opt_8cpp_source.html#l03531">lIsSafeToBlend()</a>, <a class="el" href="ispc_8cpp_source.html#l00066">m</a>, <a class="el" href="module_8h_source.html#l00151">Module::module</a>, <a class="el" href="parse_8yy.html">NULL</a>, and <a class="el" href="ispc_8h_source.html#l00375">Globals::opt</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l03730">ReplacePseudoMemoryOpsPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ae037d63652cb821b0bfe3afc19a9257e"></a><!-- doxytag: member="opt.cpp::lSelectLoads" ref="ae037d63652cb821b0bfe3afc19a9257e" args="(const std::vector&lt; int64_t &gt; &amp;loadOffsets, std::vector&lt; CoalescedLoadOp &gt; *loads)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void lSelectLoads </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>loadOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &gt; *&#160;</td>
          <td class="paramname"><em>loads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a set of offsets from a common base pointer that we need to get loaded into memory, determine a reasonable set of load operations that gets all of the corresponding values in memory (ideally, including as many as possible wider vector loads rather than scalar loads). Return a <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> for each one in the *loads array. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02606">2606</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="util_8cpp_source.html#l00390">Debug()</a>, <a class="el" href="opt_8cpp_source.html#l02505">lVectorLoadIsEfficient()</a>, and <a class="el" href="opt_8cpp_source.html#l00088">PRId64</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l03249">lCoalesceGathers()</a>.</p>

</div>
</div>
<a class="anchor" id="ae7ff7a0156aa50b53b494e4a41c61dfb"></a><!-- doxytag: member="opt.cpp::lSplit8WideLoads" ref="ae7ff7a0156aa50b53b494e4a41c61dfb" args="(const std::vector&lt; CoalescedLoadOp &gt; &amp;loadOps, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;<a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a>&gt; lSplit8WideLoads </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCoalescedLoadOp.html">CoalescedLoadOp</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>loadOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert any loads of 8-wide vectors into two 4-wide vectors (logically). This allows the assembly code below to always operate on 4-wide vectors, which leads to better code. Returns a new vector of load operations. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02808">2808</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy_source.html#l310999">int32_t</a>, and <a class="el" href="llvmutil_8cpp_source.html#l01540">LLVMShuffleVectors()</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l03249">lCoalesceGathers()</a>.</p>

</div>
</div>
<a class="anchor" id="a780f599aabf28e9c16d7f3de9d853a92"></a><!-- doxytag: member="opt.cpp::lVectorIs32BitInts" ref="a780f599aabf28e9c16d7f3de9d853a92" args="(llvm::Value *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lVectorIs32BitInts </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01606">1606</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy_source.html#l310999">int32_t</a>, <a class="el" href="ispc_8h_source.html#l00064">ISPC_MAX_NVEC</a>, and <a class="el" href="llvmutil_8cpp_source.html#l00643">LLVMExtractVectorInts()</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01624">lOffsets32BitSafe()</a>.</p>

</div>
</div>
<a class="anchor" id="a6925a69b3ebc6616ffa6a0dce8fa675b"></a><!-- doxytag: member="opt.cpp::lVectorLoadIsEfficient" ref="a6925a69b3ebc6616ffa6a0dce8fa675b" args="(std::set&lt; int64_t &gt;::iterator iter, std::set&lt; int64_t &gt;::iterator end, std::set&lt; int64_t &gt;::iterator *newIter, int vectorWidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lVectorLoadIsEfficient </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; int64_t &gt;::iterator&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int64_t &gt;::iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int64_t &gt;::iterator *&#160;</td>
          <td class="paramname"><em>newIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vectorWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function determines whether it makes sense (and is safe) to generate a vector load of width vectorWidth, starting at *iter. It returns true if so, setting *newIter to point to the next element in the set that isn't taken care of by the generated load. If a vector load of the given width doesn't make sense, then false is returned. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02505">2505</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02606">lSelectLoads()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a7faa9c8af29d05713e5d15fdff1810"></a><!-- doxytag: member="opt.cpp::Optimize" ref="a2a7faa9c8af29d05713e5d15fdff1810" args="(llvm::Module *module, int optLevel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Optimize the functions in the given module, applying the specified level of optimization. optLevel zero corresponds to essentially no optimization--just enough to generate correct code, while level one corresponds to full optimization. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00391">391</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="opt_8cpp_source.html#l03499">CreateGatherCoalescePass()</a>, <a class="el" href="opt_8cpp_source.html#l02432">CreateImproveMemoryOpsPass()</a>, <a class="el" href="opt_8cpp_source.html#l00870">CreateIntrinsicsOptPass()</a>, <a class="el" href="opt_8cpp_source.html#l03864">CreateIsCompileTimeConstantPass()</a>, <a class="el" href="opt_8cpp_source.html#l03965">CreateMakeInternalFuncsStaticPass()</a>, <a class="el" href="opt_8cpp_source.html#l03759">CreateReplacePseudoMemoryOpsPass()</a>, <a class="el" href="opt_8cpp_source.html#l00959">CreateVSelMovmskOptPass()</a>, <a class="el" href="ispc_8h_source.html#l00394">Globals::debugPrint</a>, <a class="el" href="ispc_8h_source.html#l00360">Opt::disableCoalescing</a>, <a class="el" href="ispc_8h_source.html#l00338">Opt::disableGatherScatterOptimizations</a>, <a class="el" href="ispc_8h_source.html#l00310">Opt::disableHandlePseudoMemoryOps</a>, <a class="el" href="ispc_8h_source.html#l00304">Opt::disableMaskAllOnOptimizations</a>, <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="ispc_8h_source.html#l00210">Target::GENERIC</a>, <a class="el" href="ispc_8h_source.html#l00213">Target::isa</a>, <a class="el" href="ispc_8h_source.html#l00375">Globals::opt</a>, <a class="el" href="ispc_8h_source.html#l00377">Globals::target</a>, <a class="el" href="ispc_8h_source.html#l00289">Opt::unrollLoops</a>, and <a class="el" href="ispc_8h_source.html#l00235">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00367">Module::AddGlobalVariable()</a>, <a class="el" href="module_8cpp_source.html#l00299">Module::CompileFile()</a>, <a class="el" href="decl_8cpp_source.html#l00294">Declarator::InitFromType()</a>, and <a class="el" href="expr_8cpp_source.html#l00150">lArrayToPointer()</a>.</p>

</div>
</div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 29 2012 08:42:26 for Intel SPMD Program Compiler by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
