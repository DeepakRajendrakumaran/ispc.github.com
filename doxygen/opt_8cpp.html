<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Intel SPMD Program Compiler: opt.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>opt.cpp File Reference</h1>  </div>
</div>
<div class="contents">

<p>Implementations of various ispc optimization passes that operate on the LLVM IR.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="opt_8h_source.html">opt.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ctx_8h_source.html">ctx.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sym_8h_source.html">sym.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="module_8h_source.html">module.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="llvmutil_8h_source.html">llvmutil.h</a>&quot;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;llvm/Pass.h&gt;</code><br/>
<code>#include &lt;llvm/Module.h&gt;</code><br/>
<code>#include &lt;llvm/PassManager.h&gt;</code><br/>
<code>#include &lt;llvm/PassRegistry.h&gt;</code><br/>
<code>#include &lt;llvm/Assembly/PrintModulePass.h&gt;</code><br/>
<code>#include &lt;llvm/Function.h&gt;</code><br/>
<code>#include &lt;llvm/BasicBlock.h&gt;</code><br/>
<code>#include &lt;llvm/Instructions.h&gt;</code><br/>
<code>#include &lt;llvm/Intrinsics.h&gt;</code><br/>
<code>#include &lt;llvm/Constants.h&gt;</code><br/>
<code>#include &lt;llvm/Analysis/ConstantFolding.h&gt;</code><br/>
<code>#include &lt;llvm/Target/TargetLibraryInfo.h&gt;</code><br/>
<code>#include &lt;llvm/Transforms/IPO/PassManagerBuilder.h&gt;</code><br/>
<code>#include &lt;llvm/ADT/Triple.h&gt;</code><br/>
<code>#include &lt;llvm/Transforms/Scalar.h&gt;</code><br/>
<code>#include &lt;llvm/Transforms/IPO.h&gt;</code><br/>
<code>#include &lt;llvm/Transforms/Utils/BasicBlockUtils.h&gt;</code><br/>
<code>#include &lt;llvm/Target/TargetOptions.h&gt;</code><br/>
<code>#include &lt;llvm/Target/TargetData.h&gt;</code><br/>
<code>#include &lt;llvm/Target/TargetMachine.h&gt;</code><br/>
<code>#include &lt;llvm/Analysis/Verifier.h&gt;</code><br/>
<code>#include &lt;llvm/Support/raw_ostream.h&gt;</code><br/>
<code>#include &lt;llvm/Analysis/DIBuilder.h&gt;</code><br/>
<code>#include &lt;llvm/Analysis/DebugInfo.h&gt;</code><br/>
<code>#include &lt;llvm/Support/Dwarf.h&gt;</code><br/>
<!-- startSectionHeader --><div class="dynheader">
Include dependency graph for opt.cpp:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
<div class="center"><img src="opt_8cpp__incl.png" border="0" usemap="#opt_8cpp" alt=""/></div>
<map name="opt_8cpp" id="opt_8cpp">
<area shape="rect" id="node3" href="opt_8h.html" title="Declarations related to optimization passes." alt="" coords="901,161,957,189"/><area shape="rect" id="node25" href="ctx_8h.html" title="Declaration of the FunctionEmitContext class." alt="" coords="407,83,463,111"/><area shape="rect" id="node36" href="sym_8h.html" title="header file with declarations for symbol and symbol table classes." alt="" coords="1067,83,1128,111"/><area shape="rect" id="node44" href="module_8h.html" title="Declaration of the Module class, which is the ispc&#45;side representation of the results of compiling a ..." alt="" coords="1323,83,1408,111"/><area shape="rect" id="node49" href="util_8h.html" title="util.h" alt="" coords="5,161,61,189"/><area shape="rect" id="node52" href="llvmutil_8h.html" title="Header file with declarations for various LLVM utility stuff." alt="" coords="1163,83,1248,111"/><area shape="rect" id="node5" href="ispc_8h.html" title="Main ispc.header file." alt="" coords="1056,238,1117,266"/><area shape="rect" id="node7" href="assert_8h.html" title="assert.h" alt="" coords="817,315,892,343"/><area shape="rect" id="node15" href="stdint_8h.html" title="stdint.h" alt="" coords="916,315,988,343"/><area shape="rect" id="node9" href="cdefs_8h.html" title="sys/cdefs.h" alt="" coords="807,393,903,421"/><area shape="rect" id="node11" href="__symbol__aliasing_8h.html" title="sys/_symbol_aliasing.h" alt="" coords="665,470,841,498"/><area shape="rect" id="node13" href="__posix__availability_8h.html" title="sys/_posix_availability.h" alt="" coords="865,470,1047,498"/><area shape="rect" id="node39" href="decl_8h.html" title="Declarations related to type declarations; the parser basically creates instances of these classes..." alt="" coords="1056,161,1117,189"/></map>
<!-- endSectionContent --></div>

<p><a href="opt_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrinsicsOpt.html">IntrinsicsOpt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIntrinsicsOpt_1_1MaskInstruction.html">IntrinsicsOpt::MaskInstruction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIntrinsicsOpt_1_1BlendInstruction.html">IntrinsicsOpt::BlendInstruction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGatherScatterFlattenOpt.html">GatherScatterFlattenOpt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGSInfo.html">GSInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaskedStoreOptPass.html">MaskedStoreOptPass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMSInfo.html">MSInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLowerMaskedStorePass.html">LowerMaskedStorePass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLMSInfo.html">LMSInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGSImprovementsPass.html">GSImprovementsPass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGatherImpInfo.html">GatherImpInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structScatterImpInfo.html">ScatterImpInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLowerGSPass.html">LowerGSPass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLowerGSInfo.html">LowerGSInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIsCompileTimeConstantPass.html">IsCompileTimeConstantPass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMakeInternalFuncsStaticPass.html">MakeInternalFuncsStaticPass</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ae101f1887eb612fd966ca6af38124b06">CreateIntrinsicsOptPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#aece10011609f0c71a4bc04c139812fb2">CreateGatherScatterFlattenPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ab6bcfa0afc8080f49ab690f866a05b86">CreateGatherScatterImprovementsPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a912a37fa639a1831d43bdb4814f13295">CreateLowerGatherScatterPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a026bed1bd856cd9bb2e37e50ba28f1b4">CreateLowerMaskedStorePass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a21a44464af393724a959f9c9c9ebe695">CreateMaskedStoreOptPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a9748d87e99ad21e87701c8de501b9231">CreateIsCompileTimeConstantPass</a> (bool isLastTry)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ac2100b660388956a7963ac9fe6839cb5">CreateMakeInternalFuncsStaticPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ae626137870c4cecf7e885cc2e5a5d433">lCopyMetadata</a> (llvm::Value *vto, const llvm::Instruction *from)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a9ce816b84cb0c2ca769c486be11dde5f">lGetSourcePosFromMetadata</a> (const llvm::Instruction *inst, <a class="el" href="structSourcePos.html">SourcePos</a> *pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a2aebb9b3b0bbf3a66d6539c772ea2361">lPrintModuleCode</a> (llvm::Module *module)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a2a7faa9c8af29d05713e5d15fdff1810">Optimize</a> (llvm::Module *module, int optLevel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::RegisterPass&lt; <a class="el" href="classIntrinsicsOpt.html">IntrinsicsOpt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a2084fcd069065ef366a212a84d8e498d">sse</a> (&quot;sse-constants&quot;,&quot;Intrinsics Cleanup Pass&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#aabbac44ab116503416aede9a33f1dd03">lGetMask</a> (llvm::Value *factor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a22173061ee4fe22a8ed7f20e32b40ad8">lIsUndef</a> (llvm::Value *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::RegisterPass<br class="typebreak"/>
&lt; <a class="el" href="classGatherScatterFlattenOpt.html">GatherScatterFlattenOpt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a001b3297f347351539d3a8c78ec9d38c">gsf</a> (&quot;gs-flatten&quot;,&quot;Gather/Scatter Flatten Pass&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a49699873443cd5f20f2c29a48c8316f0">lGetIntValue</a> (llvm::Value *offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a31ac0a279f49934da3a4ebd59422202a">lSizeOfIfKnown</a> (const llvm::Type *type, uint64_t *size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a64c41dd54a87b2cec2a3f75379064107">lSizeOf</a> (LLVM_TYPE_CONST llvm::Type *type, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ae27df9a92af0f1eee86f14212b826cbc">lStructOffset</a> (LLVM_TYPE_CONST llvm::Type *type, uint64_t member, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#aa1e5603a53b07ff593b980c254cf88f1">lGetTypeSize</a> (LLVM_TYPE_CONST llvm::Type *type, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a8e14de547aad10c2e127978d5ff3c209">lGetOffsetForLane</a> (int lane, llvm::Value *value, llvm::Value **offset, LLVM_TYPE_CONST llvm::Type **scaleType, bool *leafIsVarying, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a474ce319a134350cae719d1917e4b7c5">lTraverseInsertChain</a> (llvm::Value *ptrs, llvm::Value *offsets[ISPC_MAX_NVEC], LLVM_TYPE_CONST llvm::Type **scaleType, bool *leafIsVarying, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a54409d017cb8bc7cf557285a738ce945">lSmearScalar</a> (llvm::Value *scalar, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a237a81a47f939a5e0e33ba34d64ba821">lGetPtrAndOffsets</a> (llvm::Value *ptrs, llvm::Value **basePtr, llvm::Instruction *insertBefore, int eltSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::RegisterPass<br class="typebreak"/>
&lt; <a class="el" href="classMaskedStoreOptPass.html">MaskedStoreOptPass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#aaf6e6e910e5e1c83714d964ac57d6850">mss</a> (&quot;masked-store-scalarize&quot;,&quot;Masked Store Scalarize Pass&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::RegisterPass<br class="typebreak"/>
&lt; <a class="el" href="classLowerMaskedStorePass.html">LowerMaskedStorePass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ac392f0dde7e43724338de2129f1d356e">lms</a> (&quot;masked-store-lower&quot;,&quot;Lower Masked Store Pass&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a746512a4ba6a422dafde34b32c566c6f">lIsStackVariablePointer</a> (llvm::Value *lvalue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::RegisterPass<br class="typebreak"/>
&lt; <a class="el" href="classGSImprovementsPass.html">GSImprovementsPass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a780b279ceeca9e894b2c73e9bb89276d">gsi</a> (&quot;gs-improvements&quot;,&quot;Gather/Scatter Improvements Pass&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a30216faadac0120780a0bc0de5891607">lScalarizeVector</a> (llvm::Value *vec, llvm::Value **scalarizedVector, int vectorLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a19e6f673f336636576e69d485421223f">lValuesAreEqual</a> (llvm::Value *v0, llvm::Value *v1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a51f6dff642c298a32304aa504dec3630">lVectorValuesAllEqual</a> (llvm::Value *v[ISPC_MAX_NVEC])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a42d99a5caaa2957ff36e2e6a9fc29922">lVectorIsLinearConstantInts</a> (llvm::Value *v[ISPC_MAX_NVEC], int stride)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ab5c3f5c7547383dd696c693a667baaf8">lVectorIsLinear</a> (llvm::Value *v[ISPC_MAX_NVEC], int stride)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::RegisterPass&lt; <a class="el" href="classLowerGSPass.html">LowerGSPass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#adbddcd0f8f40d0deb4ef3638446a498d">lgs</a> (&quot;lower-gs&quot;,&quot;Lower Gather/Scatter Pass&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::RegisterPass<br class="typebreak"/>
&lt; <a class="el" href="classIsCompileTimeConstantPass.html">IsCompileTimeConstantPass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a07153b4dddd6b7c3c422aad50e4ccea0">ctcrp</a> (&quot;compile-time-constant&quot;,&quot;Compile-Time Constant Resolve Pass&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::RegisterPass<br class="typebreak"/>
&lt; <a class="el" href="classMakeInternalFuncsStaticPass.html">MakeInternalFuncsStaticPass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#aa1e449e76a3f6aafe94ffc939e9a500e">mifsp</a> (&quot;make-internal-funcs-static&quot;,&quot;Make Internal Funcs Static Pass&quot;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Implementations of various ispc optimization passes that operate on the LLVM IR. </p>

<p>Definition in file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aece10011609f0c71a4bc04c139812fb2"></a><!-- doxytag: member="opt.cpp::CreateGatherScatterFlattenPass" ref="aece10011609f0c71a4bc04c139812fb2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateGatherScatterFlattenPass </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01225">1225</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00176">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="ab6bcfa0afc8080f49ab690f866a05b86"></a><!-- doxytag: member="opt.cpp::CreateGatherScatterImprovementsPass" ref="ab6bcfa0afc8080f49ab690f866a05b86" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateGatherScatterImprovementsPass </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02348">2348</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00176">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="ae101f1887eb612fd966ca6af38124b06"></a><!-- doxytag: member="opt.cpp::CreateIntrinsicsOptPass" ref="ae101f1887eb612fd966ca6af38124b06" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateIntrinsicsOptPass </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00700">700</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00176">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a9748d87e99ad21e87701c8de501b9231"></a><!-- doxytag: member="opt.cpp::CreateIsCompileTimeConstantPass" ref="a9748d87e99ad21e87701c8de501b9231" args="(bool isLastTry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateIsCompileTimeConstantPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>isLastTry</em>&#160;)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02541">2541</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00176">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a912a37fa639a1831d43bdb4814f13295"></a><!-- doxytag: member="opt.cpp::CreateLowerGatherScatterPass" ref="a912a37fa639a1831d43bdb4814f13295" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateLowerGatherScatterPass </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02440">2440</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00176">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a026bed1bd856cd9bb2e37e50ba28f1b4"></a><!-- doxytag: member="opt.cpp::CreateLowerMaskedStorePass" ref="a026bed1bd856cd9bb2e37e50ba28f1b4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateLowerMaskedStorePass </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01478">1478</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00176">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="ac2100b660388956a7963ac9fe6839cb5"></a><!-- doxytag: member="opt.cpp::CreateMakeInternalFuncsStaticPass" ref="ac2100b660388956a7963ac9fe6839cb5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateMakeInternalFuncsStaticPass </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02614">2614</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00176">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a21a44464af393724a959f9c9c9ebe695"></a><!-- doxytag: member="opt.cpp::CreateMaskedStoreOptPass" ref="a21a44464af393724a959f9c9c9ebe695" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateMaskedStoreOptPass </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01342">1342</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00176">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a07153b4dddd6b7c3c422aad50e4ccea0"></a><!-- doxytag: member="opt.cpp::ctcrp" ref="a07153b4dddd6b7c3c422aad50e4ccea0" args="(&quot;compile&#45;time&#45;constant&quot;,&quot;Compile&#45;Time Constant Resolve Pass&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::RegisterPass&lt;<a class="el" href="classIsCompileTimeConstantPass.html">IsCompileTimeConstantPass</a>&gt; ctcrp </td>
          <td>(</td>
          <td class="paramtype">&quot;compile-time-constant&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Compile-Time Constant Resolve Pass&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a001b3297f347351539d3a8c78ec9d38c"></a><!-- doxytag: member="opt.cpp::gsf" ref="a001b3297f347351539d3a8c78ec9d38c" args="(&quot;gs&#45;flatten&quot;,&quot;Gather/Scatter Flatten Pass&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::RegisterPass&lt;<a class="el" href="classGatherScatterFlattenOpt.html">GatherScatterFlattenOpt</a>&gt; gsf </td>
          <td>(</td>
          <td class="paramtype">&quot;gs-flatten&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Gather/Scatter Flatten Pass&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a780b279ceeca9e894b2c73e9bb89276d"></a><!-- doxytag: member="opt.cpp::gsi" ref="a780b279ceeca9e894b2c73e9bb89276d" args="(&quot;gs&#45;improvements&quot;,&quot;Gather/Scatter Improvements Pass&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::RegisterPass&lt;<a class="el" href="classGSImprovementsPass.html">GSImprovementsPass</a>&gt; gsi </td>
          <td>(</td>
          <td class="paramtype">&quot;gs-improvements&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Gather/Scatter Improvements Pass&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae626137870c4cecf7e885cc2e5a5d433"></a><!-- doxytag: member="opt.cpp::lCopyMetadata" ref="ae626137870c4cecf7e885cc2e5a5d433" args="(llvm::Value *vto, const llvm::Instruction *from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void lCopyMetadata </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"> <em>vto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::Instruction *&#160;</td>
          <td class="paramname"> <em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This utility routine copies the metadata (if any) attached to the 'from' instruction in the IR to the 'to' instruction.</p>
<p>For flexibility, this function takes an llvm::Value rather than an llvm::Instruction for the 'to' parameter; at some places in the code below, we sometimes use a llvm::Value to start out storing a value and then later store instructions. If a llvm::Value is passed to this, the routine just returns without doing anything; if it is in fact an LLVM::Instruction, then the metadata can be copied to it. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00107">107</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00890">lGetOffsetForLane()</a>, <a class="el" href="opt_8cpp_source.html#l01046">lGetPtrAndOffsets()</a>, <a class="el" href="opt_8cpp_source.html#l00875">lGetTypeSize()</a>, <a class="el" href="opt_8cpp_source.html#l01560">lScalarizeVector()</a>, <a class="el" href="opt_8cpp_source.html#l00814">lSizeOf()</a>, <a class="el" href="opt_8cpp_source.html#l01032">lSmearScalar()</a>, <a class="el" href="opt_8cpp_source.html#l00849">lStructOffset()</a>, <a class="el" href="opt_8cpp_source.html#l02124">GSImprovementsPass::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l01413">LowerMaskedStorePass::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l01266">MaskedStoreOptPass::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l01126">GatherScatterFlattenOpt::runOnBasicBlock()</a>, and <a class="el" href="opt_8cpp_source.html#l00522">IntrinsicsOpt::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a49699873443cd5f20f2c29a48c8316f0"></a><!-- doxytag: member="opt.cpp::lGetIntValue" ref="a49699873443cd5f20f2c29a48c8316f0" args="(llvm::Value *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t lGetIntValue </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"> <em>offset</em>&#160;)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given an llvm::Value known to be an unsigned integer, return its value as an int64_t. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00748">748</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">assert</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00890">lGetOffsetForLane()</a>, and <a class="el" href="opt_8cpp_source.html#l01560">lScalarizeVector()</a>.</p>

</div>
</div>
<a class="anchor" id="aabbac44ab116503416aede9a33f1dd03"></a><!-- doxytag: member="opt.cpp::lGetMask" ref="aabbac44ab116503416aede9a33f1dd03" args="(llvm::Value *factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int lGetMask </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"> <em>factor</em>&#160;)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given an llvm::Value represinting a vector mask, see if the value is a constant. If so, return the integer mask found by taking the high bits of the mask values in turn and concatenating them into a single integer. In other words, given the 4-wide mask: &lt; 0xffffffff, 0, 0, 0xffffffff &gt;, we have 0b1001 = 9.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>This will break if we ever do 32-wide compilation, in which case it don't be possible to distinguish between -1 for "don't know" and "known and all bits on". </dd></dl>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00450">450</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">assert</a>, <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="ispc_8cpp_source.html#l00228">Target::GetTargetMachine()</a>, <a class="el" href="parse_8yy.html">NULL</a>, and <a class="el" href="ispc_8h_source.html#l00298">Globals::target</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01266">MaskedStoreOptPass::runOnBasicBlock()</a>, and <a class="el" href="opt_8cpp_source.html#l00522">IntrinsicsOpt::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e14de547aad10c2e127978d5ff3c209"></a><!-- doxytag: member="opt.cpp::lGetOffsetForLane" ref="a8e14de547aad10c2e127978d5ff3c209" args="(int lane, llvm::Value *value, llvm::Value **offset, LLVM_TYPE_CONST llvm::Type **scaleType, bool *leafIsVarying, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lGetOffsetForLane </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>lane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value **&#160;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LLVM_TYPE_CONST llvm::Type **&#160;</td>
          <td class="paramname"> <em>scaleType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"> <em>leafIsVarying</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"> <em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00890">890</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">assert</a>, <a class="el" href="llvmutil_8h_source.html#l00059">LLVMTypes::Int32Type</a>, <a class="el" href="llvmutil_8h_source.html#l00057">LLVMTypes::Int8Type</a>, <a class="el" href="opt_8cpp_source.html#l00107">lCopyMetadata()</a>, <a class="el" href="opt_8cpp_source.html#l00748">lGetIntValue()</a>, <a class="el" href="ispc_8h_source.html#l00082">LLVM_TYPE_CONST</a>, <a class="el" href="opt_8cpp_source.html#l00849">lStructOffset()</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00976">lTraverseInsertChain()</a>.</p>

</div>
</div>
<a class="anchor" id="a237a81a47f939a5e0e33ba34d64ba821"></a><!-- doxytag: member="opt.cpp::lGetPtrAndOffsets" ref="a237a81a47f939a5e0e33ba34d64ba821" args="(llvm::Value *ptrs, llvm::Value **basePtr, llvm::Instruction *insertBefore, int eltSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lGetPtrAndOffsets </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"> <em>ptrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value **&#160;</td>
          <td class="paramname"> <em>basePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"> <em>insertBefore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>eltSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01046">1046</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">assert</a>, <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="llvmutil_8h_source.html#l00077">LLVMTypes::Int32VectorType</a>, <a class="el" href="ispc_8h_source.html#l00057">ISPC_MAX_NVEC</a>, <a class="el" href="opt_8cpp_source.html#l00107">lCopyMetadata()</a>, <a class="el" href="opt_8cpp_source.html#l00875">lGetTypeSize()</a>, <a class="el" href="ispc_8h_source.html#l00082">LLVM_TYPE_CONST</a>, <a class="el" href="llvmutil_8cpp_source.html#l00188">LLVMInt32()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00304">LLVMInt32Vector()</a>, <a class="el" href="opt_8cpp_source.html#l01032">lSmearScalar()</a>, <a class="el" href="opt_8cpp_source.html#l00976">lTraverseInsertChain()</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="ispc_8h_source.html#l00298">Globals::target</a>, and <a class="el" href="ispc_8h_source.html#l00195">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01126">GatherScatterFlattenOpt::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ce816b84cb0c2ca769c486be11dde5f"></a><!-- doxytag: member="opt.cpp::lGetSourcePosFromMetadata" ref="a9ce816b84cb0c2ca769c486be11dde5f" args="(const llvm::Instruction *inst, SourcePos *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lGetSourcePosFromMetadata </td>
          <td>(</td>
          <td class="paramtype">const llvm::Instruction *&#160;</td>
          <td class="paramname"> <em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSourcePos.html">SourcePos</a> *&#160;</td>
          <td class="paramname"> <em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>We have a protocol with the front-end LLVM IR code generation process that allows us to encode the source file position that corresponds with instructions. (For example, this allows us to issue performance warnings related to things like scatter and gather after optimization has been performed, so that we aren't warning about scatters and gathers that have been improved to stores and loads by optimization passes.) Note that this is slightly redundant with the source file position encoding generated for debugging symbols, though we don't always generate debugging information but we do always generate this position data.</p>
<p>This function finds the <a class="el" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> that the metadata in the instruction (if present) corresponds to. See the implementation of <a class="el" href="classFunctionEmitContext.html#ac734fd6600297126709e557d58ea993b">FunctionEmitContext::addGSMetadata()</a>, which encodes the source position during code generation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>Instruction to try to find the source position of </td></tr>
    <tr><td class="paramname">pos</td><td>Output variable in which to store the position </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if source file position metadata was present and *pos has been set. False otherwise. </dd></dl>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00141">141</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">assert</a>, and <a class="el" href="lex_8ll_source.html#l30783">filename</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02389">LowerGSPass::runOnBasicBlock()</a>, and <a class="el" href="opt_8cpp_source.html#l02124">GSImprovementsPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="aa1e5603a53b07ff593b980c254cf88f1"></a><!-- doxytag: member="opt.cpp::lGetTypeSize" ref="aa1e5603a53b07ff593b980c254cf88f1" args="(LLVM_TYPE_CONST llvm::Type *type, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lGetTypeSize </td>
          <td>(</td>
          <td class="paramtype">LLVM_TYPE_CONST llvm::Type *&#160;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"> <em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00875">875</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="llvmutil_8h_source.html#l00059">LLVMTypes::Int32Type</a>, <a class="el" href="opt_8cpp_source.html#l00107">lCopyMetadata()</a>, <a class="el" href="ispc_8h_source.html#l00082">LLVM_TYPE_CONST</a>, <a class="el" href="opt_8cpp_source.html#l00814">lSizeOf()</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01046">lGetPtrAndOffsets()</a>.</p>

</div>
</div>
<a class="anchor" id="adbddcd0f8f40d0deb4ef3638446a498d"></a><!-- doxytag: member="opt.cpp::lgs" ref="adbddcd0f8f40d0deb4ef3638446a498d" args="(&quot;lower&#45;gs&quot;,&quot;Lower Gather/Scatter Pass&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::RegisterPass&lt;<a class="el" href="classLowerGSPass.html">LowerGSPass</a>&gt; lgs </td>
          <td>(</td>
          <td class="paramtype">&quot;lower-gs&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Lower Gather/Scatter Pass&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a746512a4ba6a422dafde34b32c566c6f"></a><!-- doxytag: member="opt.cpp::lIsStackVariablePointer" ref="a746512a4ba6a422dafde34b32c566c6f" args="(llvm::Value *lvalue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lIsStackVariablePointer </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"> <em>lvalue</em>&#160;)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine attempts to determine if the given pointer in lvalue is pointing to stack-allocated memory. It's conservative in that it should never return true for non-stack allocated memory, but may return false for memory that actually is stack allocated. The basic strategy is to traverse through the operands and see if the pointer originally comes from an AllocaInst. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01379">1379</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01413">LowerMaskedStorePass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a22173061ee4fe22a8ed7f20e32b40ad8"></a><!-- doxytag: member="opt.cpp::lIsUndef" ref="a22173061ee4fe22a8ed7f20e32b40ad8" args="(llvm::Value *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lIsUndef </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given an llvm::Value, return true if we can determine that it's an undefined value. This only makes a weak attempt at chasing this down, only detecting flat-out undef values, and bitcasts of undef values.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Is it worth working harder to find more of these? It starts to get tricky, since having an undef operand doesn't necessarily mean that the result will be undefined. (And for that matter, is there an LLVM call that will do this for us?) </dd></dl>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00509">509</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00522">IntrinsicsOpt::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ac392f0dde7e43724338de2129f1d356e"></a><!-- doxytag: member="opt.cpp::lms" ref="ac392f0dde7e43724338de2129f1d356e" args="(&quot;masked&#45;store&#45;lower&quot;,&quot;Lower Masked Store Pass&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::RegisterPass&lt;<a class="el" href="classLowerMaskedStorePass.html">LowerMaskedStorePass</a>&gt; lms </td>
          <td>(</td>
          <td class="paramtype">&quot;masked-store-lower&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Lower Masked Store Pass&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2aebb9b3b0bbf3a66d6539c772ea2361"></a><!-- doxytag: member="opt.cpp::lPrintModuleCode" ref="a2aebb9b3b0bbf3a66d6539c772ea2361" args="(llvm::Module *module)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void lPrintModuleCode </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"> <em>module</em>&#160;)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Utility routine that prints out the LLVM IR for everything in the module. (Used for debugging). </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00168">168</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00176">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a30216faadac0120780a0bc0de5891607"></a><!-- doxytag: member="opt.cpp::lScalarizeVector" ref="a30216faadac0120780a0bc0de5891607" args="(llvm::Value *vec, llvm::Value **scalarizedVector, int vectorLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lScalarizeVector </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value **&#160;</td>
          <td class="paramname"> <em>scalarizedVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>vectorLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given an LLVM vector in vec, return a 'scalarized' version of the vector in the provided scalarizedVector[] array. For example, if the vector value passed in is:</p>
<p>add &lt;4 x i32&gt; a_smear, &lt;4 x i32&gt; &lt;4, 8, 12, 16&gt;,</p>
<p>and if a_smear was computed by replicating a scalar value i32 a across all of the elements of a_smear, then the values returned will be:</p>
<p>offsets[0] = add i32 a, i32 4 offsets[1] = add i32 a, i32 8 offsets[2] = add i32 a, i32 12 offsets[3] = add i32 a, i32 16</p>
<p>This function isn't fully general, but it seems to be able to handle all of the patterns that currently arise in practice. If it can't scalarize a vector value, then it just returns false and the calling code proceeds as best it can without this information.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Vector to be scalarized </td></tr>
    <tr><td class="paramname">scalarizedVector</td><td>Array in which to store the individual vector elements </td></tr>
    <tr><td class="paramname">vectorLength</td><td>Number of elements in the given vector. (The passed scalarizedVector array must also be at least this length as well.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the vector was successfully scalarized and the values in offsets[] are valid; false otherwise </dd></dl>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01560">1560</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">assert</a>, <a class="el" href="llvmutil_8h_source.html#l00060">LLVMTypes::Int64Type</a>, <a class="el" href="opt_8cpp_source.html#l00107">lCopyMetadata()</a>, <a class="el" href="opt_8cpp_source.html#l00748">lGetIntValue()</a>, <a class="el" href="ispc_8h_source.html#l00082">LLVM_TYPE_CONST</a>, <a class="el" href="llvmutil_8cpp_source.html#l00188">LLVMInt32()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00202">LLVMInt64()</a>, <a class="el" href="opt_8cpp_source.html#l00762">lSizeOfIfKnown()</a>, <a class="el" href="parse_8yy.html">NULL</a>, and <a class="el" href="parse_8yy.html">stderr</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02124">GSImprovementsPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a64c41dd54a87b2cec2a3f75379064107"></a><!-- doxytag: member="opt.cpp::lSizeOf" ref="a64c41dd54a87b2cec2a3f75379064107" args="(LLVM_TYPE_CONST llvm::Type *type, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lSizeOf </td>
          <td>(</td>
          <td class="paramtype">LLVM_TYPE_CONST llvm::Type *&#160;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"> <em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns an llvm::Value giving the size of the given type. If any instructions need to be generated to compute the size, they are inserted before insertBefore. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00814">814</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="llvmutil_8h_source.html#l00060">LLVMTypes::Int64Type</a>, <a class="el" href="opt_8cpp_source.html#l00107">lCopyMetadata()</a>, <a class="el" href="ispc_8h_source.html#l00082">LLVM_TYPE_CONST</a>, <a class="el" href="llvmutil_8cpp_source.html#l00188">LLVMInt32()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00202">LLVMInt64()</a>, and <a class="el" href="opt_8cpp_source.html#l00762">lSizeOfIfKnown()</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00875">lGetTypeSize()</a>.</p>

</div>
</div>
<a class="anchor" id="a31ac0a279f49934da3a4ebd59422202a"></a><!-- doxytag: member="opt.cpp::lSizeOfIfKnown" ref="a31ac0a279f49934da3a4ebd59422202a" args="(const llvm::Type *type, uint64_t *size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lSizeOfIfKnown </td>
          <td>(</td>
          <td class="paramtype">const llvm::Type *&#160;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"> <em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the size of the given llvm::Type as an llvm::Value, if the size can be easily determined at compile type. If it's not easy to figure out the size, this just returns NULL and we handle finding its size differently. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00762">762</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="llvmutil_8h_source.html#l00062">LLVMTypes::DoubleType</a>, <a class="el" href="llvmutil_8h_source.html#l00080">LLVMTypes::DoubleVectorType</a>, <a class="el" href="llvmutil_8h_source.html#l00061">LLVMTypes::FloatType</a>, <a class="el" href="llvmutil_8h_source.html#l00079">LLVMTypes::FloatVectorType</a>, <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="llvmutil_8h_source.html#l00058">LLVMTypes::Int16Type</a>, <a class="el" href="llvmutil_8h_source.html#l00076">LLVMTypes::Int16VectorType</a>, <a class="el" href="llvmutil_8h_source.html#l00059">LLVMTypes::Int32Type</a>, <a class="el" href="llvmutil_8h_source.html#l00077">LLVMTypes::Int32VectorType</a>, <a class="el" href="llvmutil_8h_source.html#l00060">LLVMTypes::Int64Type</a>, <a class="el" href="llvmutil_8h_source.html#l00078">LLVMTypes::Int64VectorType</a>, <a class="el" href="llvmutil_8h_source.html#l00057">LLVMTypes::Int8Type</a>, <a class="el" href="llvmutil_8h_source.html#l00075">LLVMTypes::Int8VectorType</a>, <a class="el" href="ispc_8h_source.html#l00298">Globals::target</a>, and <a class="el" href="ispc_8h_source.html#l00195">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01560">lScalarizeVector()</a>, and <a class="el" href="opt_8cpp_source.html#l00814">lSizeOf()</a>.</p>

</div>
</div>
<a class="anchor" id="a54409d017cb8bc7cf557285a738ce945"></a><!-- doxytag: member="opt.cpp::lSmearScalar" ref="a54409d017cb8bc7cf557285a738ce945" args="(llvm::Value *scalar, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lSmearScalar </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"> <em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"> <em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a scalar value, return a vector of width g-&gt;target.vectorWidth that has the scalar replicated across each of its elements.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>Using shufflevector to do this seems more idiomatic (and would be just a single instruction). Switch to that? </dd></dl>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01032">1032</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="opt_8cpp_source.html#l00107">lCopyMetadata()</a>, <a class="el" href="ispc_8h_source.html#l00082">LLVM_TYPE_CONST</a>, <a class="el" href="llvmutil_8cpp_source.html#l00188">LLVMInt32()</a>, <a class="el" href="ispc_8h_source.html#l00298">Globals::target</a>, and <a class="el" href="ispc_8h_source.html#l00195">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01046">lGetPtrAndOffsets()</a>.</p>

</div>
</div>
<a class="anchor" id="ae27df9a92af0f1eee86f14212b826cbc"></a><!-- doxytag: member="opt.cpp::lStructOffset" ref="ae27df9a92af0f1eee86f14212b826cbc" args="(LLVM_TYPE_CONST llvm::Type *type, uint64_t member, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lStructOffset </td>
          <td>(</td>
          <td class="paramtype">LLVM_TYPE_CONST llvm::Type *&#160;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"> <em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"> <em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns a value that gives the offset in bytes from the start of the given structure type to the given struct member. The instructions that compute this value are inserted before insertBefore. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00849">849</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">assert</a>, <a class="el" href="parse_8yy_source.html#l27510">int32_t</a>, <a class="el" href="llvmutil_8h_source.html#l00060">LLVMTypes::Int64Type</a>, <a class="el" href="opt_8cpp_source.html#l00107">lCopyMetadata()</a>, <a class="el" href="ispc_8h_source.html#l00082">LLVM_TYPE_CONST</a>, and <a class="el" href="llvmutil_8cpp_source.html#l00188">LLVMInt32()</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00890">lGetOffsetForLane()</a>.</p>

</div>
</div>
<a class="anchor" id="a474ce319a134350cae719d1917e4b7c5"></a><!-- doxytag: member="opt.cpp::lTraverseInsertChain" ref="a474ce319a134350cae719d1917e4b7c5" args="(llvm::Value *ptrs, llvm::Value *offsets[ISPC_MAX_NVEC], LLVM_TYPE_CONST llvm::Type **scaleType, bool *leafIsVarying, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lTraverseInsertChain </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"> <em>ptrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"> <em>offsets</em>[ISPC_MAX_NVEC], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LLVM_TYPE_CONST llvm::Type **&#160;</td>
          <td class="paramname"> <em>scaleType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"> <em>leafIsVarying</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"> <em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>We have an LLVM array of pointer values, where each pointer has been computed with a GEP from some common base pointer value. This function deconstructs the LLVM array, storing the offset from the base pointer as an llvm::Value for the i'th element into the i'th element of the offsets[] array passed in to the function. It returns a scale factor for the offsets via *scaleType, and sets *leafIsVarying to true if the leaf data type being indexed into is a 'varying' ispc type. The return value is either the base pointer or the an array of pointers for the next dimension of indexing (that we'll in turn deconstruct with this function).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>All of the additional indexing magic for varying stuff should happen in the front end. </dd></dl>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00976">976</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">assert</a>, <a class="el" href="opt_8cpp_source.html#l00890">lGetOffsetForLane()</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01046">lGetPtrAndOffsets()</a>.</p>

</div>
</div>
<a class="anchor" id="a19e6f673f336636576e69d485421223f"></a><!-- doxytag: member="opt.cpp::lValuesAreEqual" ref="a19e6f673f336636576e69d485421223f" args="(llvm::Value *v0, llvm::Value *v1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lValuesAreEqual </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"> <em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"> <em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Conservative test to see if two values are equal. There are (potentially many) cases where the two values actually are equal but this will return false. However, if it does return true, the two vectors definitely are equal.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>This seems to catch all of the cases we currently need it for in practice, but it's be nice to make it a little more robust/general. In general, though, a little something called the halting problem means we won't get all of them. </dd></dl>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01801">1801</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01827">lVectorValuesAllEqual()</a>.</p>

</div>
</div>
<a class="anchor" id="ab5c3f5c7547383dd696c693a667baaf8"></a><!-- doxytag: member="opt.cpp::lVectorIsLinear" ref="ab5c3f5c7547383dd696c693a667baaf8" args="(llvm::Value *v[ISPC_MAX_NVEC], int stride)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lVectorIsLinear </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"> <em>v</em>[ISPC_MAX_NVEC], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given an array of integer-typed values, see if the elements of the array have a step of 'stride' between their values. This function tries to handle as many possibilities as possible, including things like all elements equal to some non-constant value plus an integer offset, etc.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>FIXME Crazy thought: can we just build up expressions that subtract the constants [v[0], v[0]+stride, v[0]+2*stride, ...] from the given values, throw the LLVM optimizer at those, and then see if we get back an array of all zeros? </dd></dl>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01877">1877</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">assert</a>, <a class="el" href="util_8h_source.html#l00104">FATAL</a>, <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="ispc_8h_source.html#l00057">ISPC_MAX_NVEC</a>, <a class="el" href="llvmutil_8cpp_source.html#l00188">LLVMInt32()</a>, <a class="el" href="opt_8cpp_source.html#l01841">lVectorIsLinearConstantInts()</a>, <a class="el" href="opt_8cpp_source.html#l01827">lVectorValuesAllEqual()</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="ispc_8h_source.html#l00298">Globals::target</a>, and <a class="el" href="ispc_8h_source.html#l00195">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02124">GSImprovementsPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a42d99a5caaa2957ff36e2e6a9fc29922"></a><!-- doxytag: member="opt.cpp::lVectorIsLinearConstantInts" ref="a42d99a5caaa2957ff36e2e6a9fc29922" args="(llvm::Value *v[ISPC_MAX_NVEC], int stride)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lVectorIsLinearConstantInts </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"> <em>v</em>[ISPC_MAX_NVEC], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given an array of scalar integer values, test to see if they are a linear sequence of compile-time constant integers starting from an arbirary value but then having a step of value "stride" between elements. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01841">1841</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="ispc_8h_source.html#l00298">Globals::target</a>, and <a class="el" href="ispc_8h_source.html#l00195">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01877">lVectorIsLinear()</a>.</p>

</div>
</div>
<a class="anchor" id="a51f6dff642c298a32304aa504dec3630"></a><!-- doxytag: member="opt.cpp::lVectorValuesAllEqual" ref="a51f6dff642c298a32304aa504dec3630" args="(llvm::Value *v[ISPC_MAX_NVEC])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lVectorValuesAllEqual </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"> <em>v</em>[ISPC_MAX_NVEC]&#160;)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tests to see if all of the llvm::Values in the array are equal. Like lValuesAreEqual, this is a conservative test and may return false for arrays where the values are actually all equal. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01827">1827</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="opt_8cpp_source.html#l01801">lValuesAreEqual()</a>, <a class="el" href="ispc_8h_source.html#l00298">Globals::target</a>, and <a class="el" href="ispc_8h_source.html#l00195">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01877">lVectorIsLinear()</a>, and <a class="el" href="opt_8cpp_source.html#l02124">GSImprovementsPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="aa1e449e76a3f6aafe94ffc939e9a500e"></a><!-- doxytag: member="opt.cpp::mifsp" ref="aa1e449e76a3f6aafe94ffc939e9a500e" args="(&quot;make&#45;internal&#45;funcs&#45;static&quot;,&quot;Make Internal Funcs Static Pass&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::RegisterPass&lt;<a class="el" href="classMakeInternalFuncsStaticPass.html">MakeInternalFuncsStaticPass</a>&gt; mifsp </td>
          <td>(</td>
          <td class="paramtype">&quot;make-internal-funcs-static&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Make Internal Funcs Static Pass&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaf6e6e910e5e1c83714d964ac57d6850"></a><!-- doxytag: member="opt.cpp::mss" ref="aaf6e6e910e5e1c83714d964ac57d6850" args="(&quot;masked&#45;store&#45;scalarize&quot;,&quot;Masked Store Scalarize Pass&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::RegisterPass&lt;<a class="el" href="classMaskedStoreOptPass.html">MaskedStoreOptPass</a>&gt; mss </td>
          <td>(</td>
          <td class="paramtype">&quot;masked-store-scalarize&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Masked Store Scalarize Pass&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2a7faa9c8af29d05713e5d15fdff1810"></a><!-- doxytag: member="opt.cpp::Optimize" ref="a2a7faa9c8af29d05713e5d15fdff1810" args="(llvm::Module *module, int optLevel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"> <em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>optLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Optimize the functions in the given module, applying the specified level of optimization. optLevel zero corresponds to essentially no optimization--just enough to generate correct code, while level one corresponds to full optimization. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00176">176</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="opt_8cpp_source.html#l01225">CreateGatherScatterFlattenPass()</a>, <a class="el" href="opt_8cpp_source.html#l02348">CreateGatherScatterImprovementsPass()</a>, <a class="el" href="opt_8cpp_source.html#l00700">CreateIntrinsicsOptPass()</a>, <a class="el" href="opt_8cpp_source.html#l02541">CreateIsCompileTimeConstantPass()</a>, <a class="el" href="opt_8cpp_source.html#l02440">CreateLowerGatherScatterPass()</a>, <a class="el" href="opt_8cpp_source.html#l01478">CreateLowerMaskedStorePass()</a>, <a class="el" href="opt_8cpp_source.html#l02614">CreateMakeInternalFuncsStaticPass()</a>, <a class="el" href="opt_8cpp_source.html#l01342">CreateMaskedStoreOptPass()</a>, <a class="el" href="ispc_8h_source.html#l00315">Globals::debugPrint</a>, <a class="el" href="ispc_8h_source.html#l00255">Opt::disableGatherScatterOptimizations</a>, <a class="el" href="ispc_8h_source.html#l00281">Opt::disableMaskedStoreOptimizations</a>, <a class="el" href="ispc_8cpp_source.html#l00065">g</a>, <a class="el" href="opt_8cpp_source.html#l00168">lPrintModuleCode()</a>, <a class="el" href="ispc_8h_source.html#l00296">Globals::opt</a>, and <a class="el" href="ispc_8h_source.html#l00227">Opt::unrollLoops</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00153">Module::CompileFile()</a>.</p>

</div>
</div>
<a class="anchor" id="a2084fcd069065ef366a212a84d8e498d"></a><!-- doxytag: member="opt.cpp::sse" ref="a2084fcd069065ef366a212a84d8e498d" args="(&quot;sse&#45;constants&quot;,&quot;Intrinsics Cleanup Pass&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::RegisterPass&lt;<a class="el" href="classIntrinsicsOpt.html">IntrinsicsOpt</a>&gt; sse </td>
          <td>(</td>
          <td class="paramtype">&quot;sse-constants&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Intrinsics Cleanup Pass&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 6 2011 19:44:52 for Intel SPMD Program Compiler by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
