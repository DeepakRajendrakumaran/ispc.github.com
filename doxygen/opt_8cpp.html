<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Intel SPMD Program Compiler: opt.cpp File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Intel SPMD Program Compiler
   &#160;<span id="projectnumber">1.1.4</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">opt.cpp File Reference</div>  </div>
</div>
<div class="contents">

<p>Implementations of various ispc optimization passes that operate on the LLVM IR.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="opt_8h_source.html">opt.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ctx_8h_source.html">ctx.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sym_8h_source.html">sym.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="module_8h_source.html">module.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="llvmutil_8h_source.html">llvmutil.h</a>&quot;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;map&gt;</code><br/>
<code>#include &lt;set&gt;</code><br/>
<code>#include &lt;llvm/Pass.h&gt;</code><br/>
<code>#include &lt;llvm/Module.h&gt;</code><br/>
<code>#include &lt;llvm/PassManager.h&gt;</code><br/>
<code>#include &lt;llvm/PassRegistry.h&gt;</code><br/>
<code>#include &lt;llvm/Assembly/PrintModulePass.h&gt;</code><br/>
<code>#include &lt;llvm/Function.h&gt;</code><br/>
<code>#include &lt;llvm/BasicBlock.h&gt;</code><br/>
<code>#include &lt;llvm/Instructions.h&gt;</code><br/>
<code>#include &lt;llvm/Intrinsics.h&gt;</code><br/>
<code>#include &lt;llvm/Constants.h&gt;</code><br/>
<code>#include &lt;llvm/Analysis/ConstantFolding.h&gt;</code><br/>
<code>#include &lt;llvm/Target/TargetLibraryInfo.h&gt;</code><br/>
<code>#include &lt;llvm/ADT/Triple.h&gt;</code><br/>
<code>#include &lt;llvm/Transforms/Scalar.h&gt;</code><br/>
<code>#include &lt;llvm/Transforms/IPO.h&gt;</code><br/>
<code>#include &lt;llvm/Transforms/Utils/BasicBlockUtils.h&gt;</code><br/>
<code>#include &lt;llvm/Target/TargetOptions.h&gt;</code><br/>
<code>#include &lt;llvm/Target/TargetData.h&gt;</code><br/>
<code>#include &lt;llvm/Target/TargetMachine.h&gt;</code><br/>
<code>#include &lt;llvm/Analysis/Verifier.h&gt;</code><br/>
<code>#include &lt;llvm/Analysis/Passes.h&gt;</code><br/>
<code>#include &lt;llvm/Support/raw_ostream.h&gt;</code><br/>
<code>#include &lt;llvm/Analysis/DIBuilder.h&gt;</code><br/>
<code>#include &lt;llvm/Analysis/DebugInfo.h&gt;</code><br/>
<code>#include &lt;llvm/Support/Dwarf.h&gt;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for opt.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="opt_8cpp__incl.png" border="0" usemap="#opt_8cpp" alt=""/></div>
<map name="opt_8cpp" id="opt_8cpp">
<area shape="rect" id="node3" href="opt_8h.html" title="Declarations related to optimization passes." alt="" coords="86,161,143,189"/><area shape="rect" id="node17" href="ctx_8h.html" title="Declaration of the FunctionEmitContext class." alt="" coords="772,83,828,111"/><area shape="rect" id="node30" href="sym_8h.html" title="header file with declarations for symbol and symbol table classes." alt="" coords="251,83,313,111"/><area shape="rect" id="node37" href="module_8h.html" title="Declaration of the Module class, which is the ispc&#45;side representation of the results of compiling a ..." alt="" coords="433,83,519,111"/><area shape="rect" id="node42" href="util_8h.html" title="util.h" alt="" coords="5,161,61,189"/><area shape="rect" id="node45" href="llvmutil_8h.html" title="Header file with declarations for various LLVM utility stuff." alt="" coords="1363,83,1448,111"/><area shape="rect" id="node5" href="ispc_8h.html" title="Main ispc.header file." alt="" coords="237,238,299,266"/><area shape="rect" id="node33" href="decl_8h.html" title="Declarations related to type declarations; the parser basically creates instances of these classes..." alt="" coords="167,161,229,189"/></map>
</div>
</div>
<p><a href="opt_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIntrinsicsOpt.html">IntrinsicsOpt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIntrinsicsOpt_1_1MaskInstruction.html">IntrinsicsOpt::MaskInstruction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIntrinsicsOpt_1_1BlendInstruction.html">IntrinsicsOpt::BlendInstruction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVSelMovmskOpt.html">VSelMovmskOpt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDetectGSBaseOffsetsPass.html">DetectGSBaseOffsetsPass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGSInfo.html">GSInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaskedStoreOptPass.html">MaskedStoreOptPass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMSInfo.html">MSInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaskedLoadOptPass.html">MaskedLoadOptPass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMLInfo.html">MLInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPseudoMaskedStorePass.html">PseudoMaskedStorePass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLMSInfo.html">LMSInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGSToLoadStorePass.html">GSToLoadStorePass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGatherImpInfo.html">GatherImpInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structScatterImpInfo.html">ScatterImpInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPseudoGSToGSPass.html">PseudoGSToGSPass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLowerGSInfo.html">LowerGSInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIsCompileTimeConstantPass.html">IsCompileTimeConstantPass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMakeInternalFuncsStaticPass.html">MakeInternalFuncsStaticPass</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ae101f1887eb612fd966ca6af38124b06">CreateIntrinsicsOptPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#aecd61ed536c82b2319f160531809b13e">CreateVSelMovmskOptPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a3a1d689d159603b30a0cb765e2829414">CreateDetectGSBaseOffsetsPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a5e3fca1f18b39a1872da149bb4b4a8e0">CreateGSToLoadStorePass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a469f236d229cc56c18cca19ba3898ecd">CreatePseudoGSToGSPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a63c6bcac157605f54d596c5897eb2a9d">CreatePseudoMaskedStorePass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a21a44464af393724a959f9c9c9ebe695">CreateMaskedStoreOptPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a2a2d594cb19236176bcde40f72c9681a">CreateMaskedLoadOptPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a9748d87e99ad21e87701c8de501b9231">CreateIsCompileTimeConstantPass</a> (bool isLastTry)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Pass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ac2100b660388956a7963ac9fe6839cb5">CreateMakeInternalFuncsStaticPass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ae626137870c4cecf7e885cc2e5a5d433">lCopyMetadata</a> (llvm::Value *vto, const llvm::Instruction *from)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a9ce816b84cb0c2ca769c486be11dde5f">lGetSourcePosFromMetadata</a> (const llvm::Instruction *inst, <a class="el" href="structSourcePos.html">SourcePos</a> *pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Instruction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a8c19662e48244e08880bd61669b26839">lCallInst</a> (llvm::Function *func, llvm::Value *arg0, llvm::Value *arg1, const char *name, llvm::Instruction *insertBefore=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Instruction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a6e4af755e19b1128d1b71e55688f249a">lCallInst</a> (llvm::Function *func, llvm::Value *arg0, llvm::Value *arg1, llvm::Value *arg2, const char *name, llvm::Instruction *insertBefore=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Instruction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a424642b393fa76f892d1a76e0192e349">lCallInst</a> (llvm::Function *func, llvm::Value *arg0, llvm::Value *arg1, llvm::Value *arg2, llvm::Value *arg3, llvm::Value *arg4, const char *name, llvm::Instruction *insertBefore=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Instruction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#af3b6debc19799c60ba11126bf7123a7e">lCallInst</a> (llvm::Function *func, llvm::Value *arg0, llvm::Value *arg1, llvm::Value *arg2, llvm::Value *arg3, llvm::Value *arg4, llvm::Value *arg5, const char *name, llvm::Instruction *insertBefore=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a2a7faa9c8af29d05713e5d15fdff1810">Optimize</a> (llvm::Module *module, int optLevel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#aabbac44ab116503416aede9a33f1dd03">lGetMask</a> (llvm::Value *factor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a22173061ee4fe22a8ed7f20e32b40ad8">lIsUndef</a> (llvm::Value *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a30ccca7ed1dca9f3ff30ebb445cfcaab">lCheckForActualPointer</a> (llvm::Value *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a568fd43a32e1a91745ca4cd1d8fc6a32">lGetBasePointer</a> (llvm::Value *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#af47f2481f316b98aa8a37354e1e1473c">lGetConstantAddExprBaseOffset</a> (llvm::Constant *op0, llvm::Constant *op1, llvm::Constant **delta)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ac6ced32908e9773085ec13530d64b96c">lGetBasePtrAndOffsets</a> (llvm::Value *ptrs, llvm::Value **offsets, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ac08b89d83dd0f7a10af30116e34fccf1">lGetZeroOffsetVector</a> (llvm::Value *origVec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#adce013e717663e5e455ad1d4b6ddb35a">lExtractConstantOffset</a> (llvm::Value *vec, llvm::Value **constOffset, llvm::Value **variableOffset, llvm::Instruction *insertBefore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a1e3b263d76c38acfd2555bc6dbb61ac9">lIs248Splat</a> (llvm::Value *v, int *splat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a8e57e1615411b94fc8171f6180b9d762">lExtractOffsetVector248Scale</a> (llvm::Value **vec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a432c7725f35dbabfc537a1f2b91b85ca">lIsSafeToBlend</a> (llvm::Value *lvalue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a4df2503b61941de507d4c287fc781829">lVectorIsLinearConstantInts</a> (llvm::ConstantVector *cv, int vectorLength, int stride)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#ae60d89f84e134a3f8151f2c75639c6bc">lVectorIsLinear</a> (llvm::Value *v, int vectorLength, int stride, std::vector&lt; llvm::PHINode * &gt; &amp;seenPhis)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#a1d74628e093fdaf434de36528eb47f2a">lCheckMulForLinear</a> (llvm::Value *op0, llvm::Value *op1, int vectorLength, int stride, std::vector&lt; llvm::PHINode * &gt; &amp;seenPhis)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt_8cpp.html#accadb004816ea7494e811c3a2d311641">lComputeCommonPointer</a> (llvm::Value *base, llvm::Value *offsets, llvm::Instruction *insertBefore)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Implementations of various ispc optimization passes that operate on the LLVM IR. </p>

<p>Definition in file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a3a1d689d159603b30a0cb765e2829414"></a><!-- doxytag: member="opt.cpp::CreateDetectGSBaseOffsetsPass" ref="a3a1d689d159603b30a0cb765e2829414" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateDetectGSBaseOffsetsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01778">1778</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00256">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e3fca1f18b39a1872da149bb4b4a8e0"></a><!-- doxytag: member="opt.cpp::CreateGSToLoadStorePass" ref="a5e3fca1f18b39a1872da149bb4b4a8e0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateGSToLoadStorePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02615">2615</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00256">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="ae101f1887eb612fd966ca6af38124b06"></a><!-- doxytag: member="opt.cpp::CreateIntrinsicsOptPass" ref="ae101f1887eb612fd966ca6af38124b06" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateIntrinsicsOptPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00891">891</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00256">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a9748d87e99ad21e87701c8de501b9231"></a><!-- doxytag: member="opt.cpp::CreateIsCompileTimeConstantPass" ref="a9748d87e99ad21e87701c8de501b9231" args="(bool isLastTry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateIsCompileTimeConstantPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLastTry</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02844">2844</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00256">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="ac2100b660388956a7963ac9fe6839cb5"></a><!-- doxytag: member="opt.cpp::CreateMakeInternalFuncsStaticPass" ref="ac2100b660388956a7963ac9fe6839cb5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateMakeInternalFuncsStaticPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02928">2928</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00256">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a2d594cb19236176bcde40f72c9681a"></a><!-- doxytag: member="opt.cpp::CreateMaskedLoadOptPass" ref="a2a2d594cb19236176bcde40f72c9681a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateMaskedLoadOptPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01995">1995</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00256">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a21a44464af393724a959f9c9c9ebe695"></a><!-- doxytag: member="opt.cpp::CreateMaskedStoreOptPass" ref="a21a44464af393724a959f9c9c9ebe695" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateMaskedStoreOptPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01896">1896</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00256">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a469f236d229cc56c18cca19ba3898ecd"></a><!-- doxytag: member="opt.cpp::CreatePseudoGSToGSPass" ref="a469f236d229cc56c18cca19ba3898ecd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreatePseudoGSToGSPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02744">2744</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00256">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a63c6bcac157605f54d596c5897eb2a9d"></a><!-- doxytag: member="opt.cpp::CreatePseudoMaskedStorePass" ref="a63c6bcac157605f54d596c5897eb2a9d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreatePseudoMaskedStorePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02134">2134</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00256">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="aecd61ed536c82b2319f160531809b13e"></a><!-- doxytag: member="opt.cpp::CreateVSelMovmskOptPass" ref="aecd61ed536c82b2319f160531809b13e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Pass * CreateVSelMovmskOptPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00976">976</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00256">Optimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c19662e48244e08880bd61669b26839"></a><!-- doxytag: member="opt.cpp::lCallInst" ref="a8c19662e48244e08880bd61669b26839" args="(llvm::Function *func, llvm::Value *arg0, llvm::Value *arg1, const char *name, llvm::Instruction *insertBefore=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Instruction* lCallInst </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00180">180</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01620">DetectGSBaseOffsetsPass::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l02076">PseudoMaskedStorePass::runOnBasicBlock()</a>, and <a class="el" href="opt_8cpp_source.html#l02426">GSToLoadStorePass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a6e4af755e19b1128d1b71e55688f249a"></a><!-- doxytag: member="opt.cpp::lCallInst" ref="a6e4af755e19b1128d1b71e55688f249a" args="(llvm::Function *func, llvm::Value *arg0, llvm::Value *arg1, llvm::Value *arg2, const char *name, llvm::Instruction *insertBefore=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Instruction* lCallInst </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00194">194</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a424642b393fa76f892d1a76e0192e349"></a><!-- doxytag: member="opt.cpp::lCallInst" ref="a424642b393fa76f892d1a76e0192e349" args="(llvm::Function *func, llvm::Value *arg0, llvm::Value *arg1, llvm::Value *arg2, llvm::Value *arg3, llvm::Value *arg4, const char *name, llvm::Instruction *insertBefore=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Instruction* lCallInst </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00225">225</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af3b6debc19799c60ba11126bf7123a7e"></a><!-- doxytag: member="opt.cpp::lCallInst" ref="af3b6debc19799c60ba11126bf7123a7e" args="(llvm::Function *func, llvm::Value *arg0, llvm::Value *arg1, llvm::Value *arg2, llvm::Value *arg3, llvm::Value *arg4, llvm::Value *arg5, const char *name, llvm::Instruction *insertBefore=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Instruction* lCallInst </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00239">239</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a30ccca7ed1dca9f3ff30ebb445cfcaab"></a><!-- doxytag: member="opt.cpp::lCheckForActualPointer" ref="a30ccca7ed1dca9f3ff30ebb445cfcaab" args="(llvm::Value *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lCheckForActualPointer </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check to make sure that this value is actually a pointer in the end. We need to make sure that given an expression like vec(offset) + ptr2int(ptr), <a class="el" href="opt_8cpp.html#a568fd43a32e1a91745ca4cd1d8fc6a32">lGetBasePointer()</a> doesn't return vec(offset) for the base pointer such that we then treat ptr2int(ptr) as an offset. This ends up being important so that we don't generate LLVM GEP instructions like "gep inttoptr 8, i64 %ptr", which in turn can lead to incorrect code since LLVM's pointer aliasing analysis assumes that operands after the first one to a GEP aren't pointers. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01017">1017</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01041">lGetBasePointer()</a>.</p>

</div>
</div>
<a class="anchor" id="a1d74628e093fdaf434de36528eb47f2a"></a><!-- doxytag: member="opt.cpp::lCheckMulForLinear" ref="a1d74628e093fdaf434de36528eb47f2a" args="(llvm::Value *op0, llvm::Value *op1, int vectorLength, int stride, std::vector&lt; llvm::PHINode * &gt; &amp;seenPhis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lCheckMulForLinear </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>op0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vectorLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; llvm::PHINode * &gt; &amp;&#160;</td>
          <td class="paramname"><em>seenPhis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks to see if (op0 * op1) is a linear vector where the result is a vector with values that increase by stride. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02226">2226</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="opt_8cpp_source.html#l02266">lVectorIsLinear()</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02266">lVectorIsLinear()</a>.</p>

</div>
</div>
<a class="anchor" id="accadb004816ea7494e811c3a2d311641"></a><!-- doxytag: member="opt.cpp::lComputeCommonPointer" ref="accadb004816ea7494e811c3a2d311641" args="(llvm::Value *base, llvm::Value *offsets, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lComputeCommonPointer </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02390">2390</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="llvmutil_8cpp_source.html#l00204">LLVMInt32()</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02426">GSToLoadStorePass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ae626137870c4cecf7e885cc2e5a5d433"></a><!-- doxytag: member="opt.cpp::lCopyMetadata" ref="ae626137870c4cecf7e885cc2e5a5d433" args="(llvm::Value *vto, const llvm::Instruction *from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void lCopyMetadata </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>vto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::Instruction *&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This utility routine copies the metadata (if any) attached to the 'from' instruction in the IR to the 'to' instruction.</p>
<p>For flexibility, this function takes an llvm::Value rather than an llvm::Instruction for the 'to' parameter; at some places in the code below, we sometimes use a llvm::Value to start out storing a value and then later store instructions. If a llvm::Value is passed to this, the routine just returns without doing anything; if it is in fact an LLVM::Instruction, then the metadata can be copied to it. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00112">112</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00713">IntrinsicsOpt::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l01620">DetectGSBaseOffsetsPass::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l01816">MaskedStoreOptPass::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l01930">MaskedLoadOptPass::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l02076">PseudoMaskedStorePass::runOnBasicBlock()</a>, and <a class="el" href="opt_8cpp_source.html#l02426">GSToLoadStorePass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="adce013e717663e5e455ad1d4b6ddb35a"></a><!-- doxytag: member="opt.cpp::lExtractConstantOffset" ref="adce013e717663e5e455ad1d4b6ddb35a" args="(llvm::Value *vec, llvm::Value **constOffset, llvm::Value **variableOffset, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void lExtractConstantOffset </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value **&#160;</td>
          <td class="paramname"><em>constOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value **&#160;</td>
          <td class="paramname"><em>variableOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a vector expression in vec, separate it into a compile-time constant component and a variable component, returning the two parts in constOffset and *variableOffset. (It should be the case that the sum of these two is exactly equal to the original vector.)</p>
<p>This routine only handles some (important) patterns; in some cases it will fail and return components that are actually compile-time constants in *variableOffset.</p>
<p>Finally, if there aren't any constant (or, respectivaly, variable) components, the corresponding return value may be set to NULL. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01255">1255</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01620">DetectGSBaseOffsetsPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e57e1615411b94fc8171f6180b9d762"></a><!-- doxytag: member="opt.cpp::lExtractOffsetVector248Scale" ref="a8e57e1615411b94fc8171f6180b9d762" args="(llvm::Value **vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lExtractOffsetVector248Scale </td>
          <td>(</td>
          <td class="paramtype">llvm::Value **&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a vector of integer offsets to a base pointer being used for a gather or a scatter, see if its root operation is a multiply by a vector of some value by all 2s/4s/8s. If not, return NULL.</p>
<p>If it is return an i32 value of 2, 4, 8 from the function and modify vec so that it points to the operand that is being multiplied by 2/4/8.</p>
<p>We go through all this trouble so that we can pass the i32 scale factor to the {gather,scatter}_base_offsets function as a separate scale factor for the offsets. This in turn is used in a way so that the LLVM x86 code generator matches it to apply x86's free scale by 2x, 4x, or 8x to one of two registers being added together for an addressing calculation. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01423">1423</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="opt_8cpp_source.html#l01379">lIs248Splat()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00204">LLVMInt32()</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01620">DetectGSBaseOffsetsPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a568fd43a32e1a91745ca4cd1d8fc6a32"></a><!-- doxytag: member="opt.cpp::lGetBasePointer" ref="a568fd43a32e1a91745ca4cd1d8fc6a32" args="(llvm::Value *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lGetBasePointer </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a llvm::Value representing a varying pointer, this function checks to see if all of the elements of the vector have the same value (i.e. there's a common base pointer). If so, it returns the common pointer value; otherwise it returns NULL. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01041">1041</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8cpp_source.html#l00067">g</a>, <a class="el" href="ispc_8h_source.html#l00072">ISPC_MAX_NVEC</a>, <a class="el" href="opt_8cpp_source.html#l01017">lCheckForActualPointer()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00566">LLVMFlattenInsertChain()</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="ispc_8h_source.html#l00358">Globals::target</a>, and <a class="el" href="ispc_8h_source.html#l00225">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01099">lGetBasePtrAndOffsets()</a>.</p>

</div>
</div>
<a class="anchor" id="ac6ced32908e9773085ec13530d64b96c"></a><!-- doxytag: member="opt.cpp::lGetBasePtrAndOffsets" ref="ac6ced32908e9773085ec13530d64b96c" args="(llvm::Value *ptrs, llvm::Value **offsets, llvm::Instruction *insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lGetBasePtrAndOffsets </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>ptrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Instruction *&#160;</td>
          <td class="paramname"><em>insertBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a varying pointer in ptrs, this function checks to see if it can be determined to be indexing from a common uniform base pointer. If so, the function returns the base pointer llvm::Value and initializes offsets with an int vector of the per-lane offsets </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01099">1099</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00059">Assert</a>, <a class="el" href="ispc_8cpp_source.html#l00067">g</a>, <a class="el" href="ispc_8h_source.html#l00209">Target::is32Bit</a>, <a class="el" href="ispc_8h_source.html#l00072">ISPC_MAX_NVEC</a>, <a class="el" href="opt_8cpp_source.html#l01041">lGetBasePointer()</a>, <a class="el" href="opt_8cpp_source.html#l01076">lGetConstantAddExprBaseOffset()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00204">LLVMInt32()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00320">LLVMInt32Vector()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00218">LLVMInt64()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00396">LLVMInt64Vector()</a>, <a class="el" href="parse_8yy.html">NULL</a>, and <a class="el" href="ispc_8h_source.html#l00358">Globals::target</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01620">DetectGSBaseOffsetsPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="af47f2481f316b98aa8a37354e1e1473c"></a><!-- doxytag: member="opt.cpp::lGetConstantAddExprBaseOffset" ref="af47f2481f316b98aa8a37354e1e1473c" args="(llvm::Constant *op0, llvm::Constant *op1, llvm::Constant **delta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Constant* lGetConstantAddExprBaseOffset </td>
          <td>(</td>
          <td class="paramtype">llvm::Constant *&#160;</td>
          <td class="paramname"><em>op0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Constant *&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Constant **&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given the two operands to a constant add expression, see if we have the form "base pointer + offset", whee op0 is the base pointer and op1 is the offset; if so return the base and the offset. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01076">1076</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01099">lGetBasePtrAndOffsets()</a>.</p>

</div>
</div>
<a class="anchor" id="aabbac44ab116503416aede9a33f1dd03"></a><!-- doxytag: member="opt.cpp::lGetMask" ref="aabbac44ab116503416aede9a33f1dd03" args="(llvm::Value *factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int lGetMask </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given an llvm::Value represinting a vector mask, see if the value is a constant. If so, return the integer mask found by taking the high bits of the mask values in turn and concatenating them into a single integer. In other words, given the 4-wide mask: &lt; 0xffffffff, 0, 0, 0xffffffff &gt;, we have 0b1001 = 9. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00627">627</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00059">Assert</a>, <a class="el" href="ispc_8cpp_source.html#l00067">g</a>, <a class="el" href="ispc_8cpp_source.html#l00313">Target::GetTargetMachine()</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="ispc_8h_source.html#l00358">Globals::target</a>, and <a class="el" href="ispc_8h_source.html#l00225">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00713">IntrinsicsOpt::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l00920">VSelMovmskOpt::runOnBasicBlock()</a>, <a class="el" href="opt_8cpp_source.html#l01816">MaskedStoreOptPass::runOnBasicBlock()</a>, and <a class="el" href="opt_8cpp_source.html#l01930">MaskedLoadOptPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ce816b84cb0c2ca769c486be11dde5f"></a><!-- doxytag: member="opt.cpp::lGetSourcePosFromMetadata" ref="a9ce816b84cb0c2ca769c486be11dde5f" args="(const llvm::Instruction *inst, SourcePos *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lGetSourcePosFromMetadata </td>
          <td>(</td>
          <td class="paramtype">const llvm::Instruction *&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSourcePos.html">SourcePos</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>We have a protocol with the front-end LLVM IR code generation process that allows us to encode the source file position that corresponds with instructions. (For example, this allows us to issue performance warnings related to things like scatter and gather after optimization has been performed, so that we aren't warning about scatters and gathers that have been improved to stores and loads by optimization passes.) Note that this is slightly redundant with the source file position encoding generated for debugging symbols, though we don't always generate debugging information but we do always generate this position data.</p>
<p>This function finds the <a class="el" href="structSourcePos.html" title="Representation of a range of positions in a source file.">SourcePos</a> that the metadata in the instruction (if present) corresponds to. See the implementation of <a class="el" href="classFunctionEmitContext.html#a9ee143b924166a394849030280512e00">FunctionEmitContext::addGSMetadata()</a>, which encodes the source position during code generation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>Instruction to try to find the source position of </td></tr>
    <tr><td class="paramname">pos</td><td>Output variable in which to store the position </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if source file position metadata was present and *pos has been set. False otherwise. </dd></dl>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00146">146</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00059">Assert</a>, and <a class="el" href="lex_8ll_source.html#l159240">filename</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02426">GSToLoadStorePass::runOnBasicBlock()</a>, and <a class="el" href="opt_8cpp_source.html#l02654">PseudoGSToGSPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ac08b89d83dd0f7a10af30116e34fccf1"></a><!-- doxytag: member="opt.cpp::lGetZeroOffsetVector" ref="ac08b89d83dd0f7a10af30116e34fccf1" args="(llvm::Value *origVec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::Value* lGetZeroOffsetVector </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>origVec</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01213">1213</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy_source.html#l269385">int32_t</a>, <a class="el" href="llvmutil_8h_source.html#l00089">LLVMTypes::Int32VectorType</a>, <a class="el" href="llvmutil_8cpp_source.html#l00320">LLVMInt32Vector()</a>, and <a class="el" href="llvmutil_8cpp_source.html#l00396">LLVMInt64Vector()</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01620">DetectGSBaseOffsetsPass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e3b263d76c38acfd2555bc6dbb61ac9"></a><!-- doxytag: member="opt.cpp::lIs248Splat" ref="a1e3b263d76c38acfd2555bc6dbb61ac9" args="(llvm::Value *v, int *splat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lIs248Splat </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>splat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l01379">1379</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l01423">lExtractOffsetVector248Scale()</a>.</p>

</div>
</div>
<a class="anchor" id="a432c7725f35dbabfc537a1f2b91b85ca"></a><!-- doxytag: member="opt.cpp::lIsSafeToBlend" ref="a432c7725f35dbabfc537a1f2b91b85ca" args="(llvm::Value *lvalue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lIsSafeToBlend </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>lvalue</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine attempts to determine if the given pointer in lvalue is pointing to stack-allocated memory. It's conservative in that it should never return true for non-stack allocated memory, but may return false for memory that actually is stack allocated. The basic strategy is to traverse through the operands and see if the pointer originally comes from an AllocaInst. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02028">2028</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8cpp_source.html#l00067">g</a>, <a class="el" href="ispc_8h_source.html#l00097">LLVM_TYPE_CONST</a>, <a class="el" href="parse_8yy.html">NULL</a>, <a class="el" href="ispc_8h_source.html#l00358">Globals::target</a>, and <a class="el" href="ispc_8h_source.html#l00225">Target::vectorWidth</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02076">PseudoMaskedStorePass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a22173061ee4fe22a8ed7f20e32b40ad8"></a><!-- doxytag: member="opt.cpp::lIsUndef" ref="a22173061ee4fe22a8ed7f20e32b40ad8" args="(llvm::Value *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lIsUndef </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given an llvm::Value, return true if we can determine that it's an undefined value. This only makes a weak attempt at chasing this down, only detecting flat-out undef values, and bitcasts of undef values.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Is it worth working harder to find more of these? It starts to get tricky, since having an undef operand doesn't necessarily mean that the result will be undefined. (And for that matter, is there an LLVM call that will do this for us?) </dd></dl>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00700">700</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l00713">IntrinsicsOpt::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ae60d89f84e134a3f8151f2c75639c6bc"></a><!-- doxytag: member="opt.cpp::lVectorIsLinear" ref="ae60d89f84e134a3f8151f2c75639c6bc" args="(llvm::Value *v, int vectorLength, int stride, std::vector&lt; llvm::PHINode * &gt; &amp;seenPhis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lVectorIsLinear </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vectorLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; llvm::PHINode * &gt; &amp;&#160;</td>
          <td class="paramname"><em>seenPhis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given vector of integer-typed values, see if the elements of the array have a step of 'stride' between their values. This function tries to handle as many possibilities as possible, including things like all elements equal to some non-constant value plus an integer offset, etc. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02266">2266</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="opt_8cpp_source.html#l02226">lCheckMulForLinear()</a>, <a class="el" href="llvmutil_8cpp_source.html#l00598">LLVMVectorValuesAllEqual()</a>, <a class="el" href="opt_8cpp_source.html#l02176">lVectorIsLinearConstantInts()</a>, <a class="el" href="parse_8yy.html">NULL</a>, and <a class="el" href="parse_8yy.html">stderr</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02226">lCheckMulForLinear()</a>, and <a class="el" href="opt_8cpp_source.html#l02426">GSToLoadStorePass::runOnBasicBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a4df2503b61941de507d4c287fc781829"></a><!-- doxytag: member="opt.cpp::lVectorIsLinearConstantInts" ref="a4df2503b61941de507d4c287fc781829" args="(llvm::ConstantVector *cv, int vectorLength, int stride)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool lVectorIsLinearConstantInts </td>
          <td>(</td>
          <td class="paramtype">llvm::ConstantVector *&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vectorLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a vector of compile-time constant integer values, test to see if they are a linear sequence of constant integers starting from an arbirary value but then having a step of value "stride" between elements. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l02176">2176</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="ispc_8h_source.html#l00059">Assert</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="opt_8cpp_source.html#l02266">lVectorIsLinear()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a7faa9c8af29d05713e5d15fdff1810"></a><!-- doxytag: member="opt.cpp::Optimize" ref="a2a7faa9c8af29d05713e5d15fdff1810" args="(llvm::Module *module, int optLevel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Optimize the functions in the given module, applying the specified level of optimization. optLevel zero corresponds to essentially no optimization--just enough to generate correct code, while level one corresponds to full optimization. </p>

<p>Definition at line <a class="el" href="opt_8cpp_source.html#l00256">256</a> of file <a class="el" href="opt_8cpp_source.html">opt.cpp</a>.</p>

<p>References <a class="el" href="opt_8cpp_source.html#l01778">CreateDetectGSBaseOffsetsPass()</a>, <a class="el" href="opt_8cpp_source.html#l02615">CreateGSToLoadStorePass()</a>, <a class="el" href="opt_8cpp_source.html#l00891">CreateIntrinsicsOptPass()</a>, <a class="el" href="opt_8cpp_source.html#l02844">CreateIsCompileTimeConstantPass()</a>, <a class="el" href="opt_8cpp_source.html#l02928">CreateMakeInternalFuncsStaticPass()</a>, <a class="el" href="opt_8cpp_source.html#l01995">CreateMaskedLoadOptPass()</a>, <a class="el" href="opt_8cpp_source.html#l01896">CreateMaskedStoreOptPass()</a>, <a class="el" href="opt_8cpp_source.html#l02744">CreatePseudoGSToGSPass()</a>, <a class="el" href="opt_8cpp_source.html#l02134">CreatePseudoMaskedStorePass()</a>, <a class="el" href="opt_8cpp_source.html#l00976">CreateVSelMovmskOptPass()</a>, <a class="el" href="ispc_8h_source.html#l00375">Globals::debugPrint</a>, <a class="el" href="ispc_8h_source.html#l00323">Opt::disableGatherScatterOptimizations</a>, <a class="el" href="ispc_8h_source.html#l00295">Opt::disableHandlePseudoMemoryOps</a>, <a class="el" href="ispc_8h_source.html#l00289">Opt::disableMaskAllOnOptimizations</a>, <a class="el" href="ispc_8cpp_source.html#l00067">g</a>, <a class="el" href="ispc_8h_source.html#l00200">Target::GENERIC</a>, <a class="el" href="ispc_8h_source.html#l00203">Target::isa</a>, <a class="el" href="ispc_8h_source.html#l00356">Globals::opt</a>, <a class="el" href="ispc_8h_source.html#l00358">Globals::target</a>, and <a class="el" href="ispc_8h_source.html#l00274">Opt::unrollLoops</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00219">Module::AddGlobalVariable()</a>, <a class="el" href="module_8cpp_source.html#l00150">Module::CompileFile()</a>, <a class="el" href="decl_8cpp_source.html#l00277">Declarator::GetType()</a>, and <a class="el" href="expr_8cpp_source.html#l00149">lArrayToPointer()</a>.</p>

</div>
</div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Sat Feb 4 2012 15:26:36 for Intel SPMD Program Compiler by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
