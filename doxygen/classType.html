<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Intel SPMD Program Compiler: Type Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>Type Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Type" -->
<p>Interface class that defines the type abstraction.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="type_8h_source.html">type.h</a>&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for Type:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
<div class="center"><img src="classType__inherit__graph.png" border="0" usemap="#Type_inherit__map" alt="Inheritance graph"/></div>
<map name="Type_inherit__map" id="Type_inherit__map">
<area shape="rect" id="node3" href="classAtomicType.html" title="AtomicType represents basic types like floats, ints, etc." alt="" coords="5,83,107,111"/><area shape="rect" id="node5" href="classCollectionType.html" title="Abstract base class for types that represent collections of other types." alt="" coords="131,83,251,111"/><area shape="rect" id="node17" href="classEnumType.html" title="Type implementation for enumerated types." alt="" coords="275,83,365,111"/><area shape="rect" id="node19" href="classFunctionType.html" title="Type representing a function (return type + argument types)" alt="" coords="389,83,499,111"/><area shape="rect" id="node21" href="classReferenceType.html" title="Type representing a reference to another (non&#45;reference) type." alt="" coords="523,83,643,111"/><area shape="rect" id="node7" href="classSequentialType.html" title="Abstract base class for types that represent sequences." alt="" coords="61,161,187,189"/><area shape="rect" id="node15" href="classStructType.html" title="Representation of a structure holding a number of members." alt="" coords="211,161,304,189"/><area shape="rect" id="node9" href="classArrayType.html" title="One&#45;dimensional array type." alt="" coords="20,238,111,266"/><area shape="rect" id="node13" href="classVectorType.html" title="A (short) vector of atomic types." alt="" coords="135,238,231,266"/><area shape="rect" id="node11" href="classSOAArrayType.html" title="&quot;Structure of arrays&quot; array type." alt="" coords="7,315,124,343"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center><!-- endSectionContent --></div>

<p><a href="classType-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a38ff6178597171c11f6e24566b251dea">IsBoolType</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#aeee9fe8b11fc75a300cf37f8b5c9f034">IsFloatType</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a3b2b570093e27170d582b67211dd6836">IsIntType</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a9fb5648ec4eb5b432723cf0b3332f8d0">IsUnsignedType</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a9a6d77fb89abc534e2ee1726cc13cf05">IsConstType</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ada5fd0f3e4c8e91a147aafae1410081c">IsNumericType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a0a997c011addd186c7a45a9352fe0edb">IsUniformType</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#affa605ca75a62c1ac079cfefa170cb3e">IsVaryingType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ab0eff8692794d3437a91404c98985d20">GetAsUniformType</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#aedfa3c719db7ab073c5e1f75b4041e55">GetAsVaryingType</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a127bfce35f03cb94bd25fbe07efb941a">GetAsUnsignedType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a51af28faf17eb05982547d9b340429eb">GetBaseType</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a1ef4f8a5d67d1ff6010ab1bcaaea4e6f">GetReferenceTarget</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a912c0c79b5fcc6f29674f6310bad5256">GetSOAType</a> (int width) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a91db376e89247992a5975936c5054eaa">GetAsConstType</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#ad97d28e97d0955f6b19bb24dbfcc22bf">GetAsNonConstType</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">GetString</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a7bd23bd909d493d271dbe1024d212c06">Mangle</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a7e35141766bbc63333953263cd85d883">GetCDeclaration</a> (const std::string &amp;name) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual LLVM_TYPE_CONST <br class="typebreak"/>
llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#aa7b08bf258938faa7e12b580b623621a">LLVMType</a> (llvm::LLVMContext *ctx) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual llvm::DIType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a8b6ded269378020c769915bbbff3d73c">GetDIType</a> (llvm::DIDescriptor scope) const =0</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a64dc632c4a2a352b75b16c7ece65ee5f">Equal</a> (const <a class="el" href="classType.html">Type</a> *a, const <a class="el" href="classType.html">Type</a> *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classType.html#a078b7dc77c288701d13abaa57434da91">MoreGeneralType</a> (const <a class="el" href="classType.html">Type</a> *type0, const <a class="el" href="classType.html">Type</a> *type1, <a class="el" href="structSourcePos.html">SourcePos</a> pos, const char *reason, bool forceVarying=false, int vecSize=0)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Interface class that defines the type abstraction. </p>
<p>Abstract base class that defines the interface that must be implemented for all types in the language. </p>

<p>Definition at line <a class="el" href="type_8h_source.html#l00053">53</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a64dc632c4a2a352b75b16c7ece65ee5f"></a><!-- doxytag: member="Type::Equal" ref="a64dc632c4a2a352b75b16c7ece65ee5f" args="(const Type *a, const Type *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::Equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"> <em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks two types for equality. Returns true if they are exactly the same, false otherwise. </p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l02090">2090</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="type_8h_source.html#l00678">FunctionType::GetArgumentTypes()</a>, <a class="el" href="type_8h_source.html#l00567">StructType::GetElementCount()</a>, <a class="el" href="type_8cpp_source.html#l01186">VectorType::GetElementCount()</a>, <a class="el" href="type_8cpp_source.html#l00823">ArrayType::GetElementCount()</a>, <a class="el" href="type_8cpp_source.html#l01520">StructType::GetElementType()</a>, <a class="el" href="type_8cpp_source.html#l01192">VectorType::GetElementType()</a>, <a class="el" href="type_8cpp_source.html#l00829">ArrayType::GetElementType()</a>, <a class="el" href="type_8cpp_source.html#l01585">ReferenceType::GetReferenceTarget()</a>, <a class="el" href="type_8h_source.html#l00669">FunctionType::GetReturnType()</a>, <a class="el" href="type_8cpp_source.html#l01579">ReferenceType::IsConstType()</a>, <a class="el" href="type_8cpp_source.html#l00540">EnumType::IsConstType()</a>, <a class="el" href="type_8cpp_source.html#l00510">EnumType::IsUniformType()</a>, <a class="el" href="parse_8yy.html">NULL</a>, and <a class="el" href="type_8h_source.html#l00295">EnumType::pos</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l04633">TypeCastExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l01745">SelectExpr::GetValue()</a>, <a class="el" href="module_8cpp_source.html#l01211">lAddTypeIfNew()</a>, <a class="el" href="builtins_8cpp_source.html#l00201">lCreateISPCSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l01988">lExactMatch()</a>, <a class="el" href="module_8cpp_source.html#l00311">lInitFunSymDecl()</a>, <a class="el" href="stmt_8cpp_source.html#l00130">lInitSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l02005">lMatchIgnoringReferences()</a>, <a class="el" href="expr_8cpp_source.html#l02021">lMatchIgnoringUniform()</a>, <a class="el" href="sym_8cpp_source.html#l00172">SymbolTable::LookupFunction()</a>, <a class="el" href="type_8cpp_source.html#l01958">MoreGeneralType()</a>, <a class="el" href="stmt_8cpp_source.html#l00327">DeclStmt::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l01132">BinaryExpr::Optimize()</a>, and <a class="el" href="expr_8cpp_source.html#l00128">Expr::TypeConv()</a>.</p>

</div>
</div>
<a class="anchor" id="a91db376e89247992a5975936c5054eaa"></a><!-- doxytag: member="Type::GetAsConstType" ref="a91db376e89247992a5975936c5054eaa" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetAsConstType </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a const version of this type. If it's already const, then the old <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> pointer is returned. </p>

<p>Implemented in <a class="el" href="classAtomicType.html#a9ca2fda82352665890b1462ebf37ab44">AtomicType</a>, <a class="el" href="classEnumType.html#ad1d1080e609abe0396bf927ecbcbbd15">EnumType</a>, <a class="el" href="classArrayType.html#a4ccb17ee3b649a2816ab8168b64e811b">ArrayType</a>, <a class="el" href="classSOAArrayType.html#a103e3eb44a8f8c531ee5dc03c4b5933e">SOAArrayType</a>, <a class="el" href="classVectorType.html#ae27955b420758d7e2ca3f26b71485ff1">VectorType</a>, <a class="el" href="classStructType.html#aab089740b8e26006d5056e895a000413">StructType</a>, <a class="el" href="classReferenceType.html#a141f641267214313f97fb161a3a5466b">ReferenceType</a>, and <a class="el" href="classFunctionType.html#ae07545f58b603d22f4ddfb69d4787236">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l03260">ConstExpr::ConstExpr()</a>, <a class="el" href="type_8cpp_source.html#l00972">SOAArrayType::GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l00811">ArrayType::GetAsConstType()</a>, <a class="el" href="type_8cpp_source.html#l01520">StructType::GetElementType()</a>, <a class="el" href="expr_8cpp_source.html#l04633">TypeCastExpr::GetValue()</a>, <a class="el" href="decl_8cpp_source.html#l00123">lGetType()</a>, <a class="el" href="expr_8cpp_source.html#l02005">lMatchIgnoringReferences()</a>, <a class="el" href="type_8cpp_source.html#l01958">MoreGeneralType()</a>, and <a class="el" href="expr_8cpp_source.html#l00128">Expr::TypeConv()</a>.</p>

</div>
</div>
<a class="anchor" id="ad97d28e97d0955f6b19bb24dbfcc22bf"></a><!-- doxytag: member="Type::GetAsNonConstType" ref="ad97d28e97d0955f6b19bb24dbfcc22bf" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetAsNonConstType </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a non-const version of this type. If it's already not const, then the old <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> pointer is returned. </p>

<p>Implemented in <a class="el" href="classAtomicType.html#a07f6d19eda86e0502144a73acd376623">AtomicType</a>, <a class="el" href="classEnumType.html#a9d954ae714eaedbc4d58e96f90fbf595">EnumType</a>, <a class="el" href="classArrayType.html#af0a6bb7ec4db0bbd03e1adf6fc8c304f">ArrayType</a>, <a class="el" href="classSOAArrayType.html#afed8963d27ab04928f228a330341f39f">SOAArrayType</a>, <a class="el" href="classVectorType.html#a819c61bbd35c74399ad876a9819a4c33">VectorType</a>, <a class="el" href="classStructType.html#afb84dd8fec7f7c2b0bdff451e4fb26db">StructType</a>, <a class="el" href="classReferenceType.html#a0f4fecfba8834ccdaaef0218cfc7a171">ReferenceType</a>, and <a class="el" href="classFunctionType.html#a0c03832895468cffeaebc272aa0f6ad2">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l00979">SOAArrayType::GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l00817">ArrayType::GetAsNonConstType()</a>, <a class="el" href="type_8cpp_source.html#l01656">ReferenceType::GetCDeclaration()</a>, <a class="el" href="expr_8cpp_source.html#l03895">ConstExpr::GetConstant()</a>, <a class="el" href="type_8cpp_source.html#l01635">ReferenceType::GetString()</a>, <a class="el" href="expr_8cpp_source.html#l01745">SelectExpr::GetValue()</a>, <a class="el" href="module_8cpp_source.html#l01211">lAddTypeIfNew()</a>, <a class="el" href="module_8cpp_source.html#l01081">lEmitStructDecls()</a>, <a class="el" href="expr_8cpp_source.html#l01988">lExactMatch()</a>, <a class="el" href="expr_8cpp_source.html#l02021">lMatchIgnoringUniform()</a>, <a class="el" href="stmt_8cpp_source.html#l01398">lProcessPrintArg()</a>, <a class="el" href="ctx_8cpp_source.html#l01570">FunctionEmitContext::maskedStore()</a>, <a class="el" href="type_8cpp_source.html#l01958">MoreGeneralType()</a>, <a class="el" href="expr_8cpp_source.html#l01132">BinaryExpr::Optimize()</a>, <a class="el" href="expr_8cpp_source.html#l00605">UnaryExpr::Optimize()</a>, and <a class="el" href="expr_8cpp_source.html#l00128">Expr::TypeConv()</a>.</p>

</div>
</div>
<a class="anchor" id="ab0eff8692794d3437a91404c98985d20"></a><!-- doxytag: member="Type::GetAsUniformType" ref="ab0eff8692794d3437a91404c98985d20" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetAsUniformType </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "uniform" instance of this type. If the type is already uniform, its "this" pointer will be returned. </p>

<p>Implemented in <a class="el" href="classAtomicType.html#a7c18848484228e3f8524b2d62c1a218b">AtomicType</a>, <a class="el" href="classEnumType.html#a81a73755f829e78e41f7096653783332">EnumType</a>, <a class="el" href="classArrayType.html#a742c7dc11c86929c494d62925f777ef7">ArrayType</a>, <a class="el" href="classSOAArrayType.html#a9b46fa5533c61eb36098b5fc167f4c74">SOAArrayType</a>, <a class="el" href="classVectorType.html#a3e3594b3341220222149f3fd8f405592">VectorType</a>, <a class="el" href="classStructType.html#af217d50c65ebbe90aa976268c157d3df">StructType</a>, <a class="el" href="classReferenceType.html#a118f51c75dc954db0caf9b01d039d059">ReferenceType</a>, and <a class="el" href="classFunctionType.html#afea1ec2e2e55becb419413e41d616733">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="ctx_8cpp_source.html#l01407">FunctionEmitContext::gather()</a>, <a class="el" href="type_8cpp_source.html#l01605">ReferenceType::GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l00958">SOAArrayType::GetAsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l00799">ArrayType::GetAsUniformType()</a>, <a class="el" href="decl_8cpp_source.html#l00123">lGetType()</a>, <a class="el" href="stmt_8cpp_source.html#l01398">lProcessPrintArg()</a>, <a class="el" href="expr_8cpp_source.html#l00605">UnaryExpr::Optimize()</a>, and <a class="el" href="ctx_8cpp_source.html#l01653">FunctionEmitContext::scatter()</a>.</p>

</div>
</div>
<a class="anchor" id="a127bfce35f03cb94bd25fbe07efb941a"></a><!-- doxytag: member="Type::GetAsUnsignedType" ref="a127bfce35f03cb94bd25fbe07efb941a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * Type::GetAsUnsignedType </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this is a signed integer type, return the unsigned version of the type. Otherwise, return the original type. </p>

<p>Reimplemented in <a class="el" href="classAtomicType.html#a5916f663a37b108719a93667e061ef7b">AtomicType</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01923">1923</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="decl_8cpp_source.html#l00123">lGetType()</a>.</p>

</div>
</div>
<a class="anchor" id="aedfa3c719db7ab073c5e1f75b4041e55"></a><!-- doxytag: member="Type::GetAsVaryingType" ref="aedfa3c719db7ab073c5e1f75b4041e55" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetAsVaryingType </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "varying" instance of this type. If the type is already uniform, its "this" pointer will be returned. </p>

<p>Implemented in <a class="el" href="classAtomicType.html#aa9f4455dfec5f9714315976603d29af9">AtomicType</a>, <a class="el" href="classEnumType.html#a9ffd999f0ad5eb3ea5f3f287293a1946">EnumType</a>, <a class="el" href="classArrayType.html#a7714386d2eb5ad482ab1b8b7bfd320a3">ArrayType</a>, <a class="el" href="classSOAArrayType.html#a9472013210600f515959c1498ac32ecb">SOAArrayType</a>, <a class="el" href="classVectorType.html#ae4d6866eb56c70856c472f48465e5260">VectorType</a>, <a class="el" href="classStructType.html#ae7f4e75c4942b5cb5ce6daaa5deb3d1a">StructType</a>, <a class="el" href="classReferenceType.html#a06dd94bbbd24f86288296e2f2295acab">ReferenceType</a>, and <a class="el" href="classFunctionType.html#a7b95328b75071c1bceab4059575eb70c">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01597">ReferenceType::GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l00951">SOAArrayType::GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l00793">ArrayType::GetAsVaryingType()</a>, <a class="el" href="expr_8cpp_source.html#l02885">StructMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l02720">IndexExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l00970">BinaryExpr::GetType()</a>, <a class="el" href="decl_8cpp_source.html#l00123">lGetType()</a>, <a class="el" href="expr_8cpp_source.html#l02021">lMatchIgnoringUniform()</a>, <a class="el" href="expr_8cpp_source.html#l04600">lUniformValueToVarying()</a>, <a class="el" href="type_8cpp_source.html#l01958">MoreGeneralType()</a>, and <a class="el" href="expr_8cpp_source.html#l01282">BinaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a51af28faf17eb05982547d9b340429eb"></a><!-- doxytag: member="Type::GetBaseType" ref="a51af28faf17eb05982547d9b340429eb" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetBaseType </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the basic root type of the given type. For example, for an array or short-vector, this returns the element type. For a struct or atomic type, it returns itself. </p>

<p>Implemented in <a class="el" href="classAtomicType.html#a49ebc38733592f94b6b58bc96757a0c6">AtomicType</a>, <a class="el" href="classEnumType.html#ada7821db322beafdaee560d6a74932d1">EnumType</a>, <a class="el" href="classArrayType.html#ac2a42e35be81b43993d2daefc02d5926">ArrayType</a>, <a class="el" href="classVectorType.html#affde79090b837ad37e1ad1a2c857ab8a">VectorType</a>, <a class="el" href="classStructType.html#a94ea104d21a014ca454fb4e51d4f8bc2">StructType</a>, <a class="el" href="classReferenceType.html#a51a2af593a7aa86fde715f9884b7a1a4">ReferenceType</a>, and <a class="el" href="classFunctionType.html#a0505addf60b72566c14f62cae3054e96">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01591">ReferenceType::GetBaseType()</a>, <a class="el" href="expr_8cpp_source.html#l01745">SelectExpr::GetValue()</a>, <a class="el" href="module_8cpp_source.html#l00270">lCheckForVaryingParameter()</a>, and <a class="el" href="module_8cpp_source.html#l00250">lRecursiveCheckVarying()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e35141766bbc63333953263cd85d883"></a><!-- doxytag: member="Type::GetCDeclaration" ref="a7e35141766bbc63333953263cd85d883" args="(const std::string &amp;name) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Type::GetCDeclaration </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> <em>name</em>&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a string that is the declaration of the same type in C syntax. </p>

<p>Implemented in <a class="el" href="classAtomicType.html#a2265daea3aae05bc483bed01cb95bbde">AtomicType</a>, <a class="el" href="classEnumType.html#aef6123ce599ecbfb5457a98d29be8fd6">EnumType</a>, <a class="el" href="classArrayType.html#a9101977af94bebe6ef2b7ca36debff3f">ArrayType</a>, <a class="el" href="classSOAArrayType.html#a1d8b743716baa455d1e6391e553d69e2">SOAArrayType</a>, <a class="el" href="classVectorType.html#ab1ca821f3386908229a99971700d84de">VectorType</a>, <a class="el" href="classStructType.html#aadacdef71c59d672d6a8603da1784641">StructType</a>, <a class="el" href="classReferenceType.html#ac4bc15b62e51a3ab4e9e3913959ea6b7">ReferenceType</a>, and <a class="el" href="classFunctionType.html#a90688df9ff3674c4baa71a663bfd90b2">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01827">FunctionType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l01656">ReferenceType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l01016">SOAArrayType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l00867">ArrayType::GetCDeclaration()</a>, <a class="el" href="module_8cpp_source.html#l01081">lEmitStructDecls()</a>, <a class="el" href="module_8cpp_source.html#l01180">lEmitVectorTypedefs()</a>, and <a class="el" href="module_8cpp_source.html#l01296">lPrintExternGlobals()</a>.</p>

</div>
</div>
<a class="anchor" id="a8b6ded269378020c769915bbbff3d73c"></a><!-- doxytag: member="Type::GetDIType" ref="a8b6ded269378020c769915bbbff3d73c" args="(llvm::DIDescriptor scope) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::DIType Type::GetDIType </td>
          <td>(</td>
          <td class="paramtype">llvm::DIDescriptor&#160;</td>
          <td class="paramname"> <em>scope</em>&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the DIType (LLVM's debugging information structure), corresponding to this type. </p>

<p>Implemented in <a class="el" href="classAtomicType.html#ad9578c90b6bf354eadcd11a2958cefcf">AtomicType</a>, <a class="el" href="classEnumType.html#a274ec08ec02e6b85f51a57cebb395034">EnumType</a>, <a class="el" href="classArrayType.html#aeb6c08334ad91a2801d89b45d00eec28">ArrayType</a>, <a class="el" href="classSOAArrayType.html#ac863293e344d93bd37848be1b24545fa">SOAArrayType</a>, <a class="el" href="classVectorType.html#aed5a430e9f14122aa53bc12df4263c41">VectorType</a>, <a class="el" href="classStructType.html#a44632b9008101e5281cead6f2539f57e">StructType</a>, <a class="el" href="classReferenceType.html#a09dd7f69931da8c6959ebc6ada540ffb">ReferenceType</a>, and <a class="el" href="classFunctionType.html#a7df9a46d5c710977a8112358d11afd44">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00493">Module::AddGlobal()</a>, <a class="el" href="ctx_8cpp_source.html#l00929">FunctionEmitContext::EmitFunctionParameterDebugInfo()</a>, <a class="el" href="ctx_8cpp_source.html#l00907">FunctionEmitContext::EmitVariableDebugInfo()</a>, <a class="el" href="ctx_8cpp_source.html#l00126">FunctionEmitContext::FunctionEmitContext()</a>, <a class="el" href="type_8cpp_source.html#l01700">ReferenceType::GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l01445">StructType::GetDIType()</a>, <a class="el" href="type_8cpp_source.html#l01046">SOAArrayType::GetDIType()</a>, and <a class="el" href="type_8cpp_source.html#l00895">ArrayType::GetDIType()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ef4f8a5d67d1ff6010ab1bcaaea4e6f"></a><!-- doxytag: member="Type::GetReferenceTarget" ref="a1ef4f8a5d67d1ff6010ab1bcaaea4e6f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * Type::GetReferenceTarget </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this is a reference type, returns the type it is referring to. For all other types, just returns its own type. </p>

<p>Reimplemented in <a class="el" href="classReferenceType.html#ad3eabdfac95c0fdd7618284de92ad7fb">ReferenceType</a>.</p>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01916">1916</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l02751">IndexExpr::GetLValue()</a>, <a class="el" href="expr_8cpp_source.html#l05049">DereferenceExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l02720">IndexExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l00460">lEmitPrePostIncDec()</a>, <a class="el" href="module_8cpp_source.html#l01231">lGetExportedTypes()</a>, <a class="el" href="expr_8cpp_source.html#l02005">lMatchIgnoringReferences()</a>, <a class="el" href="type_8cpp_source.html#l01958">MoreGeneralType()</a>, <a class="el" href="expr_8cpp_source.html#l02791">IndexExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l01660">AssignExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l00128">Expr::TypeConv()</a>.</p>

</div>
</div>
<a class="anchor" id="a912c0c79b5fcc6f29674f6310bad5256"></a><!-- doxytag: member="Type::GetSOAType" ref="a912c0c79b5fcc6f29674f6310bad5256" args="(int width) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classType.html">Type</a>* Type::GetSOAType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>width</em>&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a new type representing the current type laid out in width-wide SOA (structure of arrays) format. </p>

<p>Implemented in <a class="el" href="classAtomicType.html#a750eeeb927e5d088ff7bda06f01f5d3b">AtomicType</a>, <a class="el" href="classEnumType.html#a0230c89c20b8a4267424581cbcdbc195">EnumType</a>, <a class="el" href="classArrayType.html#a7fd568eae15c1ff2d74fa7c02b2329d5">ArrayType</a>, <a class="el" href="classSOAArrayType.html#af099c04d2425dd56f216a5dd848679d6">SOAArrayType</a>, <a class="el" href="classVectorType.html#a5e184a732d016257e087b1965ecbcf1f">VectorType</a>, <a class="el" href="classStructType.html#a9f90c1bb145ad8a88e48229bb3af5afc">StructType</a>, <a class="el" href="classReferenceType.html#abdfb5d35787805dc54b49637711a701b">ReferenceType</a>, and <a class="el" href="classFunctionType.html#ae145791e3a3222ade11d5fd0a302cd09">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01613">ReferenceType::GetSOAType()</a>, <a class="el" href="type_8cpp_source.html#l01342">StructType::GetSOAType()</a>, <a class="el" href="type_8cpp_source.html#l00965">SOAArrayType::GetSOAType()</a>, <a class="el" href="type_8cpp_source.html#l00805">ArrayType::GetSOAType()</a>, and <a class="el" href="type_8cpp_source.html#l01069">SOAArrayType::soaType()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d1539ea0f1c563872676c3ed3cfa568"></a><!-- doxytag: member="Type::GetString" ref="a4d1539ea0f1c563872676c3ed3cfa568" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Type::GetString </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a text representation of the type (for example, for use in warning and error messages). </p>

<p>Implemented in <a class="el" href="classAtomicType.html#ae1c9926d0364ffd9041d98cf9e80c871">AtomicType</a>, <a class="el" href="classEnumType.html#a9f571a2d443b4d62d5bd6f35ac7f0e4e">EnumType</a>, <a class="el" href="classArrayType.html#a9f0552ee4585f298ab98f108a7aab890">ArrayType</a>, <a class="el" href="classSOAArrayType.html#a272ed4f4523c4f8d68264d226695f431">SOAArrayType</a>, <a class="el" href="classVectorType.html#a4d77328bd40e8e2d011b3c8d492f5457">VectorType</a>, <a class="el" href="classStructType.html#a3340a328f2b3f964147e668ffeacb89f">StructType</a>, <a class="el" href="classReferenceType.html#a7382c38465789b7f1b02ed283786190f">ReferenceType</a>, and <a class="el" href="classFunctionType.html#a26fe1ec9fa3d939ccdf137ef18184afe">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="ctx_8cpp_source.html#l00613">FunctionEmitContext::CurrentLanesReturned()</a>, <a class="el" href="expr_8cpp_source.html#l02580">ExprList::GetConstant()</a>, <a class="el" href="type_8cpp_source.html#l01802">FunctionType::GetString()</a>, <a class="el" href="type_8cpp_source.html#l01635">ReferenceType::GetString()</a>, <a class="el" href="type_8cpp_source.html#l00986">SOAArrayType::GetString()</a>, <a class="el" href="type_8cpp_source.html#l00835">ArrayType::GetString()</a>, <a class="el" href="expr_8cpp_source.html#l00970">BinaryExpr::GetType()</a>, <a class="el" href="decl_8cpp_source.html#l00123">lGetType()</a>, <a class="el" href="stmt_8cpp_source.html#l00130">lInitSymbol()</a>, <a class="el" href="expr_8cpp_source.html#l01969">lPrintPassedTypes()</a>, <a class="el" href="stmt_8cpp_source.html#l01398">lProcessPrintArg()</a>, <a class="el" href="type_8cpp_source.html#l01934">lVectorConvert()</a>, <a class="el" href="type_8cpp_source.html#l01958">MoreGeneralType()</a>, <a class="el" href="decl_8cpp_source.html#l00059">DeclSpecs::Print()</a>, <a class="el" href="stmt_8cpp_source.html#l01131">ForStmt::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l00916">DoStmt::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l00510">IfStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l04770">TypeCastExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02791">IndexExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l01889">SelectExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l01660">AssignExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l01282">BinaryExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l00694">UnaryExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l00128">Expr::TypeConv()</a>.</p>

</div>
</div>
<a class="anchor" id="a38ff6178597171c11f6e24566b251dea"></a><!-- doxytag: member="Type::IsBoolType" ref="a38ff6178597171c11f6e24566b251dea" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Type::IsBoolType </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is boolean. In other words, this is true for individual bools and for short-vectors with underlying bool type, but not for arrays of bools. </p>

<p>Implemented in <a class="el" href="classAtomicType.html#ad6ed98b78d1561bee7dffeb8f77a5ce3">AtomicType</a>, <a class="el" href="classEnumType.html#a6604f1c2992b3881e0ad0f00fc93cbee">EnumType</a>, <a class="el" href="classArrayType.html#a445fc4c07127683e522813ea39d2b578">ArrayType</a>, <a class="el" href="classVectorType.html#acb7763664b9d905997301353adbc9045">VectorType</a>, <a class="el" href="classStructType.html#a2bf9d11863014d6d58ccb7bd74b2a4db">StructType</a>, <a class="el" href="classReferenceType.html#ade8733055109a4065e62414e46570fb6">ReferenceType</a>, and <a class="el" href="classFunctionType.html#a62671b908b8e98773d59dfa4b31e3862">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l00970">BinaryExpr::GetType()</a>, <a class="el" href="type_8cpp_source.html#l01742">FunctionType::IsBoolType()</a>, <a class="el" href="type_8cpp_source.html#l01555">ReferenceType::IsBoolType()</a>, <a class="el" href="stmt_8cpp_source.html#l01131">ForStmt::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l00916">DoStmt::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l00510">IfStmt::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l01282">BinaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a6d77fb89abc534e2ee1726cc13cf05"></a><!-- doxytag: member="Type::IsConstType" ref="a9a6d77fb89abc534e2ee1726cc13cf05" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Type::IsConstType </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if this type is 'const'-qualified. </p>

<p>Implemented in <a class="el" href="classAtomicType.html#af624e4674aa471c689550247ea6a5934">AtomicType</a>, <a class="el" href="classEnumType.html#afddfccd31b2387b0ab03dc4be86b4042">EnumType</a>, <a class="el" href="classArrayType.html#ac92ce0d837498af90182fe77542f064f">ArrayType</a>, <a class="el" href="classVectorType.html#a7d06faa8003edc8c99181e414ae733e3">VectorType</a>, <a class="el" href="classStructType.html#a26c69fac976b1cbc0e2778abd8679810">StructType</a>, <a class="el" href="classReferenceType.html#ae322f71beb240635596601d3d272c3e7">ReferenceType</a>, and <a class="el" href="classFunctionType.html#a2e2f700616e939d2f22ebfde308f74f3">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00493">Module::AddGlobal()</a>, <a class="el" href="stmt_8cpp_source.html#l00233">DeclStmt::EmitCode()</a>, <a class="el" href="type_8cpp_source.html#l01656">ReferenceType::GetCDeclaration()</a>, <a class="el" href="type_8cpp_source.html#l01635">ReferenceType::GetString()</a>, <a class="el" href="decl_8cpp_source.html#l00321">GetStructTypesNamesPositions()</a>, <a class="el" href="decl_8cpp_source.html#l00213">Declarator::GetType()</a>, <a class="el" href="type_8cpp_source.html#l01754">FunctionType::IsConstType()</a>, <a class="el" href="type_8cpp_source.html#l00774">ArrayType::IsConstType()</a>, <a class="el" href="expr_8cpp_source.html#l01988">lExactMatch()</a>, <a class="el" href="expr_8cpp_source.html#l02005">lMatchIgnoringReferences()</a>, <a class="el" href="stmt_8cpp_source.html#l00327">DeclStmt::Optimize()</a>, and <a class="el" href="expr_8cpp_source.html#l01660">AssignExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="aeee9fe8b11fc75a300cf37f8b5c9f034"></a><!-- doxytag: member="Type::IsFloatType" ref="aeee9fe8b11fc75a300cf37f8b5c9f034" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Type::IsFloatType </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is float or double. In other words, this is true for individual floats/doubles and for short-vectors of them, but not for arrays of them. </p>

<p>Implemented in <a class="el" href="classAtomicType.html#a2dcfce337e9ce0a0e3c749b0eb2e135f">AtomicType</a>, <a class="el" href="classEnumType.html#a21f570eed317ac1bc701bdfeaab82bda">EnumType</a>, <a class="el" href="classArrayType.html#a7ecfafe295e93746c5c2ec4ca9423996">ArrayType</a>, <a class="el" href="classVectorType.html#af57ee9fb1ea34c68d4d7053558de1825">VectorType</a>, <a class="el" href="classStructType.html#aa9646715c645651f8e2361de73857dea">StructType</a>, <a class="el" href="classReferenceType.html#a48f17712c8737276451ca589f6faae12">ReferenceType</a>, and <a class="el" href="classFunctionType.html#a03b05b6fb53707e4fb7d845416801f9c">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01730">FunctionType::IsFloatType()</a>, <a class="el" href="type_8cpp_source.html#l01561">ReferenceType::IsFloatType()</a>, <a class="el" href="type_8h_source.html#l00079">IsNumericType()</a>, <a class="el" href="expr_8cpp_source.html#l00823">lEmitBinaryArith()</a>, <a class="el" href="expr_8cpp_source.html#l00866">lEmitBinaryCmp()</a>, <a class="el" href="expr_8cpp_source.html#l00521">lEmitNegate()</a>, <a class="el" href="expr_8cpp_source.html#l00460">lEmitPrePostIncDec()</a>, and <a class="el" href="expr_8cpp_source.html#l01282">BinaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b2b570093e27170d582b67211dd6836"></a><!-- doxytag: member="Type::IsIntType" ref="a3b2b570093e27170d582b67211dd6836" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Type::IsIntType </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is an integer type. In other words, this is true for individual integers and for short-vectors of integer types, but not for arrays of integer types. </p>

<p>Implemented in <a class="el" href="classAtomicType.html#af56b796c630a0bf50433a43ab46cb05b">AtomicType</a>, <a class="el" href="classEnumType.html#affcbabed8f99a5ff3f97be76b1748e00">EnumType</a>, <a class="el" href="classArrayType.html#a9528bb4122b02bbe6ce983aa2ee5a866">ArrayType</a>, <a class="el" href="classVectorType.html#ae37497e660f800bd847c85daa97d43f2">VectorType</a>, <a class="el" href="classStructType.html#ab3016acb9dc9f2a739e2f7695e19858a">StructType</a>, <a class="el" href="classReferenceType.html#a9374c3ca367904600d63230df685e4b0">ReferenceType</a>, and <a class="el" href="classFunctionType.html#ab13379247f598875f1ea850d7e02c471">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01736">FunctionType::IsIntType()</a>, <a class="el" href="type_8cpp_source.html#l01567">ReferenceType::IsIntType()</a>, <a class="el" href="type_8h_source.html#l00079">IsNumericType()</a>, <a class="el" href="expr_8cpp_source.html#l00521">lEmitNegate()</a>, <a class="el" href="expr_8cpp_source.html#l01282">BinaryExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l00694">UnaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="ada5fd0f3e4c8e91a147aafae1410081c"></a><!-- doxytag: member="Type::IsNumericType" ref="ada5fd0f3e4c8e91a147aafae1410081c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsNumericType </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is a float or integer type. </p>

<p>Definition at line <a class="el" href="type_8h_source.html#l00079">79</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>References <a class="el" href="classType.html#aeee9fe8b11fc75a300cf37f8b5c9f034">IsFloatType()</a>, and <a class="el" href="classType.html#a3b2b570093e27170d582b67211dd6836">IsIntType()</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l00970">BinaryExpr::GetType()</a>, <a class="el" href="stmt_8cpp_source.html#l01131">ForStmt::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l00916">DoStmt::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l00510">IfStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l01282">BinaryExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l00694">UnaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a997c011addd186c7a45a9352fe0edb"></a><!-- doxytag: member="Type::IsUniformType" ref="a0a997c011addd186c7a45a9352fe0edb" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Type::IsUniformType </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is uniform </p>

<p>Implemented in <a class="el" href="classAtomicType.html#a3b19eee5cbebd7f904541187aebd7f88">AtomicType</a>, <a class="el" href="classEnumType.html#aac401a60a84fa2813f427348e8cf9ba4">EnumType</a>, <a class="el" href="classArrayType.html#aba0a4ddc0273c4ada6f5934efc62ca48">ArrayType</a>, <a class="el" href="classVectorType.html#a14870f39f9a5e7e0ee80518a413da178">VectorType</a>, <a class="el" href="classStructType.html#ada1205c6d10969b84a8cac6aad0f64a8">StructType</a>, <a class="el" href="classReferenceType.html#ace1756f278e4a45da2dadfd2a94eb0bc">ReferenceType</a>, and <a class="el" href="classFunctionType.html#a5a9ec938e7139c2cccec59db5d232fd1">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l03360">ConstExpr::ConstExpr()</a>, <a class="el" href="stmt_8cpp_source.html#l00983">ForStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l00803">DoStmt::EmitCode()</a>, <a class="el" href="stmt_8cpp_source.html#l00425">IfStmt::EmitCode()</a>, <a class="el" href="expr_8cpp_source.html#l03895">ConstExpr::GetConstant()</a>, <a class="el" href="decl_8cpp_source.html#l00321">GetStructTypesNamesPositions()</a>, <a class="el" href="expr_8cpp_source.html#l02720">IndexExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04633">TypeCastExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l01745">SelectExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l01558">AssignExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l01724">FunctionType::IsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l01549">ReferenceType::IsUniformType()</a>, <a class="el" href="type_8cpp_source.html#l00744">ArrayType::IsUniformType()</a>, <a class="el" href="type_8h_source.html#l00085">IsVaryingType()</a>, <a class="el" href="expr_8cpp_source.html#l01060">lConstFoldBinLogicalOp()</a>, <a class="el" href="expr_8cpp_source.html#l00460">lEmitPrePostIncDec()</a>, <a class="el" href="expr_8cpp_source.html#l00349">lLLVMConstantValue()</a>, <a class="el" href="expr_8cpp_source.html#l02021">lMatchIgnoringUniform()</a>, <a class="el" href="expr_8cpp_source.html#l00332">lMatchingBoolType()</a>, <a class="el" href="expr_8cpp_source.html#l02040">lMatchWithTypeConvSameVariability()</a>, <a class="el" href="stmt_8cpp_source.html#l01398">lProcessPrintArg()</a>, <a class="el" href="ctx_8cpp_source.html#l01747">FunctionEmitContext::StoreInst()</a>, <a class="el" href="stmt_8cpp_source.html#l01131">ForStmt::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l00916">DoStmt::TypeCheck()</a>, <a class="el" href="stmt_8cpp_source.html#l00510">IfStmt::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l04770">TypeCastExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l02791">IndexExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l01282">BinaryExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l00128">Expr::TypeConv()</a>.</p>

</div>
</div>
<a class="anchor" id="a9fb5648ec4eb5b432723cf0b3332f8d0"></a><!-- doxytag: member="Type::IsUnsignedType" ref="a9fb5648ec4eb5b432723cf0b3332f8d0" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Type::IsUnsignedType </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is unsigned. In other words, this is true for unsigned integers and short vectors of unsigned integer types. </p>

<p>Implemented in <a class="el" href="classAtomicType.html#a76f179b01685c3d41ce688a7f1baa912">AtomicType</a>, <a class="el" href="classEnumType.html#a08eb73c1e25ad98e693a8f8a6b74fa2e">EnumType</a>, <a class="el" href="classArrayType.html#a92bafc4b556538aebdeee86208086ec9">ArrayType</a>, <a class="el" href="classVectorType.html#a268e3f34196dffb3e82178637f1be1ae">VectorType</a>, <a class="el" href="classStructType.html#a312f5658f30b85f6f7fe902554509255">StructType</a>, <a class="el" href="classReferenceType.html#a2470b364125f12442726892a446b421f">ReferenceType</a>, and <a class="el" href="classFunctionType.html#a568bda9e9c775f80481d4f11c840d718">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01748">FunctionType::IsUnsignedType()</a>, <a class="el" href="type_8cpp_source.html#l01573">ReferenceType::IsUnsignedType()</a>, <a class="el" href="expr_8cpp_source.html#l00823">lEmitBinaryArith()</a>, and <a class="el" href="expr_8cpp_source.html#l00866">lEmitBinaryCmp()</a>.</p>

</div>
</div>
<a class="anchor" id="affa605ca75a62c1ac079cfefa170cb3e"></a><!-- doxytag: member="Type::IsVaryingType" ref="affa605ca75a62c1ac079cfefa170cb3e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::IsVaryingType </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the underlying type is varying </p>

<p>Definition at line <a class="el" href="type_8h_source.html#l00085">85</a> of file <a class="el" href="type_8h_source.html">type.h</a>.</p>

<p>References <a class="el" href="classType.html#a0a997c011addd186c7a45a9352fe0edb">IsUniformType()</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l03889">ConstExpr::Count()</a>, <a class="el" href="type_8cpp_source.html#l01597">ReferenceType::GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l01322">StructType::GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l00552">EnumType::GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l00249">AtomicType::GetAsVaryingType()</a>, <a class="el" href="expr_8cpp_source.html#l03895">ConstExpr::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l02885">StructMemberExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l01843">SelectExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l04633">TypeCastExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l03556">ConstExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l00921">BinaryExpr::GetValue()</a>, <a class="el" href="type_8cpp_source.html#l01248">VectorType::getVectorMemoryCount()</a>, <a class="el" href="expr_8cpp_source.html#l00823">lEmitBinaryArith()</a>, <a class="el" href="expr_8cpp_source.html#l00866">lEmitBinaryCmp()</a>, <a class="el" href="stmt_8cpp_source.html#l00756">lHasVaryingBreakOrContinue()</a>, <a class="el" href="expr_8cpp_source.html#l02021">lMatchIgnoringUniform()</a>, <a class="el" href="ctx_8cpp_source.html#l01366">FunctionEmitContext::LoadInst()</a>, <a class="el" href="module_8cpp_source.html#l00250">lRecursiveCheckVarying()</a>, <a class="el" href="expr_8cpp_source.html#l04084">lTypeConvAtomic()</a>, <a class="el" href="expr_8cpp_source.html#l04600">lUniformValueToVarying()</a>, <a class="el" href="type_8cpp_source.html#l01958">MoreGeneralType()</a>, <a class="el" href="expr_8cpp_source.html#l04842">TypeCastExpr::Optimize()</a>, <a class="el" href="ctx_8cpp_source.html#l01653">FunctionEmitContext::scatter()</a>, <a class="el" href="expr_8cpp_source.html#l01889">SelectExpr::TypeCheck()</a>, <a class="el" href="expr_8cpp_source.html#l01282">BinaryExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l00128">Expr::TypeConv()</a>.</p>

</div>
</div>
<a class="anchor" id="aa7b08bf258938faa7e12b580b623621a"></a><!-- doxytag: member="Type::LLVMType" ref="aa7b08bf258938faa7e12b580b623621a" args="(llvm::LLVMContext *ctx) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual LLVM_TYPE_CONST llvm::Type* Type::LLVMType </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"> <em>ctx</em>&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the LLVM type corresponding to this ispc type </p>

<p>Implemented in <a class="el" href="classAtomicType.html#a7c38ab920c31214ba5cf963c94e58f8e">AtomicType</a>, <a class="el" href="classEnumType.html#ab517f3fc75f8ac183cb27c1933ad816e">EnumType</a>, <a class="el" href="classArrayType.html#a765fb2392eb2b512b8d4627ba0ad5049">ArrayType</a>, <a class="el" href="classSOAArrayType.html#a125cc14f1d9cd133367433a2e4ff5fb3">SOAArrayType</a>, <a class="el" href="classVectorType.html#adab71a5d675f778406bab04194c7e312">VectorType</a>, <a class="el" href="classStructType.html#a8120a0acd19e9e1bccdec87af0e2be51">StructType</a>, <a class="el" href="classReferenceType.html#ab175c16c2ef42c8fdd9465ec15ba2cc0">ReferenceType</a>, and <a class="el" href="classFunctionType.html#a49b2b25b02edde4b8f9d3323b0c91485">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="module_8cpp_source.html#l00493">Module::AddGlobal()</a>, <a class="el" href="stmt_8cpp_source.html#l00233">DeclStmt::EmitCode()</a>, <a class="el" href="ctx_8cpp_source.html#l00126">FunctionEmitContext::FunctionEmitContext()</a>, <a class="el" href="ctx_8cpp_source.html#l01407">FunctionEmitContext::gather()</a>, <a class="el" href="expr_8cpp_source.html#l02580">ExprList::GetConstant()</a>, <a class="el" href="expr_8cpp_source.html#l04633">TypeCastExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l03129">MemberExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l02689">IndexExpr::GetValue()</a>, <a class="el" href="expr_8cpp_source.html#l02267">FunctionCallExpr::GetValue()</a>, <a class="el" href="stmt_8cpp_source.html#l00130">lInitSymbol()</a>, <a class="el" href="type_8cpp_source.html#l01862">FunctionType::LLVMFunctionType()</a>, <a class="el" href="type_8cpp_source.html#l01689">ReferenceType::LLVMType()</a>, <a class="el" href="type_8cpp_source.html#l01434">StructType::LLVMType()</a>, <a class="el" href="type_8cpp_source.html#l00732">ArrayType::LLVMType()</a>, <a class="el" href="stmt_8cpp_source.html#l01398">lProcessPrintArg()</a>, <a class="el" href="expr_8cpp_source.html#l04600">lUniformValueToVarying()</a>, and <a class="el" href="ctx_8cpp_source.html#l01653">FunctionEmitContext::scatter()</a>.</p>

</div>
</div>
<a class="anchor" id="a7bd23bd909d493d271dbe1024d212c06"></a><!-- doxytag: member="Type::Mangle" ref="a7bd23bd909d493d271dbe1024d212c06" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Type::Mangle </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a string that represents the mangled type (for use in mangling function symbol names for function overloading). The various Types implementations of this method should collectively ensure that all of them use mangling schemes that are guaranteed not to clash. </p>

<p>Implemented in <a class="el" href="classAtomicType.html#afc3a03de854dddee9c9d33fa53a6c757">AtomicType</a>, <a class="el" href="classEnumType.html#a4f49d85fdb766b684bf7ab8d0c440c52">EnumType</a>, <a class="el" href="classArrayType.html#aa5978b1550276038bbf17b09bccbffc3">ArrayType</a>, <a class="el" href="classSOAArrayType.html#ab307bbab3a4371eaf1a152da0f61be1a">SOAArrayType</a>, <a class="el" href="classVectorType.html#afd4698761398f68cdf7aea539eaff557">VectorType</a>, <a class="el" href="classStructType.html#aef0228ac91c3f29af7e7d42cc06e1cf3">StructType</a>, <a class="el" href="classReferenceType.html#a057ea1fec15ada012200e2d7ad33914f">ReferenceType</a>, and <a class="el" href="classFunctionType.html#a34f7649296f79dc80f636e2335e8c85c">FunctionType</a>.</p>

<p>Referenced by <a class="el" href="type_8cpp_source.html#l01646">ReferenceType::Mangle()</a>, <a class="el" href="type_8cpp_source.html#l01009">SOAArrayType::Mangle()</a>, <a class="el" href="type_8cpp_source.html#l00855">ArrayType::Mangle()</a>, and <a class="el" href="sym_8cpp_source.html#l00058">Symbol::MangledName()</a>.</p>

</div>
</div>
<a class="anchor" id="a078b7dc77c288701d13abaa57434da91"></a><!-- doxytag: member="Type::MoreGeneralType" ref="a078b7dc77c288701d13abaa57434da91" args="(const Type *type0, const Type *type1, SourcePos pos, const char *reason, bool forceVarying=false, int vecSize=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType.html">Type</a> * Type::MoreGeneralType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"> <em>type0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classType.html">Type</a> *&#160;</td>
          <td class="paramname"> <em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSourcePos.html">SourcePos</a>&#160;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>forceVarying</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>vecSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given two types, returns the least general <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a> that is more general than both of them. (i.e. that can represent their values without any loss of data.) If there is no such <a class="el" href="classType.html" title="Interface class that defines the type abstraction.">Type</a>, return NULL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type0</td><td>First of the two types </td></tr>
    <tr><td class="paramname">type1</td><td>Second of the two types </td></tr>
    <tr><td class="paramname">pos</td><td>Source file position where the general type is needed. </td></tr>
    <tr><td class="paramname">reason</td><td>String describing the context of why the general type is needed (e.g. "+ operator"). </td></tr>
    <tr><td class="paramname">forceVarying</td><td>If <code>true</code>, then make sure that the returned type is "varying". </td></tr>
    <tr><td class="paramname">vecSize</td><td>The vector size of the returned type. If non-zero, the returned type will be a <a class="el" href="classVectorType.html" title="A (short) vector of atomic types.">VectorType</a> of the more general type with given length. If zero, this parameter has no effect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The more general type, based on the provided parameters.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>the vecSize and forceVarying parts of this should probably be factored out and done separately in the cases when needed.</dd></dl>

<p>Definition at line <a class="el" href="type_8cpp_source.html#l01958">1958</a> of file <a class="el" href="type_8cpp_source.html">type.cpp</a>.</p>

<p>References <a class="el" href="parse_8yy.html">assert</a>, <a class="el" href="type_8h_source.html#l00225">AtomicType::basicType</a>, <a class="el" href="type_8cpp_source.html#l02090">Equal()</a>, <a class="el" href="util_8cpp_source.html#l00260">Error()</a>, <a class="el" href="classType.html#a91db376e89247992a5975936c5054eaa">GetAsConstType()</a>, <a class="el" href="classType.html#ad97d28e97d0955f6b19bb24dbfcc22bf">GetAsNonConstType()</a>, <a class="el" href="classType.html#aedfa3c719db7ab073c5e1f75b4041e55">GetAsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l01186">VectorType::GetElementCount()</a>, <a class="el" href="type_8cpp_source.html#l01192">VectorType::GetElementType()</a>, <a class="el" href="type_8cpp_source.html#l01916">GetReferenceTarget()</a>, <a class="el" href="classType.html#a4d1539ea0f1c563872676c3ed3cfa568">GetString()</a>, <a class="el" href="type_8h_source.html#l00085">IsVaryingType()</a>, <a class="el" href="type_8cpp_source.html#l01934">lVectorConvert()</a>, and <a class="el" href="parse_8yy.html">NULL</a>.</p>

<p>Referenced by <a class="el" href="expr_8cpp_source.html#l01843">SelectExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l00970">BinaryExpr::GetType()</a>, <a class="el" href="expr_8cpp_source.html#l01889">SelectExpr::TypeCheck()</a>, and <a class="el" href="expr_8cpp_source.html#l01282">BinaryExpr::TypeCheck()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="type_8h_source.html">type.h</a></li>
<li><a class="el" href="type_8cpp_source.html">type.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Aug 17 2011 15:15:09 for Intel SPMD Program Compiler by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
